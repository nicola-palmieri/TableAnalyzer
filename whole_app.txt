# ===============================================================
# ðŸ§ª Table Analyzer â€” One-way ANOVA Module (Clean & Minimal)
# ===============================================================

one_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(
          6,
          with_help_tooltip(
            actionButton(ns("run"), "Show results", width = "100%"),
            "Run the ANOVA using the selected response and group variable."
          )
        ),
        column(
          6,
          with_help_tooltip(
            downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
            "Export the ANOVA summaries, post-hoc tests, and diagnostics."
          )
        )
      )
    ),
    results = uiOutput(ns("summary_ui"))
  )
}

one_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    responses <- multi_response_server("response", filtered_data)
    strat_info <- stratification_server("strat", filtered_data)
    
    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      cat_cols <- names(data)[sapply(data, is.factor) | sapply(data, is.character)]
      
      tagList(
        multi_response_ui(ns("response")),
        with_help_tooltip(
          selectInput(
            ns("group"),
            "Categorical predictor",
            choices = cat_cols,
            selected = if (length(cat_cols) > 0) cat_cols[1] else NULL
          ),
          "Choose the grouping variable that defines the comparison categories."
        )
      )
    })
    
    output$level_order <- renderUI({
      req(filtered_data(), input$group)
      levels <- resolve_order_levels(filtered_data()[[input$group]])
      with_help_tooltip(
        selectInput(
          ns("order"),
          "Order of levels (first = reference)",
          choices = levels,
          selected = levels,
          multiple = TRUE
        ),
        "Arrange the group levels; the first level is used as the reference in outputs."
      )
    })
    
    models <- eventReactive(input$run, {
      df <- filtered_data()
      req(df, input$group, input$order)
      resp_vals <- responses()
      validate(need(length(resp_vals) > 0, "Select at least one response variable."))
      validate_numeric_columns(df, resp_vals, "response variables")
      prepare_stratified_anova(
        df = df,
        responses = resp_vals,
        model = "oneway_anova",
        factor1_var = input$group,
        factor1_order = input$order,
        stratification = strat_info()
      )
    })
    
    output$download_all <- downloadHandler(
      filename = function() {
        info <- models()
        n_resp <- length(info$responses)
        n_strata <- length(info$strata$levels %||% NULL)
        label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        paste0("anova_results_", n_resp, "resp_", label, "_", format(Sys.time(), "%Y%m%d-%H%M"), ".docx")
      },
      content = function(file) download_all_anova_results(models(), file)
    )
    
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "One-way ANOVA")
    })
    
    bind_anova_outputs(ns, output, models)
    
    anova_results <- reactive({
      mod <- models()
      req(mod)
      res <- compile_anova_results(mod)

      list(
        analysis_type = "ANOVA",
        type = "oneway_anova",
        data_used = mod$data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = list(
          n = nrow(mod$data_used),
          vars = names(mod$data_used)
        ),
        errors = res$errors,
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })
    
    
    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” One-way ANOVA (Apply-button version)
# ===============================================================

visualize_oneway_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize one-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      
      selectInput(
        ns("plot_type"),
        label = "Select visualization type",
        choices = c(
          "Lineplots (mean Â± SE)" = "lineplot_mean_se",
          "Barplots (mean Â± SE)"  = "barplot_mean_se"
        ),
        selected = "lineplot_mean_se"
      ),
      
      conditionalPanel(
        condition = sprintf("input['%s'] === 'lineplot_mean_se'", ns("plot_type")),
        fluidRow(
          column(6, checkboxInput(ns("lineplot_show_lines"),  "Connect means with lines", value = TRUE)),
          column(6, checkboxInput(ns("lineplot_show_jitter"), "Overlay jittered data",  value = FALSE))
        )
      ),
      
      checkboxInput(ns("share_y_axis"), "Use common y-axis across plots", value = FALSE),
      
      subplot_size_ui(ns),
      uiOutput(ns("layout_controls")),
      
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = FALSE)),
        column(6, base_size_ui(ns, default = 13))
      ),
      
      br(),
      
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"))
      )
    ),
    
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}


visualize_oneway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL
    )
    
    df <- reactive(filtered_data())
    
    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = reactive(NULL),
      multi_group = FALSE
    )
    
    base_size <- base_size_server(input = input, default = 14)
    
    strata_grid   <- plot_grid_server("strata_grid")
    response_grid <- plot_grid_server("response_grid")
    
    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })
    
    observeEvent(input$apply_plot, {
      data <- df()
      info <- model_info()
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data or ANOVA results available."
        stored$plot <- NULL
        return()
      }
      
      layout_inputs <- list(
        strata_rows = strata_grid$rows(),
        strata_cols = strata_grid$cols(),
        resp_rows   = response_grid$rows(),
        resp_cols   = response_grid$cols()
      )
      
      results <- list(
        lineplot_mean_se = plot_anova_lineplot_meanse(
          data, info, layout_inputs,
          line_colors  = custom_colors(),
          base_size    = base_size(),
          show_lines   = input$lineplot_show_lines,
          show_jitter  = input$lineplot_show_jitter,
          share_y_axis = input$share_y_axis
        ),
        barplot_mean_se = plot_anova_barplot_meanse(
          data, info,
          layout_values     = layout_inputs,
          line_colors       = custom_colors(),
          base_size         = base_size(),
          posthoc_all       = info$posthoc,
          share_y_axis      = input$share_y_axis
        )
      )
      
      chosen <- input$plot_type
      chosen_result <- results[[chosen]]

      stored$warning <- chosen_result$warning
      stored$plot    <- chosen_result$plot
      stored$layout  <- chosen_result$layout

      apply_grid_defaults_if_empty(
        input,
        session,
        "strata_grid",
        chosen_result$defaults$strata,
        n_items = chosen_result$panel_counts$strata
      )

      apply_grid_defaults_if_empty(
        input,
        session,
        "response_grid",
        chosen_result$defaults$responses,
        n_items = chosen_result$panel_counts$responses
      )
    })
    
    output$plot_warning <- renderUI({
      if (!is.null(stored$warning)) {
        div(class = "alert alert-warning", HTML(stored$warning))
      }
    })
    
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_width * (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
    },
    height = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_height * (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
    },
    res = 96)
    
    output$download_plot <- downloadHandler(
      filename = function() paste0("anova_plot_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        req(!is.null(lay))
        
        total_cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
        total_rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
        
        # Pixels â†’ inches conversion
        w_in <- (stored$plot_width  * total_cols) / 96
        h_in <- (stored$plot_height * total_rows) / 96
        
        ggsave(
          filename = file,
          plot = p,
          dpi = 300,
          width = w_in,
          height = h_in,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}


#### Section: Barplot Construction ####

plot_anova_barplot_meanse <- function(data,
                                      info,
                                      layout_values = list(),
                                      line_colors = NULL,
                                      base_size = 14,
                                      posthoc_all = NULL,
                                      share_y_axis = FALSE,
                                      common_legend = FALSE,
                                      legend_position = NULL) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2

  allowed_positions <- c("bottom", "top", "left", "right")
  legend_position_value <- if (!is.null(legend_position) && legend_position %in% allowed_positions) legend_position else "bottom"

  if (is.null(factor1) || length(context$responses) == 0) {
    return(NULL)
  }

  shared_y_limits <- if (isTRUE(share_y_axis)) {
    compute_barplot_shared_limits(
      context,
      data,
      factor1,
      factor2,
      posthoc_all
    )
  } else {
    NULL
  }
  
  base_fill <- if (!is.null(line_colors) && length(line_colors) > 0) unname(line_colors)[1] else "#3E8FC4"

  response_plots <- list()
  strata_panel_count <- context$initial_strata_panels

  build_response_plot <- function(resp) {
    posthoc_entry <- get_posthoc_entry_for_response(posthoc_all, resp)
    stats_entries <- generate_anova_stats_entries(
      context = context,
      data = data,
      resp = resp,
      factor1 = factor1,
      factor2 = factor2,
      posthoc_entry = posthoc_entry
    )

    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      stratum_plots <- lapply(stats_entries, function(entry) {
        build_bar_plot_panel(
          stats_df = entry$stats_df,
          title_text = entry$label,
          factor1 = factor1,
          factor2 = factor2,
          line_colors = line_colors,
          base_fill = base_fill,
          base_size = base_size,
          posthoc_entry = entry$posthoc,
          nested_posthoc = entry$posthoc,
          y_limits = shared_y_limits
        )
      })
      names(stratum_plots) <- vapply(stats_entries, function(x) x$label, character(1))
      stratum_plots <- Filter(Negate(is.null), stratum_plots)

      if (!length(stratum_plots)) return(NULL)

      strata_panel_count <<- max(strata_panel_count, length(stratum_plots))
      combined <- patchwork::wrap_plots(
        plotlist = stratum_plots,
        nrow = context$strata_layout$nrow,
        ncol = context$strata_layout$ncol
      )

      title_plot <- ggplot() +
        ta_plot_theme_void() +
        ggtitle(resp) +
        theme(plot.title = element_text(size = base_size, face = "bold", hjust = 0.5))

      title_plot / combined + patchwork::plot_layout(heights = c(0.08, 1))
    } else if (length(stats_entries) > 0) {
      entry <- stats_entries[[1]]
      build_bar_plot_panel(
        stats_df = entry$stats_df,
        title_text = entry$label,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_fill = base_fill,
        base_size = base_size,
        posthoc_entry = entry$posthoc,
        nested_posthoc = entry$posthoc,
        y_limits = shared_y_limits
      )
    }
  }

  response_plots <- lapply(context$responses, build_response_plot)
  names(response_plots) <- context$responses
  response_plots <- Filter(Negate(is.null), response_plots)

  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = isTRUE(common_legend),
    legend_position = if (isTRUE(common_legend)) legend_position_value else NULL
  )
}

compute_barplot_shared_limits <- function(context,
                                          data,
                                          factor1,
                                          factor2,
                                          posthoc_all = NULL) {
  combined <- NULL

  for (resp in context$responses) {
    posthoc_entry <- get_posthoc_entry_for_response(posthoc_all, resp)
    stats_entries <- generate_anova_stats_entries(
      context = context,
      data = data,
      resp = resp,
      factor1 = factor1,
      factor2 = factor2,
      posthoc_entry = posthoc_entry
    )

    for (entry in stats_entries) {
      rng <- compute_barplot_panel_range(
        entry$stats_df,
        factor1,
        factor2,
        posthoc_entry = entry$posthoc,
        nested_posthoc = entry$posthoc
      )
      combined <- update_numeric_range(combined, rng)
    }
  }

  if (is.null(combined)) return(NULL)
  
  limits <- expand_axis_limits(combined, lower_mult = 0.05, upper_mult = 0.12)
  ensure_barplot_zero_baseline(limits)
}

compute_barplot_panel_range <- function(stats_df,
                                        factor1,
                                       factor2,
                                       posthoc_entry = NULL,
                                       nested_posthoc = NULL) {
  if (is.null(stats_df) || nrow(stats_df) == 0) return(NULL)
  values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
  values <- values[is.finite(values)]
  if (length(values) == 0) return(NULL)
  range(values)
}

expand_axis_limits <- function(range_vals, lower_mult = 0.05, upper_mult = 0.12) {
  if (is.null(range_vals) || length(range_vals) != 2 || any(!is.finite(range_vals))) return(range_vals)
  span <- diff(range_vals)
  if (!is.finite(span) || span == 0) span <- max(1, abs(range_vals[2]))
  c(range_vals[1] - span * lower_mult, range_vals[2] + span * upper_mult)
}

ensure_barplot_zero_baseline <- function(range_vals) {
  if (is.null(range_vals) || length(range_vals) != 2 || any(!is.finite(range_vals))) {
    return(range_vals)
  }

  if (!is.na(range_vals[1])) range_vals[1] <- 0
  range_vals
}

get_posthoc_entry_for_response <- function(posthoc_all, resp) {
  if (is.null(posthoc_all) || is.null(posthoc_all[[resp]])) return(NULL)
  posthoc_all[[resp]]
}

generate_anova_stats_entries <- function(context,
                                         data,
                                         resp,
                                         factor1,
                                         factor2,
                                         posthoc_entry) {
  entries <- list()
  has_strata <- context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)

  if (has_strata) {
    for (stratum in context$strata_levels) {
      subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
      subset_data <- data[subset_rows, , drop = FALSE]
      if (nrow(subset_data) == 0) next

      stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) next

      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)

      stratum_posthoc <- NULL
      if (!is.null(posthoc_entry) && !is.null(posthoc_entry[[stratum]])) {
        stratum_posthoc <- posthoc_entry[[stratum]]
      }

      entries[[length(entries) + 1]] <- list(
        label = stratum,
        stats_df = stats_df,
        posthoc = stratum_posthoc
      )
    }
  } else {
    stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
    if (nrow(stats_df) == 0) return(entries)

    stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)

    entries[[1]] <- list(
      label = resp,
      stats_df = stats_df,
      posthoc = posthoc_entry
    )
  }

  entries
}

build_bar_plot_panel <- function(stats_df,
                                 title_text,
                                 factor1,
                                 factor2,
                                 line_colors,
                                 base_fill,
                                 base_size = 14,
                                 posthoc_entry = NULL,
                                 nested_posthoc = NULL,
                                 y_limits = NULL) {
  if (is.null(y_limits)) {
    panel_range <- compute_barplot_panel_range(
      stats_df,
      factor1,
      factor2,
      posthoc_entry = posthoc_entry,
      nested_posthoc = nested_posthoc
    )
    
    if (!is.null(panel_range)) {
      y_limits <- expand_axis_limits(panel_range, lower_mult = 0, upper_mult = 0.12)
      y_limits <- ensure_barplot_zero_baseline(y_limits)
    }
  }
  
  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    return(
      build_single_factor_barplot(
        stats_df = stats_df,
        title_text = title_text,
        factor1 = factor1,
        base_fill = base_fill,
        base_size = base_size,
        posthoc_entry = posthoc_entry,
        y_limits = y_limits
      )
    )
  }
  
  build_two_factor_barplot(
    stats_df = stats_df,
    title_text = title_text,
    factor1 = factor1,
    factor2 = factor2,
    line_colors = line_colors,
    base_fill = base_fill,
    base_size = base_size,
    nested_posthoc = nested_posthoc,
    y_limits = y_limits
  )
}

build_single_factor_barplot <- function(stats_df,
                                        title_text,
                                        factor1,
                                        base_fill,
                                        base_size,
                                        posthoc_entry,
                                        y_limits = NULL) {
  plot_obj <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean)) +
    geom_col(fill = base_fill, width = 0.6, alpha = 0.8) +
    geom_errorbar(
      aes(ymin = mean - se, ymax = mean + se),
      width = 0.15,
      color = "gray40",
      linewidth = 0.5
    ) +
    ta_plot_theme(base_size = base_size) +
    labs(x = factor1, y = "Mean Â± SE", title = title_text) +
    theme(
      plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
      axis.title.x = element_text(margin = margin(t = 6)),
      axis.title.y = element_text(margin = margin(r = 6)),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af")
    )
  
  plot_obj <- add_significance_after_build(
    p = plot_obj,
    stats_df = stats_df,
    factor1 = factor1,
    factor2 = NULL,
    posthoc_entry = posthoc_entry
  )
  
  plot_obj
}

build_two_factor_barplot <- function(stats_df,
                                     title_text,
                                     factor1,
                                     factor2,
                                     line_colors,
                                     base_fill,
                                     base_size,
                                     nested_posthoc = NULL,
                                     y_limits = NULL) {
  group_levels <- if (is.factor(stats_df[[factor2]])) {
    levels(stats_df[[factor2]])
  } else {
    unique(as.character(stats_df[[factor2]]))
  }
  group_levels <- group_levels[!is.na(group_levels)]
  palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
  dodge <- position_dodge(width = 0.7)
  
  plot_obj <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean, fill = !!sym(factor2))) +
    geom_col(position = dodge, width = 0.6, alpha = 0.85) +
    geom_errorbar(
      aes(ymin = mean - se, ymax = mean + se),
      position = dodge,
      width = 0.2,
      color = "gray40",
      linewidth = 0.5
    ) +
    ta_plot_theme(base_size = base_size) +
    labs(x = factor1, y = "Mean Â± SE", fill = factor2, title = title_text) +
    theme(
      plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
      axis.title.x = element_text(margin = margin(t = 6)),
      axis.title.y = element_text(margin = margin(r = 6)),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af")
    ) +
    scale_fill_manual(values = palette)
  
  plot_obj <- add_significance_after_build(
    p = plot_obj,
    stats_df = stats_df,
    factor1 = factor1,
    factor2 = factor2,
    posthoc_entry = nested_posthoc
  )
  
  plot_obj
}

#### Section: Significance Annotation System (ggplot_build-based) ####

extract_bar_positions <- function(p, factor1, factor2 = NULL) {
  built <- ggplot_build(p)
  layer <- built$data[[1]]
  original <- built$plot$data
  
  y_top <- if ("ymax" %in% names(layer)) {
    layer$ymax
  } else if ("y" %in% names(layer)) {
    layer$y
  } else {
    rep(NA_real_, nrow(layer))
  }
  
  df <- data.frame(
    x = layer$x,
    y = y_top
  )
  
  df[[factor1]] <- original[[factor1]]
  
  if (!is.null(factor2)) {
    df[[factor2]] <- original[[factor2]]
  }
  
  df
}

clean_p_values_barplot <- function(x) {
  x <- as.character(x)
  x <- gsub("[[:space:]]", "", x)
  x <- gsub("^<\\.?0*", "0.", x)
  suppressWarnings(as.numeric(x))
}

build_annotations_single_factor <- function(barpos,
                                            posthoc_entry,
                                            factor1,
                                            offset_mult = 0.12) {
  if (is.null(posthoc_entry) || nrow(posthoc_entry) == 0) return(NULL)
  
  levels_f1 <- unique(as.character(barpos[[factor1]]))
  if (length(levels_f1) < 2) return(NULL)
  reference <- levels_f1[1]
  
  posthoc_entry <- posthoc_entry |> dplyr::mutate(
    p.value = clean_p_values_barplot(.data$p.value)
  )
  posthoc_entry <- posthoc_entry |> dplyr::filter(!is.na(.data$p.value))
  if (nrow(posthoc_entry) == 0) return(NULL)
  
  values <- barpos$y[is.finite(barpos$y)]
  if (length(values) == 0) return(NULL)
  offset <- compute_annotation_offset(values, offset_mult)
  
  res <- list()
  
  for (lvl in levels_f1[-1]) {
    contrasts <- c(
      paste0(lvl, " - ", reference),
      paste0(reference, " - ", lvl)
    )
    
    row <- posthoc_entry[posthoc_entry$contrast %in% contrasts, , drop = FALSE]
    if (nrow(row) == 0) next
    
    p <- row$p.value[1]
    if (is.na(p) || p >= 0.05) next
    
    label <- dplyr::case_when(
      p < 0.001 ~ "***",
      p < 0.01 ~ "**",
      p < 0.05 ~ "*",
      TRUE ~ ""
    )
    if (label == "") next
    
    bar_row <- barpos[as.character(barpos[[factor1]]) == lvl, , drop = FALSE]
    if (nrow(bar_row) == 0) next
    
    res[[length(res) + 1]] <- data.frame(
      x = bar_row$x[1],
      y = bar_row$y[1] + offset,
      label = label
    )
  }
  
  if (length(res) == 0) return(NULL)
  
  do.call(rbind, res)
}

build_annotations_two_factor <- function(barpos,
                                         nested_posthoc,
                                         factor1,
                                         factor2,
                                         offset_mult = 0.12) {
  if (is.null(nested_posthoc)) return(NULL)
  
  nested_name <- paste0(factor2, "_within_", factor1)
  
  df <- NULL
  if (is.data.frame(nested_posthoc)) {
    if ("Factor" %in% names(nested_posthoc)) {
      df <- nested_posthoc |> dplyr::filter(.data$Factor == nested_name)
    } else {
      df <- nested_posthoc
    }
  } else if (is.list(nested_posthoc) && nested_name %in% names(nested_posthoc)) {
    df <- nested_posthoc[[nested_name]]
  } else {
    return(NULL)
  }
  
  if (is.null(df) || nrow(df) == 0) return(NULL)
  if (!all(c("contrast", "p.value", factor1) %in% names(df))) return(NULL)
  
  df <- df |> dplyr::mutate(
    p.value = clean_p_values_barplot(.data$p.value)
  )
  df <- df |> dplyr::filter(!is.na(.data$p.value))
  if (nrow(df) == 0) return(NULL)
  
  lev1 <- unique(as.character(barpos[[factor1]]))
  lev2 <- unique(as.character(barpos[[factor2]]))
  lev1 <- lev1[!is.na(lev1)]
  lev2 <- lev2[!is.na(lev2)]
  if (length(lev2) < 2) return(NULL)
  reference <- lev2[1]
  
  values <- barpos$y[is.finite(barpos$y)]
  if (length(values) == 0) return(NULL)
  offset <- compute_annotation_offset(values, offset_mult)
  
  res <- list()
  
  for (g1 in lev1) {
    for (lvl in lev2[lev2 != reference]) {
      contrasts <- c(
        paste0(lvl, " - ", reference),
        paste0(reference, " - ", lvl)
      )
      
      sub <- df[df[[factor1]] == g1 & df$contrast %in% contrasts, , drop = FALSE]
      if (nrow(sub) == 0) next
      
      p <- sub$p.value[1]
      if (is.na(p) || p >= 0.05) next
      
      label <- dplyr::case_when(
        p < 0.001 ~ "***",
        p < 0.01 ~ "**",
        p < 0.05 ~ "*",
        TRUE ~ ""
      )
      if (label == "") next
      
      bar_row <- barpos[
        as.character(barpos[[factor1]]) == g1 &
          as.character(barpos[[factor2]]) == lvl,
        ,
        drop = FALSE
      ]
      if (nrow(bar_row) == 0) next
      
      res[[length(res) + 1]] <- data.frame(
        x = bar_row$x[1],
        y = bar_row$y[1] + offset,
        label = label
      )
    }
  }
  
  if (length(res) == 0) return(NULL)

  do.call(rbind, res)
}

compute_annotation_offset <- function(values, offset_mult) {
  span <- diff(range(values))
  if (!is.finite(span) || span == 0) span <- max(values)
  if (is.finite(span) && span > 0) span * offset_mult else 0.1
}

add_significance_after_build <- function(p,
                                         stats_df,
                                         factor1,
                                         factor2 = NULL,
                                         posthoc_entry = NULL,
                                         text_size = 4) {
  if (is.null(posthoc_entry)) return(p)
  
  barpos <- extract_bar_positions(p, factor1, factor2)
  barpos <- barpos[is.finite(barpos$y), , drop = FALSE]
  if (nrow(barpos) == 0) return(p)
  
  if (is.null(factor2)) {
    ann <- build_annotations_single_factor(
      barpos = barpos,
      posthoc_entry = posthoc_entry,
      factor1 = factor1
    )
  } else {
    ann <- build_annotations_two_factor(
      barpos = barpos,
      nested_posthoc = posthoc_entry,
      factor1 = factor1,
      factor2 = factor2
    )
  }
  
  if (is.null(ann) || nrow(ann) == 0) return(p)
  
  max_y_text <- max(ann$y, na.rm = TRUE)

  p_build <- ggplot_build(p)
  current_limits <- p_build$layout$panel_params[[1]]$y.range

  padding <- compute_annotation_offset(barpos$y, offset_mult = 0.12)
  new_upper <- max(current_limits[2], max_y_text + padding)
  
  p +
    scale_y_continuous(
      limits = c(0, new_upper),
      expand = expansion(mult = c(0, 0))
    ) +
    geom_text(
      data = ann,
      aes(x = x, y = y, label = label),
      inherit.aes = FALSE,
      color = "gray30",
      size = text_size,
      fontface = "bold"
    )
  
}
#### Section: Summary Calculations ####

anova_summarise_stats <- function(df_subset, resp_name, factor1, factor2) {
  if (is.null(factor1) || !factor1 %in% names(df_subset)) {
    return(tibble::tibble())
  }

  if (is.null(factor2) || !factor2 %in% names(df_subset)) {
    df_subset |>
      dplyr::group_by(.data[[factor1]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  } else {
    df_subset |>
      dplyr::group_by(.data[[factor1]], .data[[factor2]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  }
}

apply_anova_factor_levels <- function(stats_df, factor1, factor2, order1, order2) {
  if (!is.null(factor1) && factor1 %in% names(stats_df)) {
    if (!is.null(order1)) {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]), levels = order1)
    } else {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]))
    }
  }

  if (!is.null(factor2) && factor2 %in% names(stats_df)) {
    levels2 <- if (!is.null(order2)) {
      order2
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = levels2)
  }

  stats_df
}
#### Section: Lineplot Construction ####

plot_anova_lineplot_meanse <- function(data,
                                       info,
                                       layout_values,
                                       line_colors = NULL,
                                       base_size = 14,
                                       show_lines = FALSE,
                                       show_jitter = FALSE,
                                       use_dodge = FALSE,
                                       share_y_axis = FALSE,
                                       common_legend = FALSE,
                                       legend_position = NULL) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2
  
  allowed_positions <- c("bottom", "top", "left", "right")
  legend_position_value <- if (!is.null(legend_position) && legend_position %in% allowed_positions) {
    legend_position
  } else {
    "bottom"
  }
  
  shared_y_limits <- if (isTRUE(share_y_axis)) {
    compute_lineplot_shared_limits(context, data, factor1, factor2)
  } else {
    NULL
  }
  
  response_plots <- list()
  strata_panel_count <- context$initial_strata_panels
  
  for (resp in context$responses) {
    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      stratum_stats <- list()
      y_values <- c()
      
      for (stratum in context$strata_levels) {
        subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
        subset_data <- data[subset_rows, , drop = FALSE]
        if (nrow(subset_data) == 0) {
          next
        }
        
        stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
        if (nrow(stats_df) == 0) {
          next
        }
        
        stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
        y_values <- c(y_values, stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
        stratum_stats[[stratum]] <- list(
          stats = stats_df,
          raw = prepare_lineplot_raw_data(subset_data, resp, factor1, factor2)
        )
      }
      
      if (length(stratum_stats) == 0) {
        next
      }
      
      y_limits <- range(y_values, na.rm = TRUE)
      if (!all(is.finite(y_limits))) {
        y_limits <- NULL
      }
      y_limits_to_use <- if (!is.null(shared_y_limits)) shared_y_limits else y_limits
      
      strata_panel_count <- max(strata_panel_count, length(stratum_stats))
      
      strata_plot_list <- lapply(names(stratum_stats), function(stratum_name) {
        entry <- stratum_stats[[stratum_name]]
        build_line_plot_panel(
          stats_df = entry$stats,
          title_text = stratum_name,
          y_limits = y_limits_to_use,
          factor1 = factor1,
          factor2 = factor2,
          line_colors = line_colors,
          base_size = base_size,
          raw_data = entry$raw,
          response_var = resp,
          show_lines = show_lines,
          show_jitter = show_jitter,
          use_dodge = use_dodge
        )
      })

      combined <- patchwork::wrap_plots(
        plotlist = strata_plot_list,
        nrow = context$strata_layout$nrow,
        ncol = context$strata_layout$ncol
      )
      
      if (isTRUE(common_legend)) {
        combined <- collect_guides_safe(combined)
      }
      
      title_plot <- ggplot() +
        ta_plot_theme_void() +
        ggtitle(resp) +
        theme(
          plot.title = element_text(
            size = base_size,
            face = "bold",
            hjust = 0.5
          ),
          plot.margin = margin(t = 0, r = 0, b = 6, l = 0)
        )
      
      response_plots[[resp]] <- title_plot / combined + plot_layout(heights = c(0.08, 1))
    } else {
      stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) {
        next
      }
      
      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
      y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
      y_limits <- range(y_values, na.rm = TRUE)
      if (!all(is.finite(y_limits))) {
        y_limits <- NULL
      }
      
      y_limits_to_use <- if (!is.null(shared_y_limits)) shared_y_limits else y_limits
      
      response_plots[[resp]] <- build_line_plot_panel(
        stats_df = stats_df,
        title_text = resp,
        y_limits = y_limits_to_use,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_size = base_size,
        raw_data = prepare_lineplot_raw_data(data, resp, factor1, factor2),
        response_var = resp,
        show_lines = show_lines,
        show_jitter = show_jitter,
        use_dodge = use_dodge
      )
    }
  }
  
  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = isTRUE(common_legend),
    legend_position = if (isTRUE(common_legend)) legend_position_value else NULL
  )
}

compute_lineplot_shared_limits <- function(context, data, factor1, factor2) {
  combined <- NULL

  for (resp in context$responses) {
    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      for (stratum in context$strata_levels) {
        subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
        subset_data <- data[subset_rows, , drop = FALSE]
        if (nrow(subset_data) == 0) next

        stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
        if (nrow(stats_df) == 0) next

        stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
        y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
        combined <- update_numeric_range(combined, y_values)
      }
    } else {
      stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) next
      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
      y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
      combined <- update_numeric_range(combined, y_values)
    }
  }

  if (is.null(combined) || any(!is.finite(combined))) return(NULL)
  combined
}


prepare_lineplot_raw_data <- function(df, response_var, factor1, factor2 = NULL) {
  if (is.null(df) || is.null(response_var) || is.null(factor1)) return(NULL)
  if (!response_var %in% names(df) || !factor1 %in% names(df)) return(NULL)
  
  cols <- c(factor1, factor2, response_var)
  cols <- cols[!vapply(cols, is.null, FUN.VALUE = logical(1), USE.NAMES = FALSE)]
  cols <- unique(cols)
  cols <- cols[cols %in% names(df)]
  if (!response_var %in% cols || !factor1 %in% cols) return(NULL)
  
  raw_subset <- df[, cols, drop = FALSE]
  raw_subset <- raw_subset[!is.na(raw_subset[[response_var]]), , drop = FALSE]
  if (nrow(raw_subset) == 0) return(NULL)
  raw_subset
}


build_line_plot_panel <- function(stats_df,
                                  title_text,
                                  y_limits,
                                  factor1,
                                  factor2,
                                  line_colors,
                                  base_size = 13,
                                  raw_data = NULL,
                                  response_var = NULL,
                                  show_lines = FALSE,
                                  show_jitter = FALSE,
                                  use_dodge = FALSE) {
  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    color_value <- if (!is.null(line_colors) && length(line_colors) > 0) {
      unname(line_colors)[1]
    } else {
      resolve_single_color()
    }
    p <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean))

    if (isTRUE(show_jitter) && !is.null(raw_data) &&
        !is.null(response_var) && response_var %in% names(raw_data) &&
        factor1 %in% names(raw_data)) {
      jitter_df <- raw_data[!is.na(raw_data[[response_var]]), , drop = FALSE]
      if (nrow(jitter_df) > 0) {
        p <- p + geom_jitter(
          data = jitter_df,
          aes(x = !!sym(factor1), y = !!sym(response_var)),
          width = 0.12,
          alpha = 0.35,
          size = 1.7,
          color = color_value,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
      }
    }

    if (isTRUE(show_lines)) {
      p <- p + geom_line(aes(group = 1), color = color_value, linewidth = 1)
    }

    p <- p +
      geom_point(size = 3, color = color_value) +
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        color = color_value
      ) +
      ta_plot_theme(base_size = base_size) +
      labs(x = factor1, y = "Mean Â± SE") +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.line = element_line(color = "#9ca3af"),
        axis.ticks = element_line(color = "#9ca3af")
      )
  } else {
    group_levels <- if (is.factor(stats_df[[factor2]])) {
      levels(stats_df[[factor2]])
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    group_levels <- group_levels[!is.na(group_levels)]
    palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = group_levels)
    dodge_width <- if (isTRUE(use_dodge)) 0.4 else NULL
    dodge <- if (!is.null(dodge_width)) position_dodge(width = dodge_width) else NULL
    jitter_dodge_width <- if (is.null(dodge_width)) 0 else dodge_width
    p <- ggplot(stats_df, aes(
      x = !!sym(factor1),
      y = mean,
      color = !!sym(factor2),
      group = !!sym(factor2)
    ))

    if (isTRUE(show_jitter) && !is.null(raw_data) && !is.null(response_var) &&
        all(c(factor1, factor2) %in% names(raw_data)) &&
        response_var %in% names(raw_data)) {
      jitter_df <- raw_data[!is.na(raw_data[[response_var]]), , drop = FALSE]
      if (nrow(jitter_df) > 0) {
        jitter_df[[factor2]] <- factor(as.character(jitter_df[[factor2]]), levels = group_levels)
        p <- p + geom_jitter(
          data = jitter_df,
          aes(x = !!sym(factor1), y = !!sym(response_var), color = !!sym(factor2)),
          position = position_jitterdodge(jitter.width = 0.15, dodge.width = jitter_dodge_width),
          size = 1.6,
          alpha = 0.4,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
      }
    }

    if (isTRUE(show_lines)) {
      if (is.null(dodge)) {
        p <- p + geom_line(linewidth = 1)
      } else {
        p <- p + geom_line(linewidth = 1, position = dodge)
      }
    }

    point_layer <- if (is.null(dodge)) {
      geom_point(size = 3)
    } else {
      geom_point(size = 3, position = dodge)
    }

    errorbar_layer <- if (is.null(dodge)) {
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15
      )
    } else {
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        position = dodge
      )
    }

    p <- p +
      point_layer +
      errorbar_layer +
      ta_plot_theme(base_size = base_size) +
      labs(
        x = factor1,
        y = "Mean Â± SE",
        color = factor2
      ) +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.line = element_line(color = "#9ca3af"),
        axis.ticks = element_line(color = "#9ca3af")
      ) +
      scale_color_manual(values = palette)
  }

  if (!is.null(y_limits) && all(is.finite(y_limits))) {
    p <- p + scale_y_continuous(limits = y_limits)
  }

  p + ggtitle(title_text) +
    theme(
      plot.title = element_text(
        size = base_size,
        face = "bold",
        hjust = 0.5
      )
    )
}





#### Section: Model Fitting & Preparation ####

prepare_stratified_anova <- function(
    df,
    responses,
    model,
    factor1_var = NULL,
    factor1_order = NULL,
    factor2_var = NULL,
    factor2_order = NULL,
    stratification = NULL,
    stratify_var = NULL,
    strata_order = NULL
) {
  req(df, responses, model)

  if (!is.null(stratification)) {
    if (!is.null(stratification$var)) {
      stratify_var <- stratification$var
    }
    if (!is.null(stratification$levels)) {
      strata_order <- stratification$levels
    }
  }

  

  df <- df |>
    set_factor_levels(factor1_var, factor1_order) |>
    set_factor_levels(factor2_var, factor2_order) |>
    set_factor_levels(stratify_var, strata_order, default_factor = TRUE)

  strata <- if (!is.null(stratify_var) && stratify_var %in% names(df)) {
    levels(df[[stratify_var]])
  } else {
    NULL
  }

  factor1_rhs <- anova_protect_vars(factor1_var)
  factor2_rhs <- anova_protect_vars(factor2_var)

  rhs <- switch(
    model,
    oneway_anova = factor1_rhs,
    twoway_anova = if (length(factor1_rhs) > 0 && length(factor2_rhs) > 0) {
      paste(factor1_rhs, factor2_rhs, sep = " *")
    } else {
      factor1_rhs
    },
    factor1_rhs
  )
  rhs <- if (is.null(rhs) || rhs == "") "1" else rhs

  build_formula <- function(resp) stats::as.formula(paste(anova_protect_vars(resp), "~", rhs))
  safe_fit <- purrr::safely(function(fml, data) stats::lm(fml, data = data))

  base_info <- list(
    type = model,
    responses = responses,
    factors = list(factor1 = factor1_var, factor2 = factor2_var),
    orders = list(order1 = factor1_order, order2 = factor2_order),
    data_used = df
  )

  if (is.null(strata)) {
    return(c(base_info, list(models = fit_models_for_data(df, responses, build_formula, safe_fit), strata = NULL)))
  }

  models <- lapply(strata, function(s) {
    subset_rows <- df[[stratify_var]] == s & !is.na(df[[stratify_var]])
    fit_models_for_data(df[subset_rows, , drop=FALSE], responses, build_formula, safe_fit)
  })
  names(models) <- strata

  c(base_info, list(models = models, strata = list(var = stratify_var, levels = strata)))
}


set_factor_levels <- function(data, var, levels = NULL, default_factor = FALSE) {
  if (is.null(var) || !var %in% names(data)) return(data)
  if (!is.null(levels)) {
    data[[var]] <- factor(as.character(data[[var]]), levels = levels)
  } else if (default_factor) {
    data[[var]] <- as.factor(as.character(data[[var]]))
  }
  data
}


fit_models_for_data <- function(data, responses, build_formula, safe_fit) {
  lapply(responses, function(resp) {
    fit_result <- safe_fit(build_formula(resp), data)
    list(
      model = fit_result$result,
      error = if (!is.null(fit_result$error)) conditionMessage(fit_result$error) else NULL
    )
  }) |>
    stats::setNames(responses)
}


compile_anova_results <- function(model_info) {
  if (is.null(model_info) || is.null(model_info$models)) return(NULL)

  factor_names <- unlist(model_info$factors)
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]

  if (is.null(model_info$strata)) {
    summary_list <- list()
    posthoc_list <- list()
    effects_list <- list()
    errors_list <- list()

    for (resp in names(model_info$models)) {
      entry <- model_info$models[[resp]]
      entry_errors <- character(0)
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_errors <- c(entry_errors, outputs$error)
          summary_list[[resp]] <- NULL
          posthoc_list[[resp]] <- NULL
          effects_list[[resp]] <- NULL
        } else {
          summary_list[[resp]] <- outputs$anova_table
          posthoc_list[[resp]] <- outputs$posthoc_table
          effects_list[[resp]] <- build_effects(outputs)
        }
      } else {
        summary_list[[resp]] <- NULL
        posthoc_list[[resp]] <- NULL
        effects_list[[resp]] <- NULL
      }
      if (!is.null(entry$error)) {
        entry_errors <- c(entry_errors, entry$error)
      }
      if (length(entry_errors) > 0) {
        errors_list[[resp]] <- paste(unique(entry_errors), collapse = "\n")
      }
    }

    return(list(
      summary = summary_list,
      posthoc = posthoc_list,
      effects = effects_list,
      errors = errors_list
    ))
  }

  summary_list <- list()
  posthoc_list <- list()
  effects_list <- list()
  errors_list <- list()

  for (stratum_name in names(model_info$models)) {
    stratum_models <- model_info$models[[stratum_name]]
    if (is.null(stratum_models)) next

    for (resp in names(stratum_models)) {
      entry <- stratum_models[[resp]]
      outputs <- NULL
      entry_error <- NULL
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_error <- outputs$error
          outputs <- NULL
        }
      }

      if (is.null(summary_list[[resp]])) summary_list[[resp]] <- list()
      if (is.null(posthoc_list[[resp]])) posthoc_list[[resp]] <- list()
      if (is.null(effects_list[[resp]])) effects_list[[resp]] <- list()
      if (is.null(errors_list[[resp]])) errors_list[[resp]] <- list()

      summary_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$anova_table else NULL
      posthoc_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$posthoc_table else NULL
      effects_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) build_effects(outputs) else NULL

      if (!is.null(entry$error)) {
        entry_error <- c(entry_error, entry$error)
      }

      if (!is.null(entry_error)) {
        errors_list[[resp]][[stratum_name]] <- paste(unique(entry_error), collapse = "\n")
      }
    }
  }


  list(
    summary = summary_list,
    posthoc = posthoc_list,
    effects = effects_list,
    errors = errors_list
  )
}


build_effects <- function(outputs) {
  if (is.null(outputs) || is.null(outputs$anova_table)) return(NULL)
  effects <- data.frame(
    Effect = outputs$anova_table$Effect,
    significant = outputs$anova_significant,
    stringsAsFactors = FALSE
  )
  if ("p.value" %in% names(outputs$anova_table)) {
    effects$p.value <- outputs$anova_table$p.value
  }
  effects
}#### Section: Plot Context Initialization ####

initialize_anova_plot_context <- function(data, info, layout_values) {
  factor1 <- info$factors$factor1
  factor2 <- info$factors$factor2
  order1 <- info$orders$order1
  order2 <- info$orders$order2

  if (!is.null(factor1) && !is.null(order1) && factor1 %in% names(data)) {
    data[[factor1]] <- factor(data[[factor1]], levels = order1)
  }
  if (!is.null(factor2) && !is.null(order2) && factor2 %in% names(data)) {
    data[[factor2]] <- factor(data[[factor2]], levels = order2)
  }

  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  strat_var <- if (has_strata) info$strata$var else NULL
  strata_levels <- if (has_strata) info$strata$levels else character(0)

  if (has_strata && (is.null(strata_levels) || length(strata_levels) == 0) &&
      !is.null(strat_var) && strat_var %in% names(data)) {
    strata_levels <- unique(as.character(stats::na.omit(data[[strat_var]])))
  }

  layout_input <- parse_anova_layout_inputs(layout_values)

  n_expected_strata <- if (has_strata) max(1L, length(strata_levels)) else 1L
  strata_defaults <- if (has_strata) {
    compute_default_grid(n_expected_strata)
  } else {
    list(rows = 1L, cols = 1L)
  }
  strata_layout <- basic_grid_layout(
    rows = layout_input$strata_rows,
    cols = layout_input$strata_cols,
    default_rows = strata_defaults$rows,
    default_cols = strata_defaults$cols
  )

  list(
    data = data,
    responses = info$responses,
    factor1 = factor1,
    factor2 = factor2,
    order1 = order1,
    order2 = order2,
    has_strata = has_strata,
    strat_var = strat_var,
    strata_levels = strata_levels,
    n_expected_strata = n_expected_strata,
    strata_defaults = strata_defaults,
    strata_layout = strata_layout,
    layout_input = layout_input,
    initial_strata_panels = if (has_strata) 0L else 1L
  )
}

parse_anova_layout_inputs <- function(layout_values) {
  list(
    strata_rows = suppressWarnings(as.numeric(layout_values$strata_rows)),
    strata_cols = suppressWarnings(as.numeric(layout_values$strata_cols)),
    resp_rows   = suppressWarnings(as.numeric(layout_values$resp_rows)),
    resp_cols   = suppressWarnings(as.numeric(layout_values$resp_cols))
  )
}

update_numeric_range <- function(current_range, values) {
  values <- values[is.finite(values)]
  if (length(values) == 0) return(current_range)
  new_range <- range(values)
  if (any(!is.finite(new_range))) return(current_range)
  if (is.null(current_range)) {
    new_range
  } else {
    c(min(current_range[1], new_range[1]), max(current_range[2], new_range[2]))
  }
}

apply_common_legend_layout <- function(plot_obj,
                                       legend_position = NULL,
                                       collect_guides = FALSE) {
  if (is.null(plot_obj)) return(plot_obj)

  updated <- plot_obj
  if (collect_guides) {
    updated <- collect_guides_safe(updated)
  }

  if (!is.null(legend_position)) {
    updated <- add_theme_to_plot(updated, theme(legend.position = legend_position))
  }

  updated
}

collect_guides_safe <- function(plot_obj) {
  if (is.null(plot_obj) || !requireNamespace("patchwork", quietly = TRUE)) {
    return(plot_obj)
  }

  is_patchwork <- inherits(plot_obj, "patchwork")
  if (!is_patchwork) {
    return(plot_obj)
  }

  exports <- tryCatch(getNamespaceExports("patchwork"), error = function(...) character())
  collected <- if ("collect_guides" %in% exports) {
    patchwork::collect_guides(plot_obj)
  } else {
    plot_obj + patchwork::plot_layout(guides = "collect")
  }

  collected + patchwork::plot_layout(guides = "collect")
}

add_theme_to_plot <- function(plot_obj, theme_obj) {
  if (inherits(plot_obj, "patchwork")) {
    plot_obj & theme_obj
  } else {
    plot_obj + theme_obj
  }
}


finalize_anova_plot_result <- function(response_plots,
                                       context,
                                       strata_panel_count,
                                       collect_guides = FALSE,
                                       legend_position = NULL) {
  if (length(response_plots) == 0) {
    return(NULL)
  }
  
  has_strata <- context$has_strata
  strata_layout <- context$strata_layout
  
  if (has_strata && strata_panel_count == 0L) {
    strata_panel_count <- context$n_expected_strata
  }

  response_defaults <- compute_default_grid(length(response_plots))
  response_layout <- basic_grid_layout(
    rows = context$layout_input$resp_rows,
    cols = context$layout_input$resp_cols,
    default_rows = response_defaults$rows,
    default_cols = response_defaults$cols
  )

  strata_validation <- if (has_strata) {
    validate_grid(max(1L, strata_panel_count), strata_layout$nrow, strata_layout$ncol)
  } else {
    list(valid = TRUE, message = NULL)
  }
  
  response_validation <- validate_grid(
    length(response_plots),
    response_layout$nrow,
    response_layout$ncol
  )
  
  warnings <- c()
  if (has_strata && !strata_validation$valid && !is.null(strata_validation$message)) {
    warnings <- c(warnings, strata_validation$message)
  }
  if (!response_validation$valid && !is.null(response_validation$message)) {
    warnings <- c(warnings, response_validation$message)
  }
  warning_text <- if (length(warnings) > 0) paste(warnings, collapse = "<br/>") else NULL
  
  panel_counts <- list(
    strata = if (has_strata) max(1L, strata_panel_count) else 1L,
    responses = length(response_plots)
  )
  
  final_plot <- NULL
  if (is.null(warning_text)) {
    if (length(response_plots) == 1) {
      final_plot <- response_plots[[1]]
      if (collect_guides && !is.null(legend_position)) {
        final_plot <- final_plot & theme(legend.position = legend_position)
      }
    } else {
      final_plot <- patchwork::wrap_plots(
        plotlist = response_plots,
        nrow = response_layout$nrow,
        ncol = response_layout$ncol
      )
    }
    if (collect_guides || !is.null(legend_position)) {
      final_plot <- apply_common_legend_layout(
        final_plot,
        legend_position = legend_position,
        collect_guides = collect_guides
      )
    }
  }
  
  list(
    plot = final_plot,
    layout = list(
      strata = list(
        rows = if (has_strata) strata_layout$nrow else 1L,
        cols = if (has_strata) strata_layout$ncol else 1L
      ),
      responses = list(
        rows = response_layout$nrow,
        cols = response_layout$ncol
      )
    ),
    warning = warning_text,
    panel_counts = panel_counts,
    defaults = list(
      strata = context$strata_defaults,
      responses = response_defaults
    )
  )
}
#### Section: ANOVA Output Processing ####

#### Section: ANOVA Output Processing ####

prepare_anova_outputs <- function(model_obj, factor_names) {
  old_contrasts <- options("contrasts")
  on.exit(options(old_contrasts), add = TRUE)
  options(contrasts = c("contr.sum", "contr.poly"))
  
  safe_anova <- purrr::safely(function(mod) {
    car::Anova(mod, type = 3)
  })
  
  anova_result <- safe_anova(model_obj)
  if (!is.null(anova_result$error)) {
    return(list(
      error = conditionMessage(anova_result$error),
      anova_object = NULL,
      anova_table = NULL,
      anova_significant = NULL,
      posthoc_details = list(),
      posthoc_table = NULL,
      posthoc_significant = NULL
    ))
  }
  
  anova_obj <- anova_result$result
  anova_df <- as.data.frame(anova_obj)
  anova_df$Effect <- rownames(anova_df)
  rownames(anova_df) <- NULL
  anova_df <- anova_df[, c("Effect", setdiff(names(anova_df), "Effect"))]
  
  # --- round numeric columns and keep raw p-values ---
  p_col <- grep("^Pr", names(anova_df), value = TRUE)
  p_col <- if (length(p_col) > 0) p_col[1] else NULL
  raw_p <- if (!is.null(p_col)) anova_df[[p_col]] else rep(NA_real_, nrow(anova_df))
  
  for (col in names(anova_df)) {
    if (is.numeric(anova_df[[col]])) {
      anova_df[[col]] <- round(anova_df[[col]], 2)
    }
  }
  
  anova_significant <- !is.na(raw_p) & raw_p < 0.05
  if (!is.null(p_col)) {
    names(anova_df)[names(anova_df) == p_col] <- "p.value"
  } else {
    anova_df$p.value <- NA_real_
  }
  
  # --- Post-hoc Tukey for each factor ---
  factor_names <- unique(factor_names[!is.na(factor_names) & nzchar(factor_names)])
  posthoc_details <- list()
  posthoc_combined <- NULL
  posthoc_significant <- numeric(0)
  
  # ONE-WAY POSTHOC (reference vs all)
  if (length(factor_names) == 1) {
    f1 <- factor_names[1]
    f1_spec <- anova_protect_vars(f1)
    
    if (f1 %in% names(model_obj$model)) {
      res <- tryCatch({
        
        emm <- emmeans::emmeans(model_obj, specs = as.formula(paste("~", f1_spec)))
        
        ref_lvl <- levels(model_obj$model[[f1]])[1]
        ref_idx <- which(levels(model_obj$model[[f1]]) == ref_lvl)
        
        # Only reference-vs-others contrasts (clean, robust)
        contrasts <- emmeans::contrast(emm, method = "trt.vs.ctrl", ref = ref_idx)
        res_df <- as.data.frame(summary(contrasts))
        
        res_df$Factor <- f1
        res_df
        
      }, error = function(e) list(error = e$message))
      
      if (is.data.frame(res)) {
        posthoc_details[[f1]] <- list(table = res, error = NULL)
        posthoc_combined <- res
      } else {
        posthoc_details[[f1]] <- list(table = NULL, error = res$error)
      }
    }
  } 
  ### TWO-WAY POSTHOC (nested reference-vs-all)
  else if (length(factor_names) == 2) {
    
    f1 <- factor_names[1]
    f2 <- factor_names[2]
    
    f1_spec <- anova_protect_vars(f1)
    f2_spec <- anova_protect_vars(f2)
    
    # Identify reference level of f2
    f2_levels <- levels(model_obj$model[[f2]])
    ref_lvl <- f2_levels[1]
    ref_idx <- which(f2_levels == ref_lvl)
    
    # Compute nested emmeans: f2 within each f1 level
    res_nested <- tryCatch({
      
      emm_nested <- emmeans::emmeans(
        model_obj,
        specs = as.formula(paste("~", f2_spec, "|", f1_spec))
      )
      
      # Reference-vs-all inside each f1 group
      contrasts_nested <- emmeans::contrast(
        emm_nested,
        method = "trt.vs.ctrl",
        ref = ref_idx
      )
      
      df <- as.data.frame(summary(contrasts_nested))
      df$Factor <- paste0(f2, "_within_", f1)

      # Ensure f1 column exists (grouping variable)
      if (!f1 %in% names(df)) {
        df[[f1]] <- df$comparison # fallback: emmeans puts group there
      }

      # Preserve the user-specified order of the grouping factor
      f1_levels <- levels(model_obj$model[[f1]])
      if (!is.null(f1_levels)) {
        df[[f1]] <- factor(df[[f1]], levels = f1_levels)
        df <- df[order(df[[f1]]), , drop = FALSE]
      }

      df[[f1]] <- as.character(df[[f1]])
      df
      
    }, error = function(e) list(error = e$message))
    
    if (is.data.frame(res_nested)) {
      key <- paste0(f2, "_within_", f1)
      posthoc_details[[key]] <- list(table = res_nested, error = NULL)
      posthoc_combined <- dplyr::bind_rows(posthoc_combined, res_nested)
    } else {
      key <- paste0(f2, "_within_", f1)
      posthoc_details[[key]] <- list(table = NULL, error = res_nested$error)
    }
  }
  
  
  if (!is.null(posthoc_combined)) {
    posthoc_combined <- posthoc_combined[, c("Factor", setdiff(names(posthoc_combined), "Factor"))]
    numeric_cols <- names(posthoc_combined)[sapply(posthoc_combined, is.numeric)]
    if (length(numeric_cols) > 0) {
      for (col in numeric_cols) {
        posthoc_combined[[col]] <- round(posthoc_combined[[col]], 2)
      }
    }
    
    if ("p.value" %in% names(posthoc_combined)) {
      raw_posthoc_p <- posthoc_combined$p.value
      posthoc_significant <- !is.na(raw_posthoc_p) & raw_posthoc_p < 0.05
    } else {
      posthoc_significant <- rep(FALSE, nrow(posthoc_combined))
    }
  }
  
  list(
    error = NULL,
    anova_object = anova_obj,
    anova_table = anova_df,
    anova_significant = anova_significant,
    posthoc_details = posthoc_details,
    posthoc_table = posthoc_combined,
    posthoc_significant = posthoc_significant
  )
}

#### Collate tidy summaries from ANOVA models ####

download_all_anova_results <- function(models_info, file) {
  if (is.null(models_info) || is.null(models_info$models)) {
    stop("No models found to export.")
  }

  combined_anova <- list()
  combined_contrasts <- list()
  factor_names <- unique(unlist(models_info$factors))
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]
  errors <- character(0)
  
  # --- Case 1: no stratification
  if (is.null(models_info$strata)) {
    for (resp in models_info$responses) {
      model_entry <- models_info$models[[resp]]
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        if (!is.null(model_entry$error)) {
          errors <- c(errors, paste0(resp, ": ", model_entry$error))
        }
        next
      }
      outputs <- prepare_anova_outputs(model_entry$model, factor_names)
      if (!is.null(outputs$error)) {
        errors <- c(errors, paste0(resp, ": ", outputs$error))
        next
      }
      anova_obj <- outputs$anova_object
      if (is.null(anova_obj)) {
        errors <- c(errors, paste0(resp, ": ANOVA results are unavailable."))
        next
      }
      tbl <- as.data.frame(anova_obj)
      tbl$Response <- resp
      tbl$Stratum <- "None"
      tbl$Term <- rownames(tbl)
      rownames(tbl) <- NULL
      names(tbl) <- sub(" ", "", names(tbl))
      tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
      combined_anova[[length(combined_anova) + 1]] <- tbl

      if (!is.null(outputs$posthoc_table) && nrow(outputs$posthoc_table) > 0) {
        ph_tbl <- outputs$posthoc_table
        ph_tbl$Response <- resp
        ph_tbl$Stratum <- "None"
        combined_contrasts[[length(combined_contrasts) + 1]] <- ph_tbl
      }
    }
  } else {
    # --- Case 2: stratified
    for (stratum in models_info$strata$levels) {
      for (resp in models_info$responses) {
        model_entry <- models_info$models[[stratum]][[resp]]
        if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
          if (!is.null(model_entry$error)) {
            errors <- c(errors, paste0(resp, " (", stratum, "): ", model_entry$error))
          }
          next
        }
        outputs <- prepare_anova_outputs(model_entry$model, factor_names)
        if (!is.null(outputs$error)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ", outputs$error))
          next
        }
        anova_obj <- outputs$anova_object
        if (is.null(anova_obj)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ANOVA results are unavailable."))
          next
        }
        tbl <- as.data.frame(anova_obj)
        tbl$Response <- resp
        tbl$Stratum <- stratum
        tbl$Term <- rownames(tbl)
        rownames(tbl) <- NULL
        names(tbl) <- sub(" ", "", names(tbl))
        tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
        combined_anova[[length(combined_anova) + 1]] <- tbl

        if (!is.null(outputs$posthoc_table) && nrow(outputs$posthoc_table) > 0) {
          ph_tbl <- outputs$posthoc_table
          ph_tbl$Response <- resp
          ph_tbl$Stratum <- stratum
          combined_contrasts[[length(combined_contrasts) + 1]] <- ph_tbl
        }
      }
    }
  }

  if (length(combined_anova) == 0) {
    msg <- "No ANOVA models available to export."
    if (length(errors) > 0) {
      msg <- paste0(
        msg,
        " The following issues were reported:\n",
        paste(sprintf("- %s", unique(errors)), collapse = "\n")
      )
    }
    stop(msg)
  }

  write_anova_docx(
    content = list(
      anova_results = combined_anova,
      contrast_results = combined_contrasts
    ),
    file = file
  )
}

write_anova_docx <- function(content, file, response_name = NULL, stratum_label = NULL) {
  if (is.null(content)) stop("No ANOVA results available to export.")

  add_blank_line <- function(doc, text = "", style = "Normal") {
    body_add_par(doc, text, style = style)
  }

  # Helper to format p-values consistently
  format_p <- function(df, p_col) {
    if (is.null(p_col) || !p_col %in% names(df)) return(df)
    p_vals <- as.numeric(df[[p_col]])
    df[[p_col]] <- p_vals
    df[[paste0(p_col, "_label")]] <- ifelse(p_vals < 0.001, "<0.001", sprintf("%.3f", p_vals))
    df$sig <- p_vals < 0.05
    df
  }

  # Shared styling for all tables (aligned with LM/LMM exports)
  format_table <- function(df, visible_cols, header_labels, merge_cols = NULL, p_label_col = NULL, sig_col = "sig") {
    ft <- flextable(df[, visible_cols, drop = FALSE])
    ft <- set_header_labels(ft, values = header_labels)

    if (!is.null(merge_cols)) {
      ft <- merge_v(ft, j = intersect(merge_cols, ft$col_keys))
    }

    ft <- fontsize(ft, part = "all", size = 10)
    ft <- bold(ft, part = "header", bold = TRUE)
    ft <- color(ft, part = "header", color = "black")
    ft <- align(ft, align = "center", part = "all")
    ft <- border_remove(ft)

    black <- fp_border(color = "black", width = 1)
    ft <- border(ft, part = "header", border.top = black, border.bottom = black)

    if ("Stratum" %in% names(df)) {
      group_cols <- c(if ("Response" %in% names(df)) "Response", "Stratum")
      strata_factor <- interaction(df[, group_cols, drop = FALSE], drop = TRUE)
      change_rows <- which(diff(as.numeric(strata_factor)) != 0)
      if (length(change_rows) > 0) {
        ft <- border(ft, i = change_rows, part = "body", border.bottom = fp_border(color = "black", width = 0.5))
      }
    } else if ("Response" %in% names(df)) {
      change_rows <- which(diff(as.numeric(factor(df$Response))) != 0)
      if (length(change_rows) > 0) {
        ft <- border(ft, i = change_rows, part = "body", border.bottom = fp_border(color = "black", width = 0.5))
      }
    }

    if (nrow(df) > 0) {
      ft <- border(ft, i = nrow(df), part = "body", border.bottom = black)
    }

    if (!is.null(sig_col) && sig_col %in% names(df) && !is.null(p_label_col) && p_label_col %in% ft$col_keys) {
      sig_rows <- which(df[[sig_col]] %in% TRUE)
      if (length(sig_rows) > 0) {
        ft <- bold(ft, i = sig_rows, j = p_label_col, bold = TRUE)
      }
    }

    ft <- set_table_properties(ft, layout = "autofit", width = 0.9)
    ft <- padding(ft, padding.top = 2, padding.bottom = 2, padding.left = 2, padding.right = 2)
    ft
  }

  # Build unified data frames for ANOVA and contrasts
  is_batch <- !is.null(content$anova_results) || !is.null(content$contrast_results)

  if (is_batch) {
    anova_entries <- content$anova_results
    contrast_entries <- content$contrast_results
  } else {
    anova_entries <- list()
    contrast_entries <- list()

    if (!is.null(content$anova_object)) {
      anova_tbl <- as.data.frame(content$anova_object)
      anova_tbl$Response <- response_name %||% "Response"
      anova_tbl$Stratum <- stratum_label %||% "None"
      anova_tbl$Term <- rownames(anova_tbl)
      rownames(anova_tbl) <- NULL
      names(anova_tbl) <- sub(" ", "", names(anova_tbl))
      anova_tbl$PrF <- anova_tbl[, grep("^Pr", names(anova_tbl))[1]]
      anova_entries <- list(anova_tbl)
    }

    if (!is.null(content$posthoc_table) && nrow(content$posthoc_table) > 0) {
      ph_tbl <- content$posthoc_table
      ph_tbl$Response <- response_name %||% "Response"
      ph_tbl$Stratum <- stratum_label %||% "None"
      contrast_entries <- list(ph_tbl)
    }
  }

  if (is.null(anova_entries) || length(anova_entries) == 0) stop("No ANOVA results available to export.")

  combined_anova <- bind_rows(anova_entries)

  required_cols <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF")
  if (!all(required_cols %in% names(combined_anova))) stop("Missing required columns in ANOVA results.")

  combined_anova <- combined_anova %>%
    mutate(
      SumSq = round(SumSq, 3),
      Fvalue = round(Fvalue, 3)
    ) %>%
    format_p("PrF") %>%
    arrange(Response, Stratum, Term)

  show_strata <- !(length(unique(combined_anova$Stratum)) == 1 && unique(combined_anova$Stratum) == "None")

  if (show_strata) {
    anova_visible <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    anova_merge <- c("Response", "Stratum")
  } else {
    combined_anova$Stratum <- NULL
    anova_visible <- c("Response", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    anova_merge <- c("Response")
  }

  anova_headers <- c(
    Response = "Response",
    Stratum = if (show_strata) "Stratum" else NULL,
    Term = "Term",
    SumSq = "Sum Sq",
    Df = "Df",
    Fvalue = "F value",
    PrF_label = "Pr(>F)"
  )

  doc <- read_docx()

  title_text <- if (length(unique(combined_anova$Response)) == 1) {
    sprintf("ANOVA Results â€” %s", unique(combined_anova$Response))
  } else {
    "ANOVA Results"
  }

  doc <- body_add_fpar(doc, fpar(ftext(title_text, prop = fp_text(bold = TRUE, font.size = 12))))

  # Optional subtitle when there is a single stratum label present
  if (!show_strata && !is.null(stratum_label) && nzchar(stratum_label) && !identical(stratum_label, "None")) {
    doc <- body_add_fpar(doc, fpar(ftext(stratum_label, prop = fp_text(bold = TRUE, font.size = 11))))
  }

  doc <- add_blank_line(doc)

  doc <- body_add_fpar(doc, fpar(ftext("ANOVA Table", prop = fp_text(bold = TRUE))))
  doc <- add_blank_line(doc)
  doc <- body_add_flextable(
    doc,
    format_table(
      combined_anova,
      visible_cols = anova_visible,
      header_labels = anova_headers,
      merge_cols = anova_merge,
      p_label_col = "PrF_label"
    )
  )

  if (!is.null(contrast_entries) && length(contrast_entries) > 0) {
    combined_contrasts <- bind_rows(contrast_entries)

    p_col <- intersect(c("p.value", "p.value."), names(combined_contrasts))
    p_col <- if (length(p_col) > 0) p_col[1] else NULL
    combined_contrasts <- format_p(combined_contrasts, p_col)

    has_stratum_contrast <- "Stratum" %in% names(combined_contrasts)
    show_strata_contrast <- has_stratum_contrast && !(length(unique(combined_contrasts$Stratum)) == 1 && unique(combined_contrasts$Stratum) == "None")

    combined_contrasts <- if (has_stratum_contrast) {
      combined_contrasts %>% arrange(Response, Stratum)
    } else {
      combined_contrasts %>% arrange(Response)
    }

    base_cols <- c("Response", if (show_strata_contrast) "Stratum")
    detail_cols <- setdiff(names(combined_contrasts), c(base_cols, "sig", if (!is.null(p_col)) c(p_col, paste0(p_col, "_label"))))
    p_display_col <- if (!is.null(p_col)) paste0(p_col, "_label") else NULL
    contrast_visible <- unique(c(base_cols, detail_cols, p_display_col))

    header_labels <- setNames(gsub("_", " ", contrast_visible), contrast_visible)
    if (!is.null(p_display_col)) header_labels[[p_display_col]] <- "p-value"

    doc <- add_blank_line(doc)
    doc <- body_add_fpar(doc, fpar(ftext("Post-hoc Contrasts", prop = fp_text(bold = TRUE))))
    doc <- add_blank_line(doc)
    doc <- body_add_flextable(
      doc,
      format_table(
        combined_contrasts,
        visible_cols = contrast_visible,
        header_labels = header_labels,
        merge_cols = base_cols,
        p_label_col = p_display_col
      )
    )
  }

  doc <- add_blank_line(doc)
  doc <- add_blank_line(doc, "Significance level: p < 0.05 (bold values).")
  doc <- add_blank_line(doc, sprintf("Generated by Table Analyzer on %s", Sys.Date()))
  print(doc, target = file)
}

#### Table Analyzer â€” Shared ANOVA Module  ####
#### Section: UI & Output Binding ####

build_anova_layout_controls <- function(ns, input, info) {
  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  n_responses <- if (!is.null(info$responses)) length(info$responses) else 0

  build_grid_section <- function(title, grid_id, row_help, col_help) {
    tagList(
      h5(title),
      plot_grid_ui(
        id = ns(grid_id),
        rows_help = row_help,
        cols_help = col_help
      )
    )
  }

  strata_inputs <- if (has_strata) {
    build_grid_section(
      title = "Across strata:",
      grid_id = "strata_grid",
      row_help = "Set how many rows of plots to use when displaying different strata.",
      col_help = "Set how many columns of plots to use when displaying different strata."
    )
  } else {
    NULL
  }

  response_inputs <- if (!is.null(n_responses) && n_responses > 1) {
    build_grid_section(
      title = "Across responses:",
      grid_id = "response_grid",
      row_help = "Set the number of plot rows when multiple responses are shown together.",
      col_help = "Set the number of plot columns when multiple responses are shown together."
    )
  } else {
    NULL
  }

  tagList(strata_inputs, response_inputs)
}


#### Formula utilities ####

render_anova_results <- function(ns, model_info, module_label = "ANOVA") {
  if (is.null(model_info)) return(NULL)
  
  responses <- model_info$responses
  strata_info <- model_info$strata
  
  # No stratification
  if (is.null(strata_info)) {
    tabs <- lapply(seq_along(responses), function(i) {
      tabPanel(
        title = responses[i],
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i)))
        )
      )
    })
    return(do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs)))
  }
  
  # Stratified
  strata_levels <- strata_info$levels
  tabs <- lapply(seq_along(responses), function(i) {
    response_name <- responses[i]
    stratum_tabs <- lapply(seq_along(strata_levels), function(j) {
      stratum_name <- strata_levels[j]
      tabPanel(
        title = stratum_name,
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i, "_", j)))
        )
      )
    })
    tabPanel(
      title = response_name,
      do.call(tabsetPanel, c(list(id = ns(paste0("strata_tabs_", i))), stratum_tabs))
    )
  })
  do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs))
}

bind_anova_outputs <- function(ns, output, models_reactive) {
  observeEvent(models_reactive(), {
    model_info <- models_reactive()
    if (is.null(model_info)) return()
    
    responses <- model_info$responses
    model_list <- model_info$models
    strata_info <- model_info$strata
    factors <- unlist(model_info$factors, use.names = FALSE)
    
    # --- Non-stratified case ---
    if (is.null(strata_info)) {
      for (i in seq_along(responses)) {
        local({
          idx <- i
          response_name <- responses[i]
          model_entry <- model_list[[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx),
            download_id = paste0("download_", idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors
          )
        })
      }
      return()
    }
    
    # --- Stratified case ---
    strata_levels <- strata_info$levels
    for (i in seq_along(responses)) {
      for (j in seq_along(strata_levels)) {
        local({
          idx <- i
          stratum_idx <- j
          response_name <- responses[i]
          stratum_label <- strata_levels[j]
          model_entry <- model_list[[stratum_label]][[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx, "_", stratum_idx),
            download_id = paste0("download_", idx, "_", stratum_idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors,
            stratum_label = stratum_label
          )
        })
      }
    }
  })
}

#### Results export ####

bind_single_model_outputs <- function(output, summary_id, download_id,
                                      model_entry, response_name, factors,
                                      stratum_label = NULL) {
  output[[summary_id]] <- renderPrint({
    print_anova_summary_and_posthoc(model_entry, factors)
  })

  output[[download_id]] <- downloadHandler(
    filename = function() {
      base <- paste0("anova_results_", sanitize_name(response_name))
      if (!is.null(stratum_label)) {
        base <- paste0(base, "_stratum_", sanitize_name(stratum_label))
      }
      paste0(base, "_", Sys.Date(), ".docx")
    },
    content = function(file) {
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        stop("Model not available for download due to fitting error.")
      }
      results <- prepare_anova_outputs(model_entry$model, factors)
      if (!is.null(results$error)) {
        stop(paste0("ANOVA results unavailable: ", results$error))
      }
      if (is.null(results$anova_table)) {
        stop("ANOVA results are unavailable for export.")
      }
      write_anova_docx(
        file = file,
        content = results,
        response_name = response_name,
        stratum_label = stratum_label
      )
    }
  )
}

sanitize_name <- function(name) {
  safe <- gsub("[^A-Za-z0-9]+", "_", name)
  safe <- gsub("_+", "_", safe)
  safe <- gsub("^_|_$", "", safe)
  if (!nzchar(safe)) safe <- "unnamed"
  safe
}

print_anova_summary_and_posthoc <- function(model_entry, factors) {
  if (is.null(model_entry) || (is.list(model_entry) && is.null(model_entry$model))) {
    cat("Model is not available.\n")
    return(invisible(NULL))
  }

  if (!is.null(model_entry$error)) {
    cat(format_safe_error_message("Model fitting failed", model_entry$error), "\n", sep = "")
    return(invisible(NULL))
  }

  model_obj <- model_entry$model
  results <- prepare_anova_outputs(model_obj, factors)
  if (!is.null(results$error)) {
    cat(format_safe_error_message("ANOVA computation failed", results$error), "\n", sep = "")
    return(invisible(NULL))
  }
  if (is.null(results$anova_object)) {
    cat("ANOVA results are unavailable.\n")
    return(invisible(NULL))
  }
  print(results$anova_object)

  if (length(results$posthoc_details) == 0) {
    cat("\nNo post-hoc Tukey comparisons were generated.\n")
  } else {
    for (factor_nm in names(results$posthoc_details)) {
      details <- results$posthoc_details[[factor_nm]]
      if (!is.null(details$error)) {
        cat(
          "\n",
          format_safe_error_message(
            paste("Post-hoc Tukey comparisons for", factor_nm, "failed"),
            details$error
          ),
          "\n",
          sep = ""
        )
      } else if (!is.null(details$table)) {
        cat("\nPost-hoc Tukey comparisons for", factor_nm, ":\n")
        print(details$table)
      }
    }
  }
  invisible(results)
}

#### Section: Model Fitting & Preparation ####

#### Section: Utility Helpers ####

anova_protect_vars <- function(vars) {
  if (is.null(vars) || length(vars) == 0) return(vars)

  vals <- vapply(vars, function(v) {
    if (is.null(v) || is.na(v) || !nzchar(v)) return("")
    if (grepl("^`.*`$", v)) v else paste0("`", v, "`")
  }, character(1))

  vals[nzchar(vals)]
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Two-way ANOVA Module
# ===============================================================

two_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order_1")),
      uiOutput(ns("level_order_2")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show results", width = "100%"),
          "Fit the two-way ANOVA with the selected factors and responses."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
          "Save all ANOVA tables, post-hoc results, and diagnostics to disk."
        ))
      )
    ),
    results = tagList(
      uiOutput(ns("summary_ui"))
    )
  )
}

two_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    responses <- multi_response_server("response", filtered_data)

    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      cat_cols <- names(data)[sapply(data, function(x) is.character(x) || is.factor(x))]

      tagList(
        multi_response_ui(ns("response")),
        with_help_tooltip(
          selectInput(
            ns("factor1"),
            "Categorical predictor 1 (x-axis)",
            choices = cat_cols,
            selected = if (length(cat_cols) > 0) cat_cols[1] else NULL
          ),
          "Select the factor for the x-axis groups in the interaction plot."
        ),
        with_help_tooltip(
          selectInput(
            ns("factor2"),
            "Categorical predictor 2 (lines)",
            choices = cat_cols,
            selected = if (length(cat_cols) > 1) cat_cols[2] else NULL
          ),
          "Select the factor for the lines in the interaction plot."
        )
      )
    })
    
    strat_info <- stratification_server("strat", filtered_data)
    
    # -----------------------------------------------------------
    # Level order selections
    # -----------------------------------------------------------
    output$level_order_1 <- renderUI({
      req(filtered_data(), input$factor1)
      levels1 <- resolve_order_levels(filtered_data()[[input$factor1]])
      with_help_tooltip(
        selectInput(
          ns("order1"),
          paste("Order of levels (first = reference)", input$factor1, "(x-axis)"),
          choices = levels1,
          selected = levels1,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s for the x-axis; the first level is the reference.", input$factor1)
      )
    })
    
    output$level_order_2 <- renderUI({
      req(filtered_data(), input$factor2)
      levels2 <- resolve_order_levels(filtered_data()[[input$factor2]])
      with_help_tooltip(
        selectInput(
          ns("order2"),
          paste("Order of levels (first = reference)", input$factor2, "(lines)"),
          choices = levels2,
          selected = levels2,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s for the line colours; the first level is the reference.", input$factor2)
      )
    })
    
    # -----------------------------------------------------------
    # Model fitting (via shared helper)
    # -----------------------------------------------------------
    models <- eventReactive(input$run, {
      df <- filtered_data()
      req(df, input$factor1, input$order1, input$factor2, input$order2)
      resp_vals <- responses()
      validate(
        need(length(resp_vals) > 0, "Please select at least one response variable."),
        need(
          !identical(input$factor1, input$factor2),
          "Categorical predictor 1 and 2 must be different variables."
        ),
        need(all(input$order1 %in% unique(df[[input$factor1]])), "Invalid level order for first factor."),
        need(all(input$order2 %in% unique(df[[input$factor2]])), "Invalid level order for second factor.")
      )
      validate_numeric_columns(df, resp_vals, "response variables")
      prepare_stratified_anova(
        df = df,
        responses = resp_vals,
        model = "twoway_anova",
        factor1_var = input$factor1,
        factor1_order = input$order1,
        factor2_var = input$factor2,
        factor2_order = input$order2,
        stratification = strat_info()
      )
    })

    # -----------------------------------------------------------
    # Download all results as one combined DOCX
    # -----------------------------------------------------------
    output$download_all <- downloadHandler(
      filename = function() {
        model_info <- models()
        req(model_info)
        
        n_resp <- length(model_info$responses)
        n_strata <- if (is.null(model_info$strata)) 0 else length(model_info$strata$levels)
        strata_label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        timestamp <- format(Sys.time(), "%Y%m%d-%H%M")
        sprintf("anova_results_%sresp_%s_%s.docx", n_resp, strata_label, timestamp)
      },
      content = function(file) {
        model_info <- models()
        req(model_info)
        download_all_anova_results(model_info, file)
      }
    )
    
    # -----------------------------------------------------------
    # Render results
    # -----------------------------------------------------------
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "Two-way ANOVA")
    })
    
    # -----------------------------------------------------------
    # Render model summaries + downloads (shared helper)
    # -----------------------------------------------------------
    bind_anova_outputs(ns, output, models)

    anova_results <- reactive({
      mod <- models()
      req(mod)

      res <- compile_anova_results(mod)
      data_used <- mod$data_used

      list(
        analysis_type = "ANOVA",
        type = "twoway_anova",
        data_used = data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        errors = res$errors,
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })

    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” Two-way ANOVA (Apply-button version)
# ===============================================================

visualize_twoway_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize two-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c(
            "Lineplots (mean Â± SE)" = "lineplot_mean_se",
            "Barplots (mean Â± SE)"  = "barplot_mean_se"
          ),
          selected = "lineplot_mean_se"
        ),
        "Pick the chart style you prefer for viewing group means and uncertainty."
      ),
      conditionalPanel(
        condition = sprintf("input['%s'] === 'lineplot_mean_se'", ns("plot_type")),
        fluidRow(
          column(
            6,
            with_help_tooltip(
              checkboxInput(
                ns("lineplot_show_lines"),
                "Connect means with lines",
                value = TRUE
              ),
              "Draw connecting lines between group means."
            )
          ),
          column(
            6,
            with_help_tooltip(
              checkboxInput(
                ns("lineplot_use_dodge"),
                "Dodge grouped means",
                value = FALSE
              ),
              "Offset the level means of the second factor along the x-axis to prevent overlap."
            )
          )
        )
      ),
      uiOutput(ns("axis_and_jitter")),
      subplot_size_ui(ns),
      uiOutput(ns("layout_controls")),
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = TRUE)),
        column(
          6,
          tagList(
            base_size_ui(
              ns,
              default = 13,
              help_text = "Adjust the base font size used for the ANOVA plots."
            ),
            br(),
            uiOutput(ns("common_legend_controls"))
          )
        )
      ),
      
      br(),
      
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"))
      )
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}



visualize_twoway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL,
      plot_width = NULL,
      plot_height = NULL
    )
    
    df <- reactive(filtered_data())
    
    color_var <- reactive({
      info <- model_info()
      if (is.null(info) || is.null(info$factors)) return(NULL)
      info$factors$factor2
    })
    
    factor2_levels <- reactive({
      info <- model_info()
      if (is.null(info) || is.null(info$orders)) return(NULL)
      info$orders$order2
    })
    
    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = color_var,
      multi_group = TRUE,
      level_order_reactive = factor2_levels
    )
    
    base_size <- base_size_server(input = input, default = 13)
    
    strata_grid <- plot_grid_server("strata_grid")
    response_grid <- plot_grid_server("response_grid")
    
    # UI render
    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })
    
    output$axis_and_jitter <- renderUI({
      jitter_widget <- NULL
      if (input$plot_type == "lineplot_mean_se") {
        jitter_widget <- with_help_tooltip(
          checkboxInput(
            ns("lineplot_show_jitter"),
            "Overlay jittered data",
            value = isTRUE(input$lineplot_show_jitter)
          ),
          "Overlay raw observations with jitter."
        )
      }
      
      fluidRow(
        column(
          6,
          with_help_tooltip(
            checkboxInput(
              ns("share_y_axis"),
              "Use common y-axis across plots",
              value = isTRUE(input$share_y_axis)
            ),
            "Use the same y-scale for all panels."
          )
        ),
        column(6, jitter_widget)
      )
    })
    
    # Common legend UI
    legend_state <- reactiveValues(
      enabled = FALSE,
      position = "bottom"
    )
    
    common_legend_available <- reactive({
      info <- model_info()
      if (is.null(info) || !identical(info$type, "twoway_anova"))
        return(FALSE)
      has_mult_resp <- length(info$responses %||% character()) > 1
      has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
      has_mult_resp || has_strata
    })
    
    observeEvent(input$use_common_legend, {
      legend_state$enabled <- isTRUE(input$use_common_legend)
    }, ignoreNULL = TRUE)
    
    observeEvent(input$common_legend_position, {
      legend_state$position <- input$common_legend_position
    }, ignoreNULL = TRUE)
    
    output$common_legend_controls <- renderUI({
      if (!common_legend_available()) return(NULL)
      
      legend_enabled <- isTRUE(legend_state$enabled)
      
      legend_checkbox <- with_help_tooltip(
        checkboxInput(
          ns("use_common_legend"),
          "Use common legend",
          value = legend_enabled
        ),
        "Merge legends across subplots."
      )
      
      legend_position <- NULL
      if (legend_enabled) {
        legend_position <- with_help_tooltip(
          selectInput(
            ns("common_legend_position"),
            "Legend position",
            c("Bottom" = "bottom", "Right" = "right", "Top" = "top", "Left" = "left"),
            selected = legend_state$position
          ),
          "Choose where to place the combined legend."
        )
      }
      
      tagList(legend_checkbox, legend_position)
    })
    
    # ------------------------------------------------------------------
    # APPLY button (core logic)
    # ------------------------------------------------------------------
    observeEvent(input$apply_plot, {
      data <- df()
      info <- model_info()
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data or ANOVA results available."
        stored$plot <- NULL
        return()
      }
      
      # Build layout
      layout_inputs <- list(
        strata_rows = strata_grid$rows(),
        strata_cols = strata_grid$cols(),
        resp_rows   = response_grid$rows(),
        resp_cols   = response_grid$cols()
      )
      
      # Legend handling
      legend_supported <- input$plot_type %in% c("lineplot_mean_se", "barplot_mean_se")
      use_common_legend <- legend_supported && common_legend_available() && legend_state$enabled
      legend_position <- if (use_common_legend) legend_state$position else NULL
      
      # Compute all plots
      results <- list(
        lineplot_mean_se = plot_anova_lineplot_meanse(
          data, info, layout_inputs,
          line_colors  = custom_colors(),
          base_size    = base_size(),
          show_lines   = input$lineplot_show_lines,
          show_jitter  = input$lineplot_show_jitter,
          use_dodge    = input$lineplot_use_dodge,
          share_y_axis = input$share_y_axis,
          common_legend = use_common_legend,
          legend_position = legend_position
        ),
        
        barplot_mean_se = plot_anova_barplot_meanse(
          data, info, layout_inputs,
          line_colors       = custom_colors(),
          base_size         = base_size(),
          posthoc_all       = info$posthoc,
          share_y_axis      = input$share_y_axis,
          common_legend     = use_common_legend,
          legend_position   = legend_position
        )
      )
      
      chosen <- input$plot_type
      chosen_result <- results[[chosen]]

      stored$warning <- chosen_result$warning
      stored$plot    <- chosen_result$plot
      stored$layout  <- chosen_result$layout

      apply_grid_defaults_if_empty(
        input,
        session,
        "strata_grid",
        chosen_result$defaults$strata,
        n_items = chosen_result$panel_counts$strata
      )

      apply_grid_defaults_if_empty(
        input,
        session,
        "response_grid",
        chosen_result$defaults$responses,
        n_items = chosen_result$panel_counts$responses
      )
    })
    
    # ------------------------------------------------------------------
    # OUTPUTS
    # ------------------------------------------------------------------
    
    output$plot_warning <- renderUI({
      if (!is.null(stored$warning))
        div(class = "alert alert-warning", stored$warning)
    })
    
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      total_cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
      stored$plot_width * total_cols
    },
    height = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      total_rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
      stored$plot_height * total_rows
    },
    res = 96)
    
    output$download_plot <- downloadHandler(
      filename = function() paste0("anova_twoway_plot_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        req(!is.null(lay))
        
        total_cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
        total_rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
        
        w_in <- (stored$plot_width  * total_cols) / 96
        h_in <- (stored$plot_height * total_rows) / 96
        
        ggsave(file, p, dpi = 300,
               width = w_in, height = h_in,
               units = "in", limitsize = FALSE)
      }
    )
  })
}

# ===============================================================
# ðŸ§¾ Table Analyzer â€” Descriptive Statistics Modules
# ===============================================================

descriptive_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show summary", width = "100%"),
          "Calculate the descriptive statistics for the selected variables."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_summary"), "Download summary", style = "width: 100%;"),
          "Save the displayed summary as a text file for later reference."
        ))
      ),
      hr()
    ),
    results = tagList(verbatimTextOutput(ns("summary_text")))
  )
}

descriptive_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- filtered_data

    # ------------------------------------------------------------
    # Dynamic inputs
    # ------------------------------------------------------------
    output$inputs <- renderUI({
      req(df())
      data <- df()
      cat_cols <- names(data)[vapply(data, function(x) is.character(x) || is.factor(x) || is.logical(x), logical(1))]
      num_cols <- names(data)[vapply(data, is.numeric, logical(1))]
      
      tagList(
        with_help_tooltip(
          selectInput(ns("cat_vars"), label = "Categorical variables", choices = cat_cols, selected = cat_cols, multiple = TRUE),
          "Choose the group variables whose counts and proportions you want to inspect."
        ),
        with_help_tooltip(
          selectInput(ns("num_vars"), label = "Numeric variables", choices = num_cols, selected = num_cols, multiple = TRUE),
          "Choose the numeric measurements you want to summarise (mean, SD, etc.)."
        )
      )
    })
    
    strat_info <- stratification_server("strat", df)
    
    # ------------------------------------------------------------
    # Summary computation
    # ------------------------------------------------------------
    summary_data <- eventReactive(input$run, {
      req(df())

      local_data <- df()
      selected_vars <- unique(c(input$cat_vars, input$num_vars))
      validate(need(length(selected_vars) > 0, "Please select at least one variable."))

      strat_details <- strat_info()
      group_var <- strat_details$var
      data_columns <- selected_vars

      if (!is.null(group_var)) {
        sel <- strat_details$levels
        if (!is.null(sel) && length(sel) > 0) {
          local_data <- dplyr::filter(local_data, .data[[group_var]] %in% sel)
          local_data[[group_var]] <- factor(as.character(local_data[[group_var]]), levels = sel)
        } else {
          local_data[[group_var]] <- factor(as.character(local_data[[group_var]]))
        }
        local_data <- droplevels(local_data)
        data_columns <- unique(c(data_columns, group_var))
      }

      data_columns <- data_columns[!is.na(data_columns) & nzchar(data_columns)]
      data_columns <- intersect(data_columns, names(local_data))
      local_data <- local_data[, data_columns, drop = FALSE]

      selected_vars <- selected_vars[!is.na(selected_vars) & nzchar(selected_vars)]
      selected_vars <- intersect(selected_vars, names(local_data))

      list(
        summary = compute_descriptive_summary(local_data, group_var),
        selected_vars = selected_vars,
        group_var = group_var,
        processed_data = local_data,
        strata_levels = if (!is.null(group_var) && group_var %in% names(local_data)) levels(local_data[[group_var]]) else NULL
      )
    })
    
    
    
    
    # ------------------------------------------------------------
    # Print summary
    # ------------------------------------------------------------
    output$summary_text <- renderPrint({
      req(summary_data())
      print_summary_sections(summary_data()$summary)
    })
    
    # ------------------------------------------------------------
    # Download
    # ------------------------------------------------------------
    output$download_summary <- downloadHandler(
      filename = function() paste0("Descriptive_Statistics_", Sys.Date(), ".txt"),
      content = function(file) {
        results <- summary_data()
        req(results)
        sink(file)
        on.exit(sink(), add = TRUE)
        print_summary_sections(results$summary)
      }
    )
    
    # ------------------------------------------------------------
    # Return full model info
    # ------------------------------------------------------------
    extract_detail <- function(field) reactive({
      details <- summary_data()
      req(details)
      details[[field]]
    })

    df_final <- extract_detail("processed_data")
    summary_table <- extract_detail("summary")
    selected_vars_reactive <- extract_detail("selected_vars")
    group_var_reactive <- extract_detail("group_var")
    strata_levels_reactive <- extract_detail("strata_levels")

    reactive({
      details <- summary_data()
      req(details)

      data_used <- df_final()

        list(
          analysis_type = "DESCRIPTIVE",
          type = "descriptive",
          data_used = data_used,
          model = NULL,
          summary = summary_table(),
          posthoc = NULL,
          effects = NULL,
          stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
          selected_vars = details$selected_vars,
          group_var = details$group_var,
          strata_levels = details$strata_levels,
          processed_data = df_final,
          selected_vars_reactive = selected_vars_reactive,
          group_var_reactive = group_var_reactive,
          strata_levels_reactive = strata_levels_reactive
      )
    })

  })
}

compute_descriptive_summary <- function(data, group_var = NULL) {
  numeric_vars <- names(data)[sapply(data, is.numeric)]
  group_data <- if (!is.null(group_var)) dplyr::group_by(data, .data[[group_var]], .drop = TRUE) else data

  summarise_numeric <- function(.data, vars, suffix, fn) {
    if (length(vars) == 0) {
      return(NULL)
    }
    .data %>%
      dplyr::summarise(
        dplyr::across(
          dplyr::all_of(vars),
          fn,
          .names = paste0(suffix, "_{.col}")
        ),
        .groups = "drop"
      )
  }

  # Define a custom skim function with full factor labels
  top_counts_full <- function(x) skimr::top_counts(x, max_char = 200, max_levels = 10)
  skim_full <- skimr::skim_with(
    factor = skimr::sfl(
      ordered    = is.ordered,
      n_unique   = skimr::n_unique,
      top_counts = top_counts_full
    ),
    append = FALSE
  )
  
  list(
    skim = if (!is.null(group_var)) skim_full(group_data) else skim_full(data),
    cv = summarise_numeric(
      group_data,
      numeric_vars,
      "cv",
      ~ 100 * stats::sd(.x, na.rm = TRUE) / mean(.x, na.rm = TRUE)
    ),
    outliers = summarise_numeric(
      group_data,
      numeric_vars,
      "outliers",
      ~ {
        q <- stats::quantile(.x, probs = c(0.25, 0.75), na.rm = TRUE)
        iqr <- q[2] - q[1]
        sum(.x < q[1] - 1.5 * iqr | .x > q[2] + 1.5 * iqr, na.rm = TRUE)
      }
    ),
    missing = summarise_numeric(
      group_data,
      numeric_vars,
      "missing",
      ~ 100 * mean(is.na(.x))
    ),
    distribution = summarise_numeric(
      group_data,
      numeric_vars,
      "distribution",
      ~ most_likely_distribution(.x)
    )
  )
}

most_likely_distribution <- function(values) {
  values <- values[is.finite(values)]
  if (length(values) < 5 || length(unique(values)) < 2) {
    return(NA_character_)
  }
  
  candidates <- c(
    norm   = TRUE,
    lnorm  = all(values > 0),
    gamma  = all(values > 0),
    weibull = all(values > 0),
    exp    = all(values > 0)
  )
  
  candidate_names <- names(candidates)[candidates]
  if (length(candidate_names) == 0) {
    return(NA_character_)
  }
  
  fits <- purrr::map(candidate_names, function(dist_name) {
    fit <- safe_fitdist(values, dist_name)
    if (is.null(fit)) return(NULL)
    tibble::tibble(distribution = dist_name, aic = stats::AIC(fit))
  })
  
  fits <- purrr::compact(fits)
  if (length(fits) == 0) return(NA_character_)
  
  best <- dplyr::bind_rows(fits) |>
    dplyr::arrange(.data$aic) |>
    dplyr::slice(1)
  
  label_map <- c(
    norm = "Normal",
    lnorm = "Log-normal",
    gamma = "Gamma",
    weibull = "Weibull",
    exp = "Exponential"
  )
  
  label_map[[best$distribution]] %||% best$distribution
}

safe_fitdist <- function(values, dist_name) {
  suppressWarnings(
    tryCatch(
      fitdistrplus::fitdist(values, dist_name),
      error = function(e) NULL
    )
  )
}

# ---- Shared printing ----
print_summary_sections <- function(results) {
  # 1) Print skim AS-IS (unchanged)
  cat(paste(capture.output(print(results$skim)), collapse = "\n"), "\n\n", sep = "")
  
  # 2) Helper to detect if a grouping column exists and what it's called
  metric_prefix <- "^(cv_|outliers_|missing_|distribution_)"
  first_col <- if (!is.null(results$cv) && ncol(results$cv) > 0) names(results$cv)[1] else NULL
  group_col <- if (!is.null(first_col) && !grepl(metric_prefix, first_col)) first_col else NULL
  
  # 3) Robust long conversion that preserves the real group column name (if any)
  to_long <- function(df, value_name) {
    if (is.null(df) || ncol(df) == 0) {
      empty_cols <- list(variable = character())
      if (!is.null(group_col)) {
        empty_cols[[group_col]] <- character()
      }
      empty_cols[[value_name]] <- numeric()
      return(tibble::as_tibble(empty_cols))
    }
    id_cols <- intersect(names(df), group_col)
    df |>
      tidyr::pivot_longer(
        cols = -tidyselect::any_of(id_cols),
        names_to = "variable",
        values_to = value_name
      ) |>
      dplyr::mutate(variable = sub(metric_prefix, "", .data$variable))
  }

  # 4) Build pieces (no "missing" here)
  cv_long   <- to_long(results$cv, "cv")
  out_long  <- to_long(results$outliers, "outliers")
  dist_long <- to_long(results$distribution, "distribution")

  # 5) Join by the right keys
  join_keys <- c(if (!is.null(group_col)) group_col, "variable")
  merged <- dplyr::full_join(cv_long, out_long, by = join_keys) |>
    dplyr::full_join(dist_long, by = join_keys) |>
    dplyr::mutate(
      cv = round(cv, 2)
    )

  numeric_order <- NULL
  if (is.data.frame(results$skim) && all(c("skim_type", "skim_variable") %in% names(results$skim))) {
    numeric_order <- results$skim |>
      dplyr::filter(.data$skim_type == "numeric") |>
      dplyr::pull(.data$skim_variable) |>
      unique()
  }

  arrange_cols <- c(if (!is.null(group_col)) group_col, "variable")
  if (!is.null(numeric_order) && length(numeric_order) > 0) {
    merged$variable <- factor(merged$variable, levels = numeric_order)
    merged <- dplyr::arrange(merged, !!!rlang::syms(arrange_cols))
    merged$variable <- as.character(merged$variable)
  } else {
    merged <- dplyr::arrange(merged, !!!rlang::syms(arrange_cols))
  }

  # 7) Print with/without group column
  cat("â”€â”€ Numeric variables summary â”€â”€\n")
  final_cols <- c("variable", arrange_cols[-length(arrange_cols)], "cv", "outliers", "distribution")
  final_df <- merged[, final_cols, drop = FALSE]
  print(as.data.frame(final_df), row.names = FALSE)

  cat("\nInterpretation:\n")
  cat("  â€¢ outliers = # beyond 1.5Ã—IQR\n")
  cat("  â€¢ distribution = best fit (AIC) among Normal/Log-normal/Gamma/Weibull/Exponential\n")

  invisible(NULL)
}
# ===============================================================
# Visualization Module â€” Descriptive Statistics (Dispatcher)
# ===============================================================

visualize_descriptive_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 5 â€” Visualize descriptive statistics"),
      p("Explore distributions, variability, and normality across variables."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c(
            "Categorical barplots" = "categorical",
            "Numeric boxplots"     = "boxplots",
            "Numeric histograms"   = "histograms",
            "CV (%)"               = "cv",
            "Outlier counts"       = "outliers",
            "Missingness (%)"      = "missing"
          ),
          selected = "categorical"
        ),
        "Choose the descriptive chart that best answers your question."
      ),
      uiOutput(ns("sub_controls"))
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_ui"))
    )
  )
}



visualize_descriptive_server <- function(id, filtered_data, descriptive_summary) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    # Active plot type name (UI only)
    active_type <- reactive({
      req(input$plot_type)
      input$plot_type
    })
    
    # Mount submodules ONCE
    # They no longer depend on "is_active"
    visualize_categorical_barplots_server("categorical", filtered_data, descriptive_summary)
    visualize_numeric_boxplots_server("boxplots", filtered_data, descriptive_summary)
    visualize_numeric_histograms_server("histograms", filtered_data, descriptive_summary)
    visualize_cv_server("cv", filtered_data, descriptive_summary)
    visualize_outliers_server("outliers", filtered_data, descriptive_summary)
    visualize_missing_server("missing", filtered_data, descriptive_summary)
    
    # ---- SUB-CONTROLS UI ----
    output$sub_controls <- renderUI({
      tagList(
        conditionalPanel(
          condition = sprintf("input['%s'] == 'categorical'", ns("plot_type")),
          visualize_categorical_barplots_ui(ns("categorical"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'boxplots'", ns("plot_type")),
          visualize_numeric_boxplots_ui(ns("boxplots"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'histograms'", ns("plot_type")),
          visualize_numeric_histograms_ui(ns("histograms"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'cv'", ns("plot_type")),
          visualize_cv_ui(ns("cv"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'outliers'", ns("plot_type")),
          visualize_outliers_ui(ns("outliers"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'missing'", ns("plot_type")),
          visualize_missing_ui(ns("missing"))
        )
      )
    })
    
    # ---- PLOT AREA UI ----
    output$plot_ui <- renderUI({
      tagList(
        conditionalPanel(
          condition = sprintf("input['%s'] == 'categorical'", ns("plot_type")),
          visualize_categorical_barplots_plot_ui(ns("categorical"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'boxplots'", ns("plot_type")),
          visualize_numeric_boxplots_plot_ui(ns("boxplots"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'histograms'", ns("plot_type")),
          visualize_numeric_histograms_plot_ui(ns("histograms"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'cv'", ns("plot_type")),
          visualize_cv_plot_ui(ns("cv"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'outliers'", ns("plot_type")),
          visualize_outliers_plot_ui(ns("outliers"))
        ),
        conditionalPanel(
          condition = sprintf("input['%s'] == 'missing'", ns("plot_type")),
          visualize_missing_plot_ui(ns("missing"))
        )
      )
    })
  })
}

# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Categorical Barplots
# ===============================================================

visualize_categorical_barplots_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(ns("show_proportions"), "Show proportions instead of counts", FALSE),
      "Switch between raw counts and percentages for each category."
    ),
    subplot_size_ui(
      ns,
      width_help = "Set the width of each categorical plot in pixels.",
      height_help = "Set the height of each categorical plot in pixels."
    ),
    plot_grid_ui(
      id = ns("plot_grid"),
      rows_help = "Choose how many rows of plots to display.",
      cols_help = "Choose how many columns of plots to display."
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, tagList(
        base_size_ui(
          ns,
          default = 13,
          help_text = "Adjust the base font size used for barplot text elements."
        ),
        br(),
        uiOutput(ns("common_legend_controls"))
      ))
    ),
    br(),
    fluidRow(
      column(
        6,
        actionButton(
          ns("apply_plot"), 
          "Apply changes",
          width = "100%"
        )
      ),
      column(
        6,
        downloadButton(
          ns("download_plot"),
          "Download plot",
          style = "width: 100%;"
        )
      )
    )
  )
}


visualize_categorical_barplots_plot_ui <- function(id) {
  ns <- NS(id)
  div(
    uiOutput(ns("grid_warning")),
    plotOutput(ns("plot"), width = "100%", height = "auto")
  )
}


visualize_categorical_barplots_server <- function(id, filtered_data, summary_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL,
      plot_width = 400,
      plot_height = 300
    )
    
    df <- reactive(filtered_data())
    
    grid <- plot_grid_server("plot_grid", cols_max = 100L)
    base_size <- base_size_server(input, default = 13)
    
    color_var <- reactive({
      info <- summary_info()
      dat <- df()
      g <- resolve_reactive(info$group_var)
      if (is.null(info) || is.null(dat)) return(NULL)
      if (is.null(g) || !g %in% names(dat)) return(NULL)
      g
    })
    
    custom_colors <- add_color_customization_server(
      ns, input, output, df, color_var, multi_group = TRUE
    )
    
    # --------------------------
    # Common legend logic
    # --------------------------
    legend_state <- reactiveValues(
      enabled = FALSE,
      position = "bottom"
    )
    
    observeEvent(input$use_common_legend, {
      legend_state$enabled <- isTRUE(input$use_common_legend)
    })
    
    observeEvent(input$common_legend_position, {
      legend_state$position <- input$common_legend_position
    })
    
    output$common_legend_controls <- renderUI({
      allow <- !is.null(color_var())
      if (!allow) return(NULL)
      
      checkbox <- with_help_tooltip(
        checkboxInput(
          ns("use_common_legend"), 
          "Use common legend",
          value = legend_state$enabled
        ),
        "Merge legends across subplots."
      )
      
      pos <- NULL
      if (legend_state$enabled) {
        pos <- with_help_tooltip(
          selectInput(
            ns("common_legend_position"),
            "Legend position",
            c("Bottom" = "bottom", "Right" = "right", "Top" = "top", "Left" = "left"),
            selected = legend_state$position
          ),
          "Choose legend placement."
        )
      }
      
      tagList(checkbox, pos)
    })
    
    # ==========================================================
    # APPLY LOGIC â€” the only place where the plot is computed
    # ==========================================================
    observeEvent(input$apply_plot, {
      data <- df()
      info <- summary_info()
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data available."
        stored$plot <- NULL
        return()
      }
      
      s_vars <- resolve_reactive(info$selected_vars)
      g_var  <- resolve_reactive(info$group_var)
      strata_levels <- resolve_reactive(info$strata_levels)
      
      res <- build_descriptive_categorical_plot(
        df = data,
        selected_vars = s_vars,
        group_var = g_var,
        strata_levels = strata_levels,
        show_proportions = input$show_proportions,
        nrow_input = grid$rows(),
        ncol_input = grid$cols(),
        fill_colors = custom_colors(),
        base_size = base_size(),
        common_legend = legend_state$enabled,
        legend_position = if (legend_state$enabled) legend_state$position else NULL
      )

      stored$plot    <- res$plot
      stored$warning <- res$warning
      stored$layout  <- res$layout

      apply_grid_defaults_if_empty(
        input,
        session,
        "plot_grid",
        res$defaults,
        n_items = res$panels
      )
    })
    
    # -------------------------
    # UI: warnings
    # -------------------------
    output$grid_warning <- renderUI({
      if (!is.null(stored$warning))
        div(class = "alert alert-warning", stored$warning)
    })
    
    # -------------------------
    # RENDER PLOT
    # -------------------------
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      nc <- (lay$ncol %||% 1)
      stored$plot_width * nc
    },
    height = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      nr <- (lay$nrow %||% 1)
      stored$plot_height * nr
    },
    res = 96)
    
    # -------------------------
    # DOWNLOAD BUTTON
    # -------------------------
    output$download_plot <- downloadHandler(
      filename = function() paste0("categorical_barplots_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        nc <- (lay$ncol %||% 1)
        nr <- (lay$nrow %||% 1)
        
        w_in <- (stored$plot_width  * nc) / 96
        h_in <- (stored$plot_height * nr) / 96
        
        ggsave(
          file, p,
          dpi = 300,
          width = w_in, height = h_in,
          units = "in", limitsize = FALSE
        )
      }
    )
  })
}

apply_value_scale <- function(plot, show_proportions) {
  if (isTRUE(show_proportions)) {
    plot + scale_y_continuous(
      labels = scales::percent_format(accuracy = 1),
      limits = c(0, 1)
    )
  } else {
    plot + scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05)))
  }
}

build_descriptive_categorical_plot <- function(df,
                                               selected_vars = NULL,
                                               group_var = NULL,
                                               strata_levels = NULL,
                                               show_proportions = FALSE,
                                               nrow_input = NULL,
                                               ncol_input = NULL,
                                               fill_colors = NULL,
                                               base_size = 13,
                                               common_legend = FALSE,
                                               legend_position = NULL) {
  if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) return(NULL)
  
  factor_vars <- names(df)[vapply(df, function(x) {
    is.character(x) || is.factor(x) || is.logical(x)
  }, logical(1))]
  
  if (!is.null(selected_vars) && length(selected_vars) > 0) {
    factor_vars <- intersect(factor_vars, selected_vars)
  }
  if (length(factor_vars) == 0) return(NULL)
  
  if (!is.null(group_var) && group_var %in% names(df)) {
    df[[group_var]] <- as.character(df[[group_var]])
    df[[group_var]][is.na(df[[group_var]]) | trimws(df[[group_var]]) == ""] <- "Missing"
    
    if (!is.null(strata_levels) && length(strata_levels) > 0) {
      keep_levels <- unique(strata_levels)
      df <- df[df[[group_var]] %in% keep_levels, , drop = FALSE]
      if (nrow(df) == 0) return(NULL)
      df[[group_var]] <- factor(df[[group_var]], levels = keep_levels)
    } else {
      df[[group_var]] <- factor(df[[group_var]], levels = unique(df[[group_var]]))
    }
  } else {
    group_var <- NULL
  }
  
  plots <- lapply(factor_vars, function(var) {
    group_col <- if (!is.null(group_var) && !identical(group_var, var)) group_var else NULL
    cols_to_use <- c(var, group_col)
    cols_to_use <- cols_to_use[cols_to_use %in% names(df)]
    var_data <- df[, cols_to_use, drop = FALSE]
    
    var_data[[var]] <- as.character(var_data[[var]])
    keep <- !is.na(var_data[[var]]) & trimws(var_data[[var]]) != ""
    if (!any(keep)) return(NULL)
    var_data <- var_data[keep, , drop = FALSE]
    
    level_order <- if (is.factor(df[[var]])) {
      as.character(levels(df[[var]]))
    } else {
      unique(var_data[[var]])
    }
    var_data[[var]] <- factor(var_data[[var]], levels = level_order)
    
    y_label <- if (isTRUE(show_proportions)) "Proportion" else "Count"
    
    if (!is.null(group_col)) {
      var_data[[group_col]] <- droplevels(var_data[[group_col]])
      count_df <- dplyr::count(var_data, .data[[var]], .data[[group_col]], name = "count")
      if (nrow(count_df) == 0) return(NULL)

      if (isTRUE(show_proportions)) {
        count_df <- count_df |>
          dplyr::group_by(.data[[group_col]]) |>
          dplyr::mutate(total = sum(.data$count, na.rm = TRUE)) |>
          dplyr::mutate(value = ifelse(.data$total > 0, .data$count / .data$total, 0)) |>
          dplyr::ungroup()
        count_df$total <- NULL
      } else {
        count_df <- dplyr::mutate(count_df, value = .data$count)
      }

      count_df[[var]] <- factor(as.character(count_df[[var]]), levels = level_order)
      group_levels <- levels(droplevels(var_data[[group_col]]))
      count_df[[group_col]] <- factor(as.character(count_df[[group_col]]), levels = group_levels)

      palette <- resolve_palette_for_levels(group_levels, custom = fill_colors)
      group_dodge <- position_dodge(width = 0.75)

      p <- ggplot(count_df, aes(x = .data[[var]], y = .data$value, fill = .data[[group_col]])) +
        geom_col(position = group_dodge, width = 0.65) +
        scale_fill_manual(values = palette) +
        ta_plot_theme(base_size = base_size) +
        labs(title = var, x = NULL, y = y_label, fill = group_col) +
        theme(
          plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
          axis.text.x = element_text(angle = 45, hjust = 1),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color = "#9ca3af"),
          axis.ticks = element_line(color = "#9ca3af")
        )

      apply_value_scale(p, show_proportions)
    } else {
      count_df <- dplyr::count(var_data, .data[[var]], name = "count")
      if (nrow(count_df) == 0) return(NULL)

      total <- sum(count_df$count, na.rm = TRUE)
      if (isTRUE(show_proportions) && total > 0) {
        count_df$value <- count_df$count / total
      } else {
        count_df$value <- count_df$count
      }

      count_df[[var]] <- factor(as.character(count_df[[var]]), levels = level_order)

      single_fill <- if (!is.null(fill_colors) && length(fill_colors) > 0) {
        fill_colors[1]
      } else {
        resolve_single_color()
      }

      p <- ggplot(count_df, aes(x = .data[[var]], y = .data$value)) +
        geom_col(fill = single_fill, width = 0.65) +
        ta_plot_theme(base_size = base_size) +
        labs(title = var, x = NULL, y = y_label) +
        theme(
          plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
          axis.text.x = element_text(angle = 45, hjust = 1),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color = "#9ca3af"),
          axis.ticks = element_line(color = "#9ca3af")
        )

      apply_value_scale(p, show_proportions)
    }
  })
  
  plots <- Filter(Negate(is.null), plots)
  if (length(plots) == 0) return(NULL)
  
  n_panels <- length(plots)
  defaults <- compute_default_grid(n_panels)

  layout <- basic_grid_layout(
    rows = suppressWarnings(as.numeric(nrow_input)),
    cols = suppressWarnings(as.numeric(ncol_input)),
    default_rows = defaults$rows,
    default_cols = defaults$cols
  )

  validation <- validate_grid(n_panels, layout$nrow, layout$ncol)

  combined <- NULL
  if (isTRUE(validation$valid)) {
    combined <- patchwork::wrap_plots(plots, nrow = layout$nrow, ncol = layout$ncol) +
      patchwork::plot_annotation(
        theme = theme(plot.title = element_text(size = base_size, face = "bold", hjust = 0.5))
      )

    combined <- apply_common_legend_layout(
      combined,
      legend_position = legend_position,
      collect_guides = isTRUE(common_legend)
    )
  }

  list(
    plot = combined,
    layout = list(nrow = layout$nrow, ncol = layout$ncol),
    panels = n_panels,
    warning = validation$message,
    defaults = defaults
  )
}

# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Summary Metrics
# ===============================================================

metric_panel_ui <- function(id, default_width = 400, default_height = 300,
                            default_rows = 1, default_cols = 1) {
  ns <- NS(id)
  tagList(
    subplot_size_ui(
      ns,
      width_value = default_width,
      height_value = default_height,
      width_help = "Set the width of each metric panel in pixels.",
      height_help = "Set the height of each metric panel in pixels."
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, base_size_ui(
        ns,
        default = 13,
        help_text = "Adjust the base font size used for metric plots."
      ))
    ),
    br(),
    fluidRow(
      column(
        6,
        actionButton(
          ns("apply_plot"),
          "Apply changes",
          width = "100%"
        )
      ),
      column(
        6,
        downloadButton(
          ns("download_plot"),
          "Download plot",
          style = "width: 100%;"
        )
      )
    )
  )
}



visualize_cv_ui <- visualize_outliers_ui <- visualize_missing_ui <- function(id) {
  metric_panel_ui(id, default_width = 800, default_height = 600, default_rows = 2, default_cols = 3)
}

metric_plot_ui <- function(id) {
  ns <- NS(id)
  plotOutput(ns("plot"), width = "100%", height = "auto")
}

visualize_cv_plot_ui <- visualize_outliers_plot_ui <- visualize_missing_plot_ui <- metric_plot_ui


safe_cv <- function(x) {
  m <- mean(x, na.rm = TRUE)
  s <- stats::sd(x, na.rm = TRUE)
  if (!is.finite(m) || abs(m) < .Machine$double.eps) {
    return(NA_real_)
  }
  100 * s / m
}

count_outliers <- function(x) {
  q <- stats::quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
  iqr <- q[2] - q[1]
  sum(x < q[1] - 1.5 * iqr | x > q[2] + 1.5 * iqr, na.rm = TRUE)
}

missing_pct <- function(x) {
  100 * mean(is.na(x))
}

prepare_metric_data <- function(data, numeric_vars, group_var, strata_levels, metric) {
  if (length(numeric_vars) == 0) {
    return(NULL)
  }

  if (is.null(group_var) || !group_var %in% names(data)) {
    group_var <- NULL
  }

  data_tbl <- tibble::as_tibble(data)

  if (!is.null(group_var)) {
    if (!is.null(strata_levels) && length(strata_levels) > 0) {
      data_tbl[[group_var]] <- factor(as.character(data_tbl[[group_var]]), levels = strata_levels)
      data_tbl <- droplevels(data_tbl)
    }
    data_tbl <- dplyr::group_by(data_tbl, .data[[group_var]], .drop = TRUE)
  }

  summarised <- switch(
    metric,
    cv = dplyr::summarise(
      data_tbl,
      dplyr::across(
        dplyr::all_of(numeric_vars),
        ~ safe_cv(.x),
        .names = "cv_{.col}"
      ),
      .groups = "drop"
    ),
    outliers = dplyr::summarise(
      data_tbl,
      dplyr::across(
        dplyr::all_of(numeric_vars),
        ~ count_outliers(.x),
        .names = "outliers_{.col}"
      ),
      .groups = "drop"
    ),
    missing = dplyr::summarise(
      data_tbl,
      dplyr::across(
        dplyr::all_of(numeric_vars),
        ~ missing_pct(.x),
        .names = "missing_{.col}"
      ),
      .groups = "drop"
    ),
    stop("Unsupported metric type.")
  )

  tidy <- tidy_descriptive_metric(summarised, metric)
  if (is.null(tidy)) {
    return(NULL)
  }

  tidy$data <- tidy$data[tidy$data$variable %in% numeric_vars, , drop = FALSE]
  if (nrow(tidy$data) == 0) {
    return(NULL)
  }

  tidy$data$variable <- factor(tidy$data$variable, levels = numeric_vars)

  if (!is.null(group_var) && !is.null(strata_levels) && length(strata_levels) > 0) {
    tidy$data$.group <- factor(as.character(tidy$data$.group), levels = strata_levels)
  }

  tidy
}

tidy_descriptive_metric <- function(df, prefix) {
  if (is.null(df) || nrow(df) == 0) return(NULL)
  metric_cols <- grep(paste0("^", prefix, "_"), names(df), value = TRUE)
  if (length(metric_cols) == 0) return(NULL)
  group_cols <- setdiff(names(df), metric_cols)
  has_group <- length(group_cols) > 0
  group_label <- if (has_group) paste(group_cols, collapse = " / ") else NULL
  if (!has_group) {
    df <- df |> dplyr::mutate(.group = "Overall")
    group_cols <- ".group"
  }
  tidy <- df |>
    tidyr::unite(".group", dplyr::all_of(group_cols), sep = " / ", remove = FALSE) |>
    tidyr::pivot_longer(
      cols = dplyr::all_of(metric_cols),
      names_to = "variable",
      values_to = "value"
    ) |>
    dplyr::mutate(
      variable = gsub(paste0("^", prefix, "_"), "", .data$variable),
      value = ifelse(is.finite(.data$value), .data$value, NA_real_),
      .group = factor(.data$.group, levels = unique(.data$.group))
    ) |>
    tidyr::drop_na("value")
  if (nrow(tidy) == 0) return(NULL)
  list(data = tidy, has_group = has_group, group_label = group_label)
}


build_metric_plot <- function(metric_info,
                              y_label,
                              title,
                              custom_colors = NULL,
                              base_size = 13) {
  df <- metric_info$data
  has_group <- isTRUE(metric_info$has_group)

  if (has_group) {
    legend_title <- if (!is.null(metric_info$group_label)) metric_info$group_label else "Group"
    palette <- resolve_palette_for_levels(levels(df$.group), custom = custom_colors)
    p <- ggplot(df, aes(x = variable, y = value, fill = .group)) +
      geom_col(position = position_dodge(width = 0.7), width = 0.65) +
      scale_fill_manual(values = palette) +
      labs(fill = legend_title)
  } else {
    p <- ggplot(df, aes(x = variable, y = value)) +
      geom_col(width = 0.65, fill = resolve_single_color(custom_colors)) +
      guides(fill = "none")
  }

  p +
    ta_plot_theme(base_size = base_size) +
    labs(x = NULL, y = y_label, title = title) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af")
    )
}


metric_module_server <- function(id, filtered_data, summary_info, metric_key,
                                 y_label, title, filename_prefix, is_active = NULL) {
  
  moduleServer(id, function(input, output, session) {
    
    ns <- session$ns
    
    # ---- Stored state (same as all other modules) ----
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      plot_width  = 400,
      plot_height = 300
    )
    
    df <- reactive(filtered_data())
    base_size <- base_size_server(input, default = 13)
    
    # Color variable
    color_var_reactive <- reactive({
      info <- summary_info()
      group_var <- resolve_reactive(info$group_var)
      dat <- df()
      if (is.null(group_var) || !group_var %in% names(dat)) return(NULL)
      group_var
    })
    
    custom_colors <- add_color_customization_server(
      ns, input, output, df,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )
    
    # ---- APPLY button ----
    observeEvent(input$apply_plot, {
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      data <- df()
      info <- summary_info()
      
      # Basic checks
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data available."
        stored$plot <- NULL
        return()
      }
      
      processed <- resolve_reactive(info$processed_data)
      dat <- if (!is.null(processed)) processed else data
      
      selected_vars <- resolve_reactive(info$selected_vars)
      group_var     <- resolve_reactive(info$group_var)
      strata_levels <- resolve_reactive(info$strata_levels)
      group_label   <- resolve_reactive(info$group_label)
      
      # Select numeric vars in correct order
      numeric_vars <- names(dat)[vapply(dat, is.numeric, logical(1))]
      if (!is.null(selected_vars) && length(selected_vars) > 0) {
        numeric_vars <- selected_vars[selected_vars %in% numeric_vars]
      }
      
      if (length(numeric_vars) == 0) {
        stored$warning <- "No numeric variables available for this metric."
        stored$plot <- NULL
        return()
      }
      
      # Compute CV / Outliers / Missingness
      metric_info <- prepare_metric_data(
        data = dat,
        numeric_vars = numeric_vars,
        group_var = group_var,
        strata_levels = strata_levels,
        metric = metric_key
      )
      
      if (is.null(metric_info)) {
        stored$warning <- "Unable to compute metric for selected variables."
        stored$plot <- NULL
        return()
      }
      
      if (!is.null(group_label)) {
        metric_info$group_label <- group_label
      }
      
      p <- build_metric_plot(
        metric_info = metric_info,
        y_label = y_label,
        title = title,
        custom_colors = custom_colors(),
        base_size = base_size()
      )
      
      stored$plot    <- p
      stored$warning <- NULL
    })
    
    # ---- Render Plot ----
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() stored$plot_width,
    height = function() stored$plot_height,
    res = 96)
    
    # ---- Download ----
    output$download_plot <- downloadHandler(
      filename = function() paste0(filename_prefix, "_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        w_in <- stored$plot_width  / 96
        h_in <- stored$plot_height / 96
        
        ggsave(
          file, p,
          dpi = 300,
          width = w_in, height = h_in,
          units = "in", limitsize = FALSE
        )
      }
    )
  })
}



metric_server_factory <- function(metric_key, y_label, filename_prefix) {
  force(metric_key)
  force(y_label)
  force(filename_prefix)

  function(id, filtered_data, summary_info, is_active = NULL) {
    metric_module_server(
      id = id,
      filtered_data = filtered_data,
      summary_info = summary_info,
      metric_key = metric_key,
      y_label = y_label,
      title = "",
      filename_prefix = filename_prefix,
      is_active = is_active
    )
  }
}

visualize_cv_server <- metric_server_factory("cv", "CV (%)", "cv_summary")
visualize_outliers_server <- metric_server_factory("outliers", "Outlier Count", "outlier_summary")
visualize_missing_server <- metric_server_factory("missing", "Missing (%)", "missing_summary")
# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Numeric Boxplots
# ===============================================================

visualize_numeric_boxplots_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(ns("show_points"), "Show individual data points", TRUE),
      "Add the raw observations on top of each boxplot."
    ),
    with_help_tooltip(
      checkboxInput(ns("show_outliers"), "Highlight boxplot outliers", FALSE),
      "Highlight points that fall outside the typical range."
    ),
    
    conditionalPanel(
      condition = sprintf("input['%s']", ns("show_outliers")),
      uiOutput(ns("outlier_label_ui"))
    ),
    
    subplot_size_ui(
      ns,
      width_value = 200,
      height_value = 800,
      width_help = "Control how wide each boxplot panel should be.",
      height_help = "Control how tall each boxplot panel should be."
    ),
    
    plot_grid_ui(
      id = ns("plot_grid"),
      rows_help = "Choose how many rows of plots to display.",
      cols_help = "Choose how many columns of plots to display.",
      cols_max = 100L
    ),
    
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, tagList(
        base_size_ui(
          ns,
          default = 13,
          help_text = "Adjust the base font size used for boxplot text."
        ),
        br(),
        uiOutput(ns("common_legend_controls"))
      ))
    ),
    br(),
    fluidRow(
      column(
        6,
        actionButton(
          ns("apply_plot"),
          "Apply changes",
          width = "100%"
        )
      ),
      column(
        6,
        downloadButton(
          ns("download_plot"),
          "Download plot",
          style = "width: 100%;"
        )
      )
    )
  )
}

visualize_numeric_boxplots_plot_ui <- function(id) {
  ns <- NS(id)
  div(
    uiOutput(ns("grid_warning")),
    plotOutput(ns("plot"), width = "100%", height = "auto")
  )
}


visualize_numeric_boxplots_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  moduleServer(id, function(input, output, session) {
    
    ns <- session$ns
    
    #======================================================
    # Stored state (same pattern as ANOVA + Barplots)
    #======================================================
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL,
      plot_width = 200,
      plot_height = 800
    )
    
    df <- reactive(filtered_data())
    
    grid <- plot_grid_server("plot_grid", cols_max = 100L)
    base_size <- base_size_server(input, default = 13)
    
    #======================================================
    # Outlier label dropdown (depends on data)
    #======================================================
    output$outlier_label_ui <- renderUI({
      dat <- df()
      if (is.null(dat)) return(NULL)
      
      cat_cols <- names(dat)[vapply(dat, \(x) is.character(x) || is.factor(x) || is.logical(x), logical(1))]
      cat_cols <- sort(unique(cat_cols))
      
      current <- isolate(input$outlier_label)
      if (is.null(current) || !current %in% cat_cols) current <- ""
      
      with_help_tooltip(
        selectInput(
          ns("outlier_label"),
          "Label outliers by",
          choices = c("None" = "", stats::setNames(cat_cols, cat_cols)),
          selected = current
        ),
        "Choose a column to annotate the highlighted outliers."
      )
    })
    
    #======================================================
    # Color grouping
    #======================================================
    color_var <- reactive({
      info <- summary_info()
      g <- resolve_reactive(info$group_var)
      dat <- df()
      if (is.null(g) || is.null(dat) || !g %in% names(dat)) return(NULL)
      g
    })
    
    custom_colors <- add_color_customization_server(
      ns, input, output, df, color_var, multi_group = TRUE
    )
    
    #======================================================
    # Common legend toggle
    #======================================================
    legend_state <- reactiveValues(enabled = FALSE, position = "bottom")
    
    observeEvent(input$use_common_legend, {
      legend_state$enabled <- isTRUE(input$use_common_legend)
    })
    
    observeEvent(input$common_legend_position, {
      legend_state$position <- input$common_legend_position
    })
    
    output$common_legend_controls <- renderUI({
      if (is.null(color_var())) return(NULL)
      
      checkbox <- with_help_tooltip(
        checkboxInput(
          ns("use_common_legend"),
          "Use common legend",
          value = legend_state$enabled
        ),
        "Merge legends across panels."
      )
      
      pos <- NULL
      if (legend_state$enabled) {
        pos <- with_help_tooltip(
          selectInput(
            ns("common_legend_position"),
            "Legend position",
            c("Bottom"="bottom","Right"="right","Top"="top","Left"="left"),
            selected = legend_state$position
          ),
          "Choose placement for the combined legend."
        )
      }
      
      tagList(checkbox, pos)
    })
    
    #======================================================
    # APPLY BUTTON â€” the *only* place where plots are computed
    #======================================================
    observeEvent(input$apply_plot, {
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      data <- df()
      info <- summary_info()
      
      if (is.null(data) || is.null(info) || nrow(data) == 0) {
        stored$warning <- "No data available."
        stored$plot <- NULL
        return()
      }
      
      s_vars <- resolve_reactive(info$selected_vars)
      g_var  <- resolve_reactive(info$group_var)
      processed <- resolve_reactive(info$processed_data)
      dat <- if (!is.null(processed)) processed else data
      
      res <- build_descriptive_numeric_boxplot(
        df = dat,
        selected_vars = s_vars,
        group_var = g_var,
        show_points = input$show_points,
        show_outliers = input$show_outliers,
        outlier_label_var = validate_outlier_label(input$outlier_label),
        nrow_input = grid$rows(),
        ncol_input = grid$cols(),
        custom_colors = custom_colors(),
        base_size = base_size(),
        common_legend = legend_state$enabled,
        legend_position = if (legend_state$enabled) legend_state$position else NULL
      )

      stored$plot    <- res$plot
      stored$layout  <- res$layout
      stored$warning <- res$warning

      apply_grid_defaults_if_empty(
        input,
        session,
        "plot_grid",
        res$defaults,
        n_items = res$panels
      )
    })
    
    #======================================================
    # warnings
    #======================================================
    output$grid_warning <- renderUI({
      if (!is.null(stored$warning))
        div(class = "alert alert-warning", stored$warning)
    })
    
    #======================================================
    # RENDER PLOT
    #======================================================
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_width * (lay$ncol %||% 1)
    },
    height = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_height * (lay$nrow %||% 1)
    },
    res = 96)
    
    #======================================================
    # DOWNLOAD BUTTON (same behavior as ANOVA + categorical)
    #======================================================
    output$download_plot <- downloadHandler(
      filename = function() paste0("numeric_boxplots_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        nc <- (lay$ncol %||% 1)
        nr <- (lay$nrow %||% 1)
        
        w_in <- (stored$plot_width  * nc) / 96
        h_in <- (stored$plot_height * nr) / 96
        
        ggsave(
          file, p,
          dpi = 300,
          width = w_in,
          height = h_in,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}


build_descriptive_numeric_boxplot <- function(df,
                                              selected_vars = NULL,
                                              group_var = NULL,
                                              show_points = TRUE,
                                              show_outliers = FALSE,
                                              outlier_label_var = NULL,
                                              nrow_input = NULL,
                                              ncol_input = NULL,
                                              custom_colors = NULL,
                                              base_size = 13,
                                              common_legend = FALSE,
                                              legend_position = NULL) {
  if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) return(NULL)

  num_vars <- names(df)[vapply(df, is.numeric, logical(1))]
  if (!is.null(selected_vars) && length(selected_vars) > 0) {
    num_vars <- intersect(num_vars, selected_vars)
  }
  if (length(num_vars) == 0) return(NULL)
  
  # ensure discrete x if grouped
  if (!is.null(group_var) && group_var %in% names(df)) {
    df[[group_var]] <- as.factor(df[[group_var]])
  } else {
    group_var <- NULL
  }
  
  plots <- lapply(num_vars, function(var) {
    vec <- df[[var]]
    if (all(is.na(vec))) return(NULL)

    if (!is.null(group_var)) {
      group_levels <- levels(df[[group_var]])
      palette <- resolve_palette_for_levels(group_levels, custom = custom_colors)
      p <- ggplot(df, aes(x = .data[[group_var]], y = .data[[var]], fill = .data[[group_var]])) +
        geom_boxplot(outlier.shape = NA, width = 0.6) +
        scale_fill_manual(values = palette) +
        ta_plot_theme(base_size = base_size) +
        labs(x = NULL, y = var) +
        theme(
          axis.text.x = element_text(angle = 45, hjust = 1),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color = "#9ca3af"),
          axis.ticks = element_line(color = "#9ca3af")
        )

      needs_color_scale <- FALSE
      if (isTRUE(show_points)) {
        p <- p + geom_jitter(
          aes(color = .data[[group_var]]),
          width = 0.2,
          alpha = 0.5,
          size = 1
        )
        needs_color_scale <- TRUE
      }

      if (isTRUE(show_outliers)) {
        outliers <- prepare_boxplot_outliers(
          data = df,
          value_col = var,
          group_col = group_var,
          label_col = outlier_label_var
        )
        if (has_rows(outliers)) {
          p <- p + geom_point(
            data = outliers,
            aes(x = x, y = y, color = group),
            inherit.aes = FALSE,
            size = 2.5,
            show.legend = FALSE
          )
          needs_color_scale <- TRUE

          label_data <- filter_labeled_outliers(outliers)
          if (has_rows(label_data)) {
            p <- p + ggrepel::geom_text_repel(
              data = label_data,
              aes(x = x, y = y, label = label, color = group),
              inherit.aes = FALSE,
              size = 3,
              max.overlaps = Inf,
              min.segment.length = 0,
              box.padding = 0.3,
              point.padding = 0.2,
              show.legend = FALSE
            )
          }
        }
      }

      if (needs_color_scale) {
        p <- p + scale_color_manual(values = palette, guide = "none")
      }
    } else {
      single_color <- resolve_single_color(custom_colors)
      p <- ggplot(df, aes(x = factor(1), y = .data[[var]])) +
        geom_boxplot(fill = single_color, width = 0.3) +
        ta_plot_theme(base_size = base_size) +
        labs(x = NULL, y = var) +
        theme(
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color = "#9ca3af"),
          axis.ticks = element_line(color = "#9ca3af")
        )

      if (isTRUE(show_points)) {
        p <- p + geom_jitter(color = single_color, width = 0.05, alpha = 0.5, size = 1)
      }

      if (isTRUE(show_outliers)) {
        outliers <- prepare_boxplot_outliers(
          data = df,
          value_col = var,
          label_col = outlier_label_var
        )
        if (has_rows(outliers)) {
          p <- p + geom_point(
            data = outliers,
            aes(x = x, y = y),
            inherit.aes = FALSE,
            color = single_color,
            size = 2.5,
            show.legend = FALSE
          )

          label_data <- filter_labeled_outliers(outliers)
          if (has_rows(label_data)) {
            p <- p + ggrepel::geom_text_repel(
              data = label_data,
              aes(x = x, y = y, label = label),
              inherit.aes = FALSE,
              size = 3,
              color = single_color,
              max.overlaps = Inf,
              min.segment.length = 0,
              box.padding = 0.3,
              point.padding = 0.2,
              show.legend = FALSE
            )
          }
        }
      }
    }

    if (inherits(p, "gg")) p else NULL
  })
  
  # keep only valid ggplots
  plots <- Filter(Negate(is.null), plots)
  if (length(plots) == 0) return(NULL)

  n_panels <- length(plots)
  defaults <- list(
    rows = 1L,
    cols = max(1L, as.integer(n_panels))
  )

  layout <- basic_grid_layout(
    rows = suppressWarnings(as.numeric(nrow_input)),
    cols = suppressWarnings(as.numeric(ncol_input)),
    default_rows = defaults$rows,
    default_cols = defaults$cols,
    max_cols = max(100L, as.integer(defaults$cols))
  )

  validation <- validate_grid(n_panels, layout$nrow, layout$ncol)

  combined <- NULL
  if (isTRUE(validation$valid)) {
    combined <- patchwork::wrap_plots(plots, nrow = layout$nrow, ncol = layout$ncol)

    combined <- apply_common_legend_layout(
      combined,
      legend_position = legend_position,
      collect_guides = isTRUE(common_legend)
    )
  }

  list(
    plot = combined,
    layout = list(nrow = layout$nrow, ncol = layout$ncol),
    panels = n_panels,
    warning = validation$message,
    defaults = defaults
  )
}


has_rows <- function(x) {
  is.data.frame(x) && nrow(x) > 0
}


compute_outlier_bounds <- function(values) {
  if (is.null(values)) return(NULL)
  values <- values[!is.na(values)]
  if (!length(values)) return(NULL)

  stats <- stats::quantile(values, probs = c(0.25, 0.75), na.rm = TRUE, names = FALSE)
  if (anyNA(stats)) return(NULL)

  iqr <- stats[2] - stats[1]
  list(
    lower = stats[1] - 1.5 * iqr,
    upper = stats[2] + 1.5 * iqr
  )
}


clean_outlier_labels <- function(values) {
  if (is.null(values)) return(character())
  out <- as.character(values)
  out[is.na(out) | trimws(out) == ""] <- NA_character_
  out
}


filter_labeled_outliers <- function(outliers) {
  if (!has_rows(outliers) || !"label" %in% names(outliers)) {
    return(NULL)
  }
  labeled <- outliers[!is.na(outliers$label) & nzchar(outliers$label), , drop = FALSE]
  if (has_rows(labeled)) labeled else NULL
}


validate_outlier_label <- function(label_input) {
  if (is.null(label_input) || !nzchar(label_input)) {
    return(NULL)
  }
  label_input
}


prepare_boxplot_outliers <- function(data,
                                     value_col,
                                     group_col = NULL,
                                     label_col = NULL) {
  if (is.null(data) || !is.data.frame(data) || !value_col %in% names(data)) {
    return(NULL)
  }

  extract_labels <- function(df, idx) {
    if (is.null(label_col) || !label_col %in% names(df)) {
      return(rep(NA_character_, length(idx)))
    }
    clean_outlier_labels(df[[label_col]][idx])
  }

  if (!is.null(group_col) && group_col %in% names(data)) {
    grouped <- data
    grouped[[group_col]] <- droplevels(as.factor(grouped[[group_col]]))
    group_levels <- levels(grouped[[group_col]])
    split_data <- split(grouped, grouped[[group_col]], drop = TRUE)

    out_list <- lapply(group_levels, function(lvl) {
      subset <- split_data[[lvl]]
      if (is.null(subset)) return(NULL)

      bounds <- compute_outlier_bounds(subset[[value_col]])
      if (is.null(bounds)) return(NULL)

      idx <- which(subset[[value_col]] < bounds$lower | subset[[value_col]] > bounds$upper)
      if (!length(idx)) return(NULL)

      data.frame(
        x = factor(rep(lvl, length(idx)), levels = group_levels),
        y = subset[[value_col]][idx],
        group = factor(rep(lvl, length(idx)), levels = group_levels),
        label = extract_labels(subset, idx),
        stringsAsFactors = FALSE
      )
    })

    out_list <- Filter(has_rows, out_list)
    if (!length(out_list)) return(NULL)

    outliers <- do.call(rbind, out_list)
    rownames(outliers) <- NULL
    return(outliers)
  }

  bounds <- compute_outlier_bounds(data[[value_col]])
  if (is.null(bounds)) return(NULL)

  idx <- which(data[[value_col]] < bounds$lower | data[[value_col]] > bounds$upper)
  if (!length(idx)) return(NULL)

  data.frame(
    x = factor(rep(1, length(idx))),
    y = data[[value_col]][idx],
    group = NA,
    label = extract_labels(data, idx),
    stringsAsFactors = FALSE
  )
}

# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Numeric Histograms
# ===============================================================

visualize_numeric_histograms_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(ns("use_density"), "Show density instead of count", FALSE),
      "Switch between showing counts or densities for each histogram."
    ),
    
    subplot_size_ui(
      ns,
      width_help  = "Set the width of each histogram panel in pixels.",
      height_help = "Set the height of each histogram panel in pixels."
    ),
    
    plot_grid_ui(
      id = ns("plot_grid"),
      rows_help = "Choose how many rows of histograms to display.",
      cols_help = "Choose how many columns of histograms to display."
    ),
    
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, tagList(
        base_size_ui(
          ns,
          default = 13,
          help_text = "Adjust the base font size used for histogram labels."
        ),
        br(),
        uiOutput(ns("common_legend_controls"))
      ))
    ),
    br(),
    fluidRow(
      column(
        6,
        actionButton(
          ns("apply_plot"),
          "Apply changes",
          width = "100%"
        )
      ),
      column(
        6,
        downloadButton(
          ns("download_plot"),
          "Download plot",
          style = "width: 100%;"
        )
      )
    )
  )
}


visualize_numeric_histograms_plot_ui <- function(id) {
  ns <- NS(id)
  div(
    uiOutput(ns("grid_warning")),
    plotOutput(ns("plot"), width = "100%", height = "auto")
  )
}


visualize_numeric_histograms_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  moduleServer(id, function(input, output, session) {
    
    ns <- session$ns
    
    # ================================================================
    # Stored state (same logic as the ANOVA / barplots / boxplots)
    # ================================================================
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL,
      plot_width  = 400,
      plot_height = 300
    )
    
    df <- reactive(filtered_data())
    
    grid <- plot_grid_server("plot_grid", cols_max = 100L)
    base_size <- base_size_server(input, default = 13)
    
    # ================================================================
    # Color grouping
    # ================================================================
    color_var <- reactive({
      info <- summary_info()
      g <- resolve_reactive(info$group_var)
      dat <- df()
      if (is.null(g) || is.null(dat) || !g %in% names(dat)) return(NULL)
      g
    })
    
    custom_colors <- add_color_customization_server(
      ns, input, output, df, color_var, multi_group = TRUE
    )
    
    # ================================================================
    # Common legend
    # ================================================================
    legend_state <- reactiveValues(enabled = FALSE, position = "bottom")
    
    observeEvent(input$use_common_legend, {
      legend_state$enabled <- isTRUE(input$use_common_legend)
    })
    
    observeEvent(input$common_legend_position, {
      legend_state$position <- input$common_legend_position
    })
    
    output$common_legend_controls <- renderUI({
      if (is.null(color_var())) return(NULL)
      
      checkbox <- with_help_tooltip(
        checkboxInput(
          ns("use_common_legend"),
          "Use common legend",
          value = legend_state$enabled
        ),
        "Merge color legends across histogram panels."
      )
      
      pos <- NULL
      if (legend_state$enabled) {
        pos <- with_help_tooltip(
          selectInput(
            ns("common_legend_position"),
            "Legend position",
            c("Bottom"="bottom","Right"="right","Top"="top","Left"="left"),
            selected = legend_state$position
          ),
          "Choose placement for the combined legend."
        )
      }
      
      tagList(checkbox, pos)
    })
    
    # ================================================================
    # APPLY â€” compute histogram only when user clicks
    # ================================================================
    observeEvent(input$apply_plot, {
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      data <- df()
      info <- summary_info()
      
      if (is.null(data) || is.null(info) || nrow(data) == 0) {
        stored$warning <- "No data available."
        stored$plot <- NULL
        return()
      }
      
      s_vars <- resolve_reactive(info$selected_vars)
      g_var  <- resolve_reactive(info$group_var)
      strata_levels <- resolve_reactive(info$strata_levels)
      
      processed <- resolve_reactive(info$processed_data)
      dat <- if (!is.null(processed)) processed else data
      
      res <- build_descriptive_numeric_histogram(
        df = dat,
        selected_vars = s_vars,
        group_var = g_var,
        strata_levels = strata_levels,
        use_density = input$use_density,
        nrow_input = grid$rows(),
        ncol_input = grid$cols(),
        custom_colors = custom_colors(),
        base_size = base_size(),
        common_legend = legend_state$enabled,
        legend_position = if (legend_state$enabled) legend_state$position else NULL
      )

      stored$plot    <- res$plot
      stored$layout  <- res$layout
      stored$warning <- res$warning

      apply_grid_defaults_if_empty(
        input,
        session,
        "plot_grid",
        res$defaults,
        n_items = res$panels
      )
    })
    
    # ================================================================
    # Warning box
    # ================================================================
    output$grid_warning <- renderUI({
      if (!is.null(stored$warning))
        div(class = "alert alert-warning", stored$warning)
    })
    
    # ================================================================
    # RENDER HISTOGRAM
    # ================================================================
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_width * (lay$ncol %||% 1)
    },
    height = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_height * (lay$nrow %||% 1)
    },
    res = 96)
    
    # ================================================================
    # DOWNLOAD â€” matches what user sees
    # ================================================================
    output$download_plot <- downloadHandler(
      filename = function() paste0("numeric_histograms_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        nc <- (lay$ncol %||% 1)
        nr <- (lay$nrow %||% 1)
        
        w_in <- (stored$plot_width  * nc) / 96
        h_in <- (stored$plot_height * nr) / 96
        
        ggsave(
          file, p,
          dpi = 300,
          width = w_in, height = h_in,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}


build_descriptive_numeric_histogram <- function(df,
                                                selected_vars = NULL,
                                                group_var = NULL,
                                                strata_levels = NULL,
                                                use_density = FALSE,
                                                nrow_input = NULL,
                                                ncol_input = NULL,
                                                custom_colors = NULL,
                                                base_size = 13,
                                                common_legend = FALSE,
                                                legend_position = NULL) {
  if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) return(NULL)

  num_vars <- names(Filter(is.numeric, df))
  if (!is.null(selected_vars) && length(selected_vars) > 0) {
    num_vars <- intersect(num_vars, selected_vars)
  }
  if (length(num_vars) == 0) return(NULL)

  if (is.null(group_var) || !group_var %in% names(df)) {
    group_var <- NULL
  } else {
    df[[group_var]] <- as.character(df[[group_var]])
    df[[group_var]][is.na(df[[group_var]]) | trimws(df[[group_var]]) == ""] <- "Missing"

    if (!is.null(strata_levels) && length(strata_levels) > 0) {
      keep_levels <- unique(strata_levels)
      df <- df[df[[group_var]] %in% keep_levels, , drop = FALSE]
      if (nrow(df) == 0) return(NULL)
      df[[group_var]] <- factor(df[[group_var]], levels = keep_levels)
    } else {
      df[[group_var]] <- factor(df[[group_var]], levels = unique(df[[group_var]]))
    }
  }

  plots <- lapply(num_vars, function(var) {
    cols <- intersect(c(var, group_var), names(df))
    plot_data <- df[, cols, drop = FALSE]

    keep <- is.finite(plot_data[[var]])
    keep[is.na(keep)] <- FALSE
    plot_data <- plot_data[keep, , drop = FALSE]
    if (nrow(plot_data) == 0) return(NULL)

    if (!is.null(group_var)) {
      plot_data[[group_var]] <- droplevels(plot_data[[group_var]])
    }

    density_mode <- isTRUE(use_density) && length(unique(plot_data[[var]])) > 1
    base <- ggplot(plot_data, aes(x = .data[[var]]))
    y_label <- if (density_mode) "Density" else "Count"

    if (!is.null(group_var)) {
      group_levels <- levels(plot_data[[group_var]])
      palette <- resolve_palette_for_levels(group_levels, custom = custom_colors)
      if (density_mode) {
        base <- base +
          geom_density(aes(color = .data[[group_var]], fill = .data[[group_var]]), alpha = 0.3) +
          scale_color_manual(values = palette) +
          scale_fill_manual(values = palette) +
          labs(color = group_var, fill = group_var)
      } else {
        base <- base +
          geom_histogram(
            aes(fill = .data[[group_var]]),
            position = "identity",
            alpha = 0.5,
            bins = 30,
            color = "black",
            linewidth = 0.2
          ) +
          scale_fill_manual(values = palette) +
          labs(fill = group_var)
      }
    } else {
      single_color <- resolve_single_color(custom_colors)
      if (density_mode) {
        base <- base + geom_density(fill = single_color, color = single_color, alpha = 0.35)
      } else {
        base <- base +
          geom_histogram(
            fill = single_color,
            color = "black",
            bins = 30,
            linewidth = 0.2
          )
      }
    }

    base +
      ta_plot_theme(base_size = base_size) +
      labs(x = var, y = y_label) +
      scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05))) +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "#9ca3af"),
        axis.ticks = element_line(color = "#9ca3af")
      )
  })

  plots <- Filter(Negate(is.null), plots)
  if (length(plots) == 0) return(NULL)

  n_panels <- length(plots)
  defaults <- compute_default_grid(n_panels)
  layout <- basic_grid_layout(
    rows = suppressWarnings(as.numeric(nrow_input)),
    cols = suppressWarnings(as.numeric(ncol_input)),
    default_rows = defaults$rows,
    default_cols = defaults$cols
  )

  validation <- validate_grid(n_panels, layout$nrow, layout$ncol)
  combined <- if (isTRUE(validation$valid)) {
    patchwork::wrap_plots(plots, nrow = layout$nrow, ncol = layout$ncol)
  } else {
    NULL
  }

  if (!is.null(combined)) {
    combined <- apply_common_legend_layout(
      combined,
      legend_position = legend_position,
      collect_guides = isTRUE(common_legend)
    )
  }

  list(
    plot = combined,
    layout = list(nrow = layout$nrow, ncol = layout$ncol),
    panels = n_panels,
    warning = validation$message,
    defaults = defaults
  )
}
#### Error helpers ####

format_safe_error_message <- function(title, details = NULL) {
  if (is.null(title) || !nzchar(title)) {
    title <- "Error"
  }

  if (inherits(details, "condition")) {
    details <- conditionMessage(details)
  }

  if (is.null(details)) {
    details <- ""
  }

  if (is.list(details)) {
    details <- unlist(details, recursive = TRUE, use.names = FALSE)
  }

  details <- vapply(details, as.character, character(1), USE.NAMES = FALSE)
  details <- trimws(details)
  details <- details[nzchar(details)]

  if (length(details) == 0) {
    return(paste0(title, ":"))
  }

  paste0(title, ":\n", paste(details, collapse = "\n"))
}

validate_numeric_columns <- function(data, columns, context_label = "response variables") {
  if (is.null(data) || !is.data.frame(data) || length(columns) == 0) {
    return(invisible(TRUE))
  }

  missing_cols <- setdiff(columns, names(data))
  if (length(missing_cols) > 0) {
    shiny::validate(shiny::need(
      FALSE,
      sprintf(
        "The following columns are no longer available: %s.",
        paste(missing_cols, collapse = ", ")
      )
    ))
  }

  non_numeric <- columns[!vapply(columns, function(col) is.numeric(data[[col]]), logical(1))]
  if (length(non_numeric) > 0) {
    shiny::validate(shiny::need(
      FALSE,
      sprintf(
        "The selected %s must be numeric. Please check their type in the Upload tab: %s.",
        context_label,
        paste(non_numeric, collapse = ", ")
      )
    ))
  }

  invisible(TRUE)
}

#### Levels helpers ####

resolve_order_levels <- function(values) {
  if (is.null(values)) return(character())
  
  if (is.factor(values)) {
    levels(values)
  } else {
    values <- values[!is.na(values)]
    unique(as.character(values))
  }
}

#### Reactive helpers ####

resolve_reactive <- function(value, default = NULL) {
  if (is.null(value)) {
    return(default)
  }
  
  resolved <- if (is.reactive(value)) value() else value
  
  if (is.null(resolved)) default else resolved
}# ===============================================================
# ðŸ§® Linear Model (LM) â€” fixed effects only
# ===============================================================

lm_ui <- function(id) regression_ui(id, "lm", allow_multi_response = TRUE)

lm_server <- function(id, data) regression_server(id, data, "lm", allow_multi_response = TRUE)
# ===============================================================
# ðŸ§¬ Linear Mixed Model (LMM) â€” single random intercept
# ===============================================================

lmm_ui <- function(id) regression_ui(id, "lmm", allow_multi_response = TRUE)

lmm_server <- function(id, data) regression_server(id, data, "lmm", allow_multi_response = TRUE)

# ===============================================================
# ðŸ§© Helpers for LMM
# ===============================================================

compute_icc <- function(model) {
  if (!inherits(model, "merMod")) return(NA_real_)
  
  vc <- as.data.frame(VarCorr(model))
  if (nrow(vc) < 2) return(NA_real_)
  
  # residual variance is always the last row
  var_residual <- vc$vcov[nrow(vc)]
  
  # compute ICC for each random effect
  icc_list <- lapply(seq_len(nrow(vc) - 1), function(i) {
    var_random <- vc$vcov[i]
    icc_value <- var_random / (var_random + var_residual)
    data.frame(
      Group = vc$grp[i],
      ICC   = round(icc_value, 3),
      stringsAsFactors = FALSE
    )
  })
  
  icc_df <- do.call(rbind, icc_list)
  rownames(icc_df) <- NULL
  icc_df
}# ===============================================================
# ðŸ§ª Table Analyzer â€” Analysis Coordinator
# ===============================================================

analysis_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 3 â€” Analyze results"),
      p("Select an analysis type to explore your data, then inspect the summaries on the right."),
      hr(),
      
      # --- CSS: expand dropdown height for better visibility ---
      tags$style(HTML(sprintf("
        #%s + .selectize-control .selectize-dropdown,
        #%s + .selectize-control .selectize-dropdown .selectize-dropdown-content {
          max-height: none !important;
        }
      ", ns("analysis_type"), ns("analysis_type")))),
      
      # --- Analysis type selector ---
      with_help_tooltip(
        selectInput(
          ns("analysis_type"),
          "Select analysis type",
          choices = list(
            " " = "",
            "Descriptive" = c("Descriptive Statistics" = "Descriptive Statistics"),
            "Univariate" = c(
              "One-way ANOVA" = "One-way ANOVA",
              "Two-way ANOVA" = "Two-way ANOVA",
              "Linear Model (LM)" = "Linear Model (LM)",
              "Linear Mixed Model (LMM)" = "Linear Mixed Model (LMM)"
            ),
            "Multivariate" = c(
              "Pairwise Correlation" = "Pairwise Correlation",
              "Principal Component Analysis (PCA)" = "PCA"
            )
          ),
          selected = ""
        ),
        "Choose the statistical method you want to run on the filtered data."
      ),
      uiOutput(ns("config_panel"))
    ),
    
    mainPanel(
      width = 8,
      h4("Analysis results"),
      uiOutput(ns("results_panel"))
    )
  )
}


analysis_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(filtered_data())
    
    # ---- Mapping of available modules ----
    modules <- list(
      "Descriptive Statistics" = list(id = "desc",  ui = descriptive_ui, server = descriptive_server, type = "desc"),
      "One-way ANOVA"          = list(id = "anova1", ui = one_way_anova_ui, server = one_way_anova_server, type = "anova1"),
      "Two-way ANOVA"          = list(id = "anova2", ui = two_way_anova_ui, server = two_way_anova_server, type = "anova2"),
      "Linear Model (LM)"      = list(id = "lm",     ui = lm_ui, server = lm_server, type = "lm"),
      "Linear Mixed Model (LMM)" = list(id = "lmm",  ui = lmm_ui, server = lmm_server, type = "lmm"),
      "Pairwise Correlation"   = list(id = "pairs",  ui = ggpairs_ui, server = ggpairs_server, type = "pairs"),
      "PCA"                    = list(id = "pca",    ui = pca_ui, server = pca_server, type = "pca")
    )
    
    # ---- Cache for lazily created servers ----
    server_cache <- reactiveValues()
    
    # ---- Current module getter ----
    current_mod <- reactive({
      type <- input$analysis_type
      req(type)
      mod <- modules[[type]]
      req(mod)
    })
    
    # ---- Lazy server initialization ----
    normalize_analysis_type <- function(mod_type) {
      lookup <- c(
        desc = "DESCRIPTIVE",
        anova1 = "ANOVA",
        anova2 = "ANOVA",
        lm = "LM",
        lmm = "LMM",
        pairs = "CORR",
        pca = "PCA"
      )
      lookup[[mod_type]] %||% toupper(mod_type)
    }


    ensure_module_server <- function(mod) {
      key <- mod$id
      if (!is.null(server_cache[[key]])) return(server_cache[[key]])

      result <- tryCatch(mod$server(mod$id, df), error = function(e) {
        warning(sprintf("Module '%s' failed to initialize: %s", key, conditionMessage(e)))
        NULL
      })

      defaults <- list(
        analysis_type = normalize_analysis_type(mod$type),
        type = mod$type,
        data_used = NULL,
        model = NULL,
        summary = NULL,
        posthoc = NULL,
        effects = NULL,
        stats = NULL
      )

      fill_defaults <- function(val) {
        for (name in names(defaults)) {
          if (is.null(val[[name]])) val[[name]] <- defaults[[name]]
        }
        val
      }

      # --- Standardize all outputs to a reactive returning a list ---
      standardized <- reactive({
        val <- resolve_reactive(result)
        req(val)
        fill_defaults(val)
      })

      server_cache[[key]] <- standardized
      standardized
    }


    # ---- Render active submodule UI ----
    output$config_panel <- renderUI({
      mod <- current_mod()
      ui <- mod$ui(ns(mod$id))
      req(ui)
      ui$config
    })

    output$results_panel <- renderUI({
      mod <- current_mod()
      ui <- mod$ui(ns(mod$id))
      req(ui)
      ui$results
    })

    # ---- Unified model output ----
    model_out <- reactive({
      mod <- current_mod()
      srv <- ensure_module_server(mod)
      req(srv)
      srv()
    })
    
    # Return the active model output as a reactive
    model_out
  })
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Filter Module (Refactored Reactive Version)
# ===============================================================

filter_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 2 â€” Filter records"),
      p("Select the columns to focus on and adjust the filters to refine the dataset for analysis."),
      hr(),
      uiOutput(ns("column_selector")),
      uiOutput(ns("filter_widgets"))
    ),
    mainPanel(
      width = 8,
      h4("Filtered data preview"),
      DTOutput(ns("filtered_preview"))
    )
  )
}

filter_server <- function(id, uploaded_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(uploaded_data())

    column_key <- function(prefix, col) paste0(prefix, col)

    safe_range <- function(x) {
      rng <- suppressWarnings(range(x, na.rm = TRUE))
      if (any(!is.finite(rng))) rep(0, 2) else rng
    }

    numeric_step <- function(rng) {
      span <- diff(rng)
      if (span == 0 || any(!is.finite(span))) 1 else span / 100
    }

    build_numeric_widget <- function(col, x) {
      rng <- safe_range(x)
      step_val <- numeric_step(rng)
      fluidRow(
        column(
          6,
          with_help_tooltip(
            numericInput(
              ns(column_key("min_", col)), paste(col, "(min)"),
              value = rng[1], min = rng[1], max = rng[2], step = step_val
            ),
            sprintf("Enter the smallest value to keep for %s.", col)
          )
        ),
        column(
          6,
          with_help_tooltip(
            numericInput(
              ns(column_key("max_", col)), paste(col, "(max)"),
              value = rng[2], min = rng[1], max = rng[2], step = step_val
            ),
            sprintf("Enter the largest value to keep for %s.", col)
          )
        )
      )
    }

    build_logical_widget <- function(col) {
      with_help_tooltip(
        checkboxGroupInput(
          ns(column_key("filter_", col)), label = col,
          choices = c(TRUE, FALSE), selected = c(TRUE, FALSE), inline = TRUE
        ),
        sprintf("Tick the logical values you want to keep for %s.", col)
      )
    }

    build_factor_widget <- function(col, x) {
      choices <- sort(unique(as.character(x)))
      with_help_tooltip(
        selectInput(
          ns(column_key("filter_", col)), label = col,
          choices = choices, multiple = TRUE, selected = choices
        ),
        sprintf("Choose which categories should remain for %s.", col)
      )
    }

    build_widget <- function(col) {
      x <- df()[[col]]
      if (is.numeric(x)) build_numeric_widget(col, x)
      else if (is.logical(x)) build_logical_widget(col)
      else build_factor_widget(col, x)
    }

    filter_column <- function(data, col) {
      x <- data[[col]]
      if (is.numeric(x)) {
        if (all(is.na(x))) return(data)
        min_val <- input[[column_key("min_", col)]] %||% -Inf
        max_val <- input[[column_key("max_", col)]] %||% Inf
        keep <- is.na(x) | (x >= min_val & x <= max_val)
      } else {
        sel <- input[[column_key("filter_", col)]] %||% character(0)
        if (!length(sel)) return(data[0, , drop = FALSE])
        keep <- is.na(x) | (as.character(x) %in% sel)
      }
      data[keep, , drop = FALSE]
    }

    # --- 1. Column selector ---
    output$column_selector <- renderUI({
      data <- req(df())
      with_help_tooltip(
        selectInput(
          ns("columns"),
          "Select columns to filter",
          choices = names(data),
          multiple = TRUE
        ),
        "Choose which variables you want to filter before running analyses."
      )
    })

    # --- 2. Dynamic filter widgets ---
    output$filter_widgets <- renderUI({
      cols <- req(input$columns)
      tagList(lapply(cols, build_widget))
    })

    # --- 3. Reactive filtering ---
    filtered_df <- reactive({
      data <- req(df())
      cols <- input$columns
      if (!length(cols)) return(droplevels(data))
      filtered <- Reduce(filter_column, cols, init = data, right = FALSE)
      droplevels(filtered)
    })

    # --- 4. Preview table ---
    output$filtered_preview <- renderDT(
      filtered_df(),
      options = list(
        scrollX = TRUE,
        pageLength = 10,
        columnDefs = list(
          list(targets = "_all", className = "dt-nowrap")
        )
      ),
      class = "display nowrap"
    )

    # --- 5. Return filtered data downstream ---
    filtered_df
  })
}
# ===============================================================
# ðŸ  Table Analyzer â€” Home Module
# ===============================================================

home_ui <- function(id) {
  ns <- NS(id)

  fluidPage(
    div(
      class = "home-wrapper px-3",
      div(
        class = "hero text-center mx-auto",
        h1("Welcome to Table Analyzer"),
        p(
          class = "lead text-muted",
          "Turn your tabular data into publication-ready tables and plots."
        ),
        br(),
        div(
          class = "home-steps",
          fluidRow(
            class = "g-4 justify-content-center",
            column(
              width = 3,
              div(
                icon("upload", class = "fa-2x text-primary mb-2"),
                h5("1. Upload"),
                p("Bring in spreadsheets with ease.")
              )
            ),
            column(
              width = 3,
              div(
                icon("filter", class = "fa-2x text-primary mb-2"),
                h5("2. Filter"),
                p("Refine rows and columns to spotlight what's important.")
              )
            ),
            column(
              width = 3,
              div(
                icon("square-poll-horizontal", class = "fa-2x text-primary mb-2"),
                h5("3. Analyze"),
                p("Run summaries and models tailored to your dataset.")
              )
            ),
            column(
              width = 3,
              div(
                icon("chart-area", class = "fa-2x text-primary mb-2"),
                h5("4. Visualize"),
                p("Create polished plots to communicate key findings.")
              )
            )
          )
        ),
        br(),
        tags$hr(class = "my-4"),
        p(
          tagList(
            em("Developed by Nicola Palmieri"),
            br(),
            span("Version v1.00", style = "color:#6c757d; font-size:0.9em;")
          ),
          class = "text-muted small"
        )
      )
    )
  )
}


home_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    # Placeholder for future home page interactivity
  })
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Upload Module (Stable wide-format version)
# ===============================================================

upload_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 1 â€” Upload data"),
      p("Choose whether to load the example dataset or upload your own Excel file."),
      hr(),
      with_help_tooltip(
        radioButtons(
          ns("data_source"),
          label = "Data source",
          choices = c(
            "Example dataset" = "example",
            "Upload (long format)" = "long",
            "Upload (wide format)" = "wide"
          ),
          selected = "example"
        ),
        "Decide whether to explore the built-in example data or load your own table."
      ),
      uiOutput(ns("layout_example")),
      uiOutput(ns("file_input")),
      uiOutput(ns("sheet_selector")),
      uiOutput(ns("replicate_col_input")),
      uiOutput(ns("type_selectors"))
    ),
    mainPanel(
      width = 8,
      h4("Data preview"),
      verbatimTextOutput(ns("validation_msg")),
      DTOutput(ns("preview"))
    )
  )
}


upload_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactiveVal(NULL)
    editable_cols <- reactiveVal(NULL)

    render_validation <- function(text) {
      output$validation_msg <- renderText(text)
    }

    safe_call <- function(fun, ...) {
      tryCatch(list(result = fun(...), error = NULL),
               error = function(e) list(result = NULL, error = e))
    }

    process_loaded_data <- function(data, success_message = NULL,
                                    error_prefix = "Error preparing data") {
      processed <- safe_preprocess_uploaded_table(data)
      if (!is.null(processed$error)) {
        render_validation(format_safe_error_message(error_prefix, processed$error))
        return(FALSE)
      }

      data <- processed$result
      df(data)
      output$preview <- renderDT(
        data,
        options = list(
          scrollX = TRUE,
          pageLength = 10,
          columnDefs = list(
            list(targets = "_all", className = "dt-nowrap")
          )
        ),
        class = "display nowrap"
      )
      create_type_selectors(data)
      if (!is.null(success_message)) {
        render_validation(success_message)
      }
      TRUE
    }

    handle_safe_result <- function(safe_result, error_prefix, success_message = NULL,
                                   prepare_error_prefix = "Error preparing data") {
      if (!is.null(safe_result$error)) {
        render_validation(format_safe_error_message(error_prefix, safe_result$error))
        return(FALSE)
      }
      process_loaded_data(safe_result$result, success_message, prepare_error_prefix)
    }

    # -----------------------------------------------------------
    # 1ï¸âƒ£ Handle source selection
    # -----------------------------------------------------------
    observeEvent(input$data_source, {
      df(NULL)
      editable_cols(NULL)
      output$type_selectors <- renderUI(NULL)
      output$sheet_selector <- renderUI(NULL)
      output$preview <- renderDT(data.frame())

      if (input$data_source == "example") {
        path <- "data/Data at necropsy_all groups_all days_Table Analyzer.xlsx"
        validate(need(file.exists(path), "âš ï¸ Example dataset not found in data folder."))
        safe_result <- safe_call(readxl::read_excel, path)
        if (!handle_safe_result(
          safe_result,
          "Error preparing example dataset",
          "ðŸ“‚ Loaded built-in example dataset.",
          "Error preparing example dataset"
        )) {
          return()
        }
      } else {
        render_validation("Please upload an Excel file.")
      }
    }, ignoreInit = FALSE)

    output$file_input <- renderUI({
      req(input$data_source)
      if (input$data_source == "example") {
        return(NULL)
      }

      with_help_tooltip(
        fileInput(
          ns("file"),
          "Upload Excel file (.xlsx / .xls / .xlsm)",
          accept = c(".xlsx", ".xls", ".xlsm")
        ),
        "Provide the Excel workbook that stores your study measurements."
      )
    })

    output$replicate_col_input <- renderUI({
      req(input$data_source)
      if (input$data_source != "wide") {
        return(NULL)
      }

      with_help_tooltip(
        tagList(
          textInput(
            ns("replicate_col"),
            label = "Replicate column name",
            value = "Replicate",
            placeholder = "Replicate"
          )
        ),
        "Choose the column name that will store the second header row when wide data is reshaped."
      )
    })
    
    # -----------------------------------------------------------
    # 2ï¸âƒ£ Example layout preview
    # -----------------------------------------------------------
    output$layout_example <- renderUI({
      req(input$data_source %in% c("long", "wide"))
      long_path <- "data/toy_animal_trial_data_long.xlsx"
      wide_path <- "data/toy_animal_trial_data_wide.xlsx"
      validate(need(file.exists(long_path) && file.exists(wide_path),
                    "âŒ Example layout files not found in /data folder."))
      
      loader <- if (input$data_source == "long") {
        list(path = long_path, caption = "Long format â€” one row per measurement.")
      } else {
        list(
          path = wide_path,
          caption = "Wide format â€” two header rows (top: response, bottom: replicate).",
          fix_names = TRUE
        )
      }

      toy_result <- safe_call(readxl::read_excel, loader$path, n_max = 5)
      validate(need(
        is.null(toy_result$error),
        format_safe_error_message("Error loading example layout", toy_result$error)
      ))

      toy <- toy_result$result
      if (isTRUE(loader$fix_names)) {
        bad <- grepl("^\\.\\.\\.[0-9]+$", names(toy))
        names(toy)[bad] <- ""
      }
      caption <- loader$caption
      
      DT::datatable(
        toy,
        caption = htmltools::tags$caption(htmltools::tags$b(caption)),
        options = list(dom = "t", scrollX = TRUE),
        rownames = FALSE,
        class = "compact stripe"
      )
    })
    
    # -----------------------------------------------------------
    # 3ï¸âƒ£ File upload â†’ detect sheets
    # -----------------------------------------------------------
    observeEvent(input$file, {
      req(input$data_source != "example")
      ext <- tolower(tools::file_ext(input$file$name))
      validate(need(ext %in% c("xlsx", "xls", "xlsm"),
                    "âŒ Invalid file type. Please upload .xlsx/.xls/.xlsm."))
      
      sheets_result <- safe_call(readxl::excel_sheets, input$file$datapath)
      validate(need(is.null(sheets_result$error), "âŒ No readable sheets found in workbook."))

      sheets <- sheets_result$result

      render_validation(paste("âœ… File loaded:", input$file$name))
      output$sheet_selector <- renderUI(
        with_help_tooltip(
          selectInput(ns("sheet"), "Select sheet", choices = sheets),
          "Pick the worksheet inside your Excel file that contains the data."
        )
      )
    }, ignoreInit = TRUE)
    
    # -----------------------------------------------------------
    # 4ï¸âƒ£ Load selected sheet (handles both long & wide)
    # -----------------------------------------------------------
    reprocess_wide_upload <- function() {
      req(input$file, input$sheet)

      replicate_col <- input$replicate_col
      if (is.null(replicate_col) || !nzchar(trimws(replicate_col))) {
        replicate_col <- "Replicate"
      } else {
        replicate_col <- trimws(replicate_col)
      }

      safe_result <- safe_convert_wide_to_long(
        input$file$datapath,
        sheet = input$sheet,
        replicate_col = replicate_col
      )

      handle_safe_result(
        safe_result,
        "Error converting wide format",
        "âœ… Wide format reshaped successfully."
      )
    }

    observeEvent(list(input$sheet, input$data_source), {
      req(input$file, input$sheet, input$data_source != "example")
      path <- input$file$datapath

      if (input$data_source == "wide") {
        reprocess_wide_upload()
        return()
      }

      long_result <- safe_call(readxl::read_excel, path, sheet = input$sheet)
      if (!handle_safe_result(
        long_result,
        "âŒ Error loading sheet",
        "âœ… Long format loaded successfully."
      )) {
        return()
      }
    })

    observeEvent(input$replicate_col, {
      req(input$file, input$sheet, input$data_source == "wide")
      reprocess_wide_upload()
    }, ignoreInit = TRUE)
    
    # -----------------------------------------------------------
    # 5ï¸âƒ£ Create type selectors
    # -----------------------------------------------------------
    create_type_selectors <- function(data) {
      req(data)
      num_vars <- names(data)[vapply(data, is.numeric, logical(1))]
      few_level_nums <- Filter(
        function(col) length(unique(stats::na.omit(data[[col]]))) <= 10,
        num_vars
      )

      if (length(few_level_nums) == 0) {
        editable_cols(NULL)
        output$type_selectors <- renderUI(NULL)
        return()
      }

      editable_cols(few_level_nums)
      output$type_selectors <- renderUI({
        tagList(
          h5("Ambiguous type columns"),
          lapply(few_level_nums, function(col) {
            with_help_tooltip(
              selectInput(
                ns(paste0("type_", col)),
                label = col,
                choices = c("Numeric", "Categorical"),
                selected = "Numeric",
                width = "100%"
              ),
              "Tell the app whether this column should be treated as numbers or as groups."
            )
          })
        )
      })
    }
    
    # -----------------------------------------------------------
    # 6ï¸âƒ£ Apply user type edits reactively
    # -----------------------------------------------------------
    observe({
      data <- df()
      cols <- editable_cols()
      req(data, cols)
      for (col in cols) {
        sel <- input[[paste0("type_", col)]] %||% "Numeric"
        if (sel == "Categorical") {
          data[[col]] <- auto_factor_order(as.character(data[[col]]))
        } else {
          data[[col]] <- suppressWarnings(as.numeric(as.character(data[[col]])))
        }
      }
      df(data)
    })
    
    # -----------------------------------------------------------
    # âœ… Return reactive data
    # -----------------------------------------------------------
    df
  })
}
# Clean names + convert characters to ordered factors
preprocess_uploaded_table <- function(df) {
  df |> mutate(across(where(is.character) | where(is.factor), auto_factor_order))
}

# Convert character/factor to factor with numeric-aware order
auto_factor_order <- function(x) {
  if (!is.factor(x) && !is.character(x)) return(x)

  ordered_levels <- stringr::str_sort(
    if (is.factor(x)) levels(x) else unique(x),
    numeric = TRUE,
    na_last = TRUE
  )

  factor(x, levels = ordered_levels, ordered = is.ordered(x))
}


convert_wide_to_long <- function(path, sheet = 1, replicate_col = "Replicate") {
  headers <- readxl::read_excel(path, sheet = sheet, n_max = 2, col_names = FALSE)
  header1 <- as.character(unlist(headers[1, , drop = TRUE]))
  header2 <- as.character(unlist(headers[2, , drop = TRUE]))
  
  if (all(header1 == "" | is.na(header1))) {
    header1 <- header2
    header2 <- rep("", length(header1))
  }
  
  header1[header1 == ""] <- NA
  header1 <- zoo::na.locf(header1, na.rm = FALSE)
  
  header2[is.na(header2) | header2 == ""] <- ""
  
  if (all(header2 == "")) {
    header2 <- ifelse(grepl("_", header1), sub(".*_", "", header1), "")
  }
  
  clean_names <- ifelse(header2 == "", header1, paste0(header1, "_", header2))
  clean_names <- make.unique(clean_names, sep = "_")
  
  fixed_cols   <- clean_names[header2 == ""]
  measure_cols <- clean_names[header2 != ""]
  
  data <- readxl::read_excel(path, sheet = sheet, skip = 2, col_names = clean_names)
  
  data_long <- data |>
    tidyr::pivot_longer(
      cols = tidyselect::all_of(measure_cols),
      names_to   = c("Variable", replicate_col),
      names_pattern = "^(.*)_([^_]*)$",
      values_to  = "Value"
    )
  
  id_cols <- c(fixed_cols, replicate_col, "Variable")
  
  duplicates <- data_long |>
    dplyr::group_by(dplyr::across(dplyr::all_of(id_cols))) |>
    dplyr::summarise(.n = dplyr::n(), .groups = "drop") |>
    dplyr::filter(.n > 1)
  
  if (nrow(duplicates) > 0) {
    ex <- duplicates[1, , drop = FALSE]
    stop(
      sprintf(
        "Duplicate measurements detected for variable '%s' and replicate '%s'. Ensure header labels are unique before uploading.",
        as.character(ex$Variable),
        as.character(ex[[replicate_col]])
      ),
      call. = FALSE
    )
  }
  
  data_long |>
    tidyr::pivot_wider(
      names_from  = "Variable",
      values_from = "Value"
    ) |>
    tibble::as_tibble()
}




safe_convert_wide_to_long <- purrr::safely(convert_wide_to_long)

safe_preprocess_uploaded_table <- purrr::safely(preprocess_uploaded_table)
# ===============================================================
# ðŸ§© Visualization Coordinator (Lazy + Reactive)
# ===============================================================

visualize_ui <- function(id) {
  ns <- NS(id)
  uiOutput(ns("dynamic_ui"))
}

visualize_server <- function(id, filtered_data, model_fit) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    empty_state <- function(icon, title, message) {
      div(
        class = "empty-state card bg-light border-0 shadow-sm text-center my-5",
        div(
          class = "card-body py-5 px-4",
          div(class = "empty-state-icon text-primary mb-3", HTML(icon)),
          h4(class = "mb-2", title),
          p(class = "text-muted mb-0", message)
        )
      )
    }

    model_info_or_null <- reactive({
      tryCatch(
        model_fit(),
        shiny.silent.stop = function(e) NULL
      )
    })

    model_info <- reactive({
      info <- model_info_or_null()
      req(info)
      info
    })

    analysis_type <- reactive({
      info <- model_info()
      type <- info$type %||% "oneway_anova"
      tolower(type)
    })

    vis_cache <- reactiveValues()

    ensure_vis_server <- function(key, create_fn) {
      if (is.null(vis_cache[[key]])) {
        vis_cache[[key]] <- create_fn()
      }
      vis_cache[[key]]
    }

    visualization_specs <- list(
      oneway_anova = list(
        id = "oneway",
        ui = function(ns) visualize_oneway_ui(ns("oneway")),
        server = function() visualize_oneway_server("oneway", filtered_data, model_info)
      ),
      twoway_anova = list(
        id = "twoway",
        ui = function(ns) visualize_twoway_ui(ns("twoway")),
        server = function() visualize_twoway_server("twoway", filtered_data, model_info)
      ),
      pairs = list(
        id = "ggpairs",
        ui = function(ns) visualize_ggpairs_ui(ns("ggpairs")),
        server = function() visualize_ggpairs_server("ggpairs", filtered_data, model_info)
      ),
      pca = list(
        id = "pca",
        ui = function(ns) visualize_pca_ui(ns("pca"), filtered_data()),
        server = function() visualize_pca_server("pca", filtered_data, model_info)
      ),
      descriptive = list(
        id = "descriptive",
        ui = function(ns) visualize_descriptive_ui(ns("descriptive")),
        server = function() visualize_descriptive_server("descriptive", filtered_data, model_info)
      )
    )

    output$dynamic_ui <- renderUI({
      info <- model_info_or_null()
      if (is.null(info)) {
        return(empty_state(
          "&#128221;",
          "No analysis selected yet",
          "Run an analysis in the Analyze tab to unlock tailored visualizations for your results."
        ))
      }

      type <- analysis_type()
      spec <- visualization_specs[[type]]
      if (!is.null(spec)) {
        return(spec$ui(ns))
      }

      empty_state(
        "&#128065;",
        "Visualization coming soon",
        "We're still crafting charts for this analysis type. In the meantime, explore the other visualizations available!"
      )
    })

    observeEvent(analysis_type(), {
      type <- analysis_type()
      spec <- visualization_specs[[type]]
      if (!is.null(spec)) {
        ensure_vis_server(spec$id, spec$server)
      }
    }, ignoreInit = FALSE)
  })
}
# ===============================================================
# ðŸ§ª Table  Analyzer â€” Pairwise Correlation Module
# ===============================================================

ggpairs_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("vars_ui")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show correlation matrix", width = "100%"),
          "Calculate the correlation coefficients for the selected variables."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_model"), "Download all results", style = "width: 100%;"),
          "Export the correlation matrices and any messages to a text file."
        ))
      )
    ),
    results = tagList(
      h5("Correlation matrix"),
      verbatimTextOutput(ns("summary"))
    )
  )
}

ggpairs_server <- function(id, data_reactive) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(data_reactive())

    strat_info <- stratification_server("strat", df)

    # ---- Build variable selector (handles re-rendering) ----
    output$vars_ui <- renderUI({
      data <- req(df())
      num_vars <- names(data)[vapply(data, is.numeric, logical(1))]

      with_help_tooltip(
        selectInput(ns("vars"), "Numeric variables", choices = num_vars, selected = num_vars, multiple = TRUE),
        "Choose which numeric columns to include in the correlation matrix."
      )
    })

    build_ggpairs_object <- function(data) {
      GGally::ggpairs(
        data,
        progress = FALSE,
        upper = list(
          continuous = GGally::wrap("cor", size = 4, color = basic_color_palette[1])
        ),
        lower = list(
          continuous = GGally::wrap("points", alpha = 0.6, color = basic_color_palette[1], size = 1.5)
        ),
        diag = list(
          continuous = GGally::wrap("densityDiag", fill = basic_color_palette[1], alpha = 0.4)
        )
      ) +
        ta_plot_theme(base_size = 11) +
        ggplot2::theme(
          strip.text = ggplot2::element_text(size = 9),
          panel.grid.major.x = ggplot2::element_blank(),
          panel.grid.major.y = ggplot2::element_blank(),
          axis.line = ggplot2::element_line(color = "#9ca3af"),
          axis.ticks = ggplot2::element_line(color = "#9ca3af")
        )
    }

    correlation_store <- reactiveVal(NULL)

    # ---- Compute correlation matrix ----
    observeEvent(input$run, {
      data <- req(df())
      numeric_vars <- names(data)[vapply(data, is.numeric, logical(1))]
      selected_vars <- if (length(input$vars)) input$vars else numeric_vars
      selected_vars <- intersect(selected_vars, numeric_vars)

      if (length(selected_vars) < 2) {
        correlation_store(list(
          message = "Need at least two numeric columns.",
          matrices = list(),
          plots = list(),
          group_var = NULL,
          selected_vars = selected_vars,
          data_used = NULL,
          strata_levels = NULL
        ))
        return()
      }

      strat_details <- strat_info()
      group_var <- strat_details$var

      if (!is.null(group_var) && !group_var %in% names(data)) {
        group_var <- NULL
      }

      if (is.null(group_var)) {
        strata_levels <- "Overall"
      } else {
        levels <- strat_details$levels
        if (is.null(levels) || !length(levels)) {
          values <- data[[group_var]]
          values <- values[!is.na(values)]
          strata_levels <- unique(as.character(values))
        } else {
          strata_levels <- levels
        }
      }

      processed_data <- data[, unique(c(selected_vars, group_var)), drop = FALSE]

      if (!is.null(group_var)) {
        keep_rows <- !is.na(processed_data[[group_var]]) &
          as.character(processed_data[[group_var]]) %in% strata_levels
        processed_data <- processed_data[keep_rows, , drop = FALSE]
        processed_data[[group_var]] <- factor(
          as.character(processed_data[[group_var]]),
          levels = strata_levels
        )
      }

      if (is.null(group_var)) {
        dat <- processed_data[, selected_vars, drop = FALSE]
        matrices <- list(Overall = cor(dat, use = "pairwise.complete.obs"))
        plots <- list(Overall = build_ggpairs_object(dat))
      } else {
        split_data <- lapply(strata_levels, function(level) {
          dat <- processed_data[processed_data[[group_var]] == level, selected_vars, drop = FALSE]
          if (nrow(dat) == 0) return(NULL)
          dat
        })
        names(split_data) <- strata_levels

        matrices <- lapply(split_data, function(dat) {
          if (is.null(dat)) return(NULL)
          suppressWarnings(cor(dat, use = "pairwise.complete.obs"))
        })

        plots <- lapply(split_data, function(dat) {
          if (is.null(dat)) return(NULL)
          build_ggpairs_object(dat)
        })
      }

      correlation_store(list(
        matrices = matrices,
        plots = plots,
        group_var = group_var,
        selected_vars = selected_vars,
        data_used = processed_data,
        strata_levels = if (!is.null(group_var)) strata_levels else NULL
      ))
    })

    output$summary <- renderPrint({
      results <- correlation_store()
      if (is.null(results)) {
        return(invisible(NULL))
      }

      if (!is.null(results$message)) {
        cat(results$message)
        return(invisible(NULL))
      }

      matrices <- results$matrices
      if (is.null(matrices) || length(matrices) == 0) {
        return(invisible(NULL))
      }

      multiple <- length(matrices) > 1
      for (name in names(matrices)) {
        mat <- matrices[[name]]
        if (multiple) {
          cat(sprintf("=== Stratum: %s ===\n", name))
        }
        if (is.null(mat)) {
          cat("  No data available for this stratum.\n\n")
        } else {
          print(round(mat, 2))
          cat("\n")
        }
      }
    })
    
    # ---- Download results ----
    output$download_model <- downloadHandler(
      filename = function() paste0("Correlation_results_", Sys.Date(), ".txt"),
      content = function(file) {
        res <- correlation_store()
        if (is.null(res)) return()
        sink(file)
        on.exit(sink(), add = TRUE)
        
        if (!is.null(res$message)) {
          cat(res$message, "\n")
          return()
        }
        
        matrices <- res$matrices
        if (is.null(matrices) || length(matrices) == 0) {
          cat("No correlation matrices available.\n")
          return()
        }
        
        multiple <- length(matrices) > 1
        for (nm in names(matrices)) {
          mat <- matrices[[nm]]
          if (multiple) cat(sprintf("=== Stratum: %s ===\n", nm))
          if (is.null(mat)) {
            cat("No data available for this stratum.\n\n")
          } else {
            print(round(mat, 3))
            cat("\n")
          }
        }

      }
    )

    # ---- Return structured output for visualization ----
    df_final <- reactive({
      res <- correlation_store()
      req(res)
      res$data_used
    })

    model_fit <- reactive({
      res <- correlation_store()
      req(res)
      res$matrices
    })

    summary_table <- model_fit

    posthoc_results <- reactive(NULL)

    effect_table <- reactive(NULL)

    reactive({
      res <- correlation_store()
      if (is.null(res)) return(NULL)

      data_used <- df_final()

      list(
        analysis_type = "CORR",
        type = "pairs",
        data_used = data_used,
        model = model_fit(),
        summary = summary_table(),
        posthoc = posthoc_results(),
        effects = effect_table(),
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        selected_vars = res$selected_vars,
        group_var = res$group_var,
        strata_levels = res$strata_levels,
        plots = res$plots,
        message = res$message,
        group_var_reactive = reactive({
          res <- correlation_store()
          req(res)
          res$group_var
        }),
        strata_order = reactive({
          res <- correlation_store()
          req(res)
          res$strata_levels
        }),
        results = reactive(correlation_store())
      )
    })
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” Pairwise Correlation (Dispatcher)
# ===============================================================

visualize_ggpairs_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize pairwise correlation"),
      p("Visualize pairwise relationships and correlation coefficients among numeric variables."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c("Pairwise scatterplot matrix" = "GGPairs"),
          selected = "GGPairs"
        ),
        "Choose how to visualise the pairwise relationships between variables."
      ),
      uiOutput(ns("sub_controls")),
      br(),
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, downloadButton(ns("download_plot"), "Download Plot", style = "width: 100%;"))
      )
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}


visualize_ggpairs_server <- function(id, filtered_data, model_fit) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    correlation_info <- reactive({
      info <- model_fit()
      if (is.null(info) || is.null(info$type) || info$type != "pairs") {
        return(NULL)
      }
      info
    })

    output$sub_controls <- renderUI({
      info <- correlation_info()
      if (is.null(info)) {
        helpText("Run the pairwise correlation analysis to configure plots.")
      } else if (identical(input$plot_type, "GGPairs")) {
        pairwise_correlation_visualize_ggpairs_ui(ns("ggpairs"))
      }
    })

    ggpairs_state <- pairwise_correlation_visualize_ggpairs_server(
      "ggpairs",
      filtered_data,
      correlation_info,
      apply_trigger = reactive(input$apply_plot)
    )

    output$plot_warning <- renderUI({
      warning_text <- ggpairs_state$warning()
      if (!is.null(warning_text)) {
        div(class = "alert alert-warning", HTML(warning_text))
      }
    })

    output$plot <- renderPlot({
      plot_obj <- ggpairs_state$plot()
      validate(need(!is.null(plot_obj), "No plot available."))
      print(plot_obj)
    },
    width = function() ggpairs_state$width(),
    height = function() ggpairs_state$height(),
    res = 96)

    output$download_plot <- downloadHandler(
      filename = function() paste0("pairwise_correlation_ggpairs_", Sys.Date(), ".png"),
      content = function(file) {
        p <- ggpairs_state$plot()
        dims <- ggpairs_state$dimensions()
        validate(need(!is.null(p), "No plot"))
        validate(need(!is.null(dims), "No layout"))
        ggplot2::ggsave(
          file, p, dpi = 300,
          width = dims$width / 96,
          height = dims$height / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}
# ===============================================================
# ðŸ§ª Pairwise Correlation â€” GGPairs Visualization Module
# ===============================================================

pairwise_correlation_visualize_ggpairs_ui <- function(id) {
  ns <- NS(id)
  tagList(
    subplot_size_ui(
      ns,
      width_value = 800,
      height_value = 600,
      width_help = "Set the width in pixels for each panel of the correlation matrix.",
      height_help = "Set the height in pixels for each panel of the correlation matrix."
    ),
    plot_grid_ui(
      id = ns("plot_grid"),
      rows_help = "Choose how many rows of panels to use when multiple strata are plotted.",
      cols_help = "Choose how many columns of panels to use when multiple strata are plotted."
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, base_size_ui(
        ns,
        default = 11,
        help_text = "Adjust the base font size used for the correlation plot."
      ))
    )
  )
}


pairwise_correlation_visualize_ggpairs_server <- function(
    id, filtered_data, correlation_info, apply_trigger = reactive(NULL)
) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    # ---- Helpers -------------------------------------------------------------
    sanitize <- function(x, default) {
      v <- suppressWarnings(as.numeric(x))
      if (is.na(v) || length(v) == 0) default else v
    }
    
    # ---- Reactives -----------------------------------------------------------
    df <- reactive(filtered_data())
    
    group_var <- reactive({
      info <- correlation_info()
      g <- resolve_reactive(info$group_var)
      if (is.null(info) || is.null(g) || g == "" || g == "None") return(NULL)
      dat <- df()
      if (!is.data.frame(dat) || !g %in% names(dat)) return(NULL)
      g
    })
    
    strata_order <- reactive({
      info <- correlation_info()
      so <- resolve_reactive(info$strata_order)
      if (is.null(so)) return(NULL)
      so <- as.character(so)
      so[nzchar(so)]
    })
    
    custom_colors <- add_color_customization_server(
      ns,
      input, output,
      data = df,
      color_var_reactive = group_var,
      multi_group = TRUE,
      level_order_reactive = strata_order
    )
    
    grid <- plot_grid_server("plot_grid")
    base_size <- base_size_server(input = input, default = 11)
    
    # ---- Unified state() -----------------------------------------------------
    state <- reactive({
      list(
        data      = df(),
        info      = correlation_info(),
        group_var = group_var(),
        strata_order = strata_order(),
        colors    = custom_colors(),
        base_size = base_size(),
        plot_w    = sanitize(input$plot_width, 800),
        plot_h    = sanitize(input$plot_height, 600),
        rows      = grid$rows(),
        cols      = grid$cols()
      )
    })
    
    # ---- Build one ggpairs plot ---------------------------------------------
    build_ggpairs_plot <- function(data, color, title = NULL, base_size) {
      numeric_cols <- data[, vapply(data, is.numeric, logical(1)), drop = FALSE]
      numeric_cols <- numeric_cols[, colSums(!is.na(numeric_cols)) > 0, drop = FALSE]
      validate(need(ncol(numeric_cols) >= 2, "Need â‰¥2 numeric columns."))
      
      p <- GGally::ggpairs(
        numeric_cols,
        progress = FALSE,
        upper = list(continuous = GGally::wrap("cor", size = 4, colour = color)),
        lower = list(continuous = GGally::wrap("points", alpha = 0.6, colour = color, size = 1.5)),
        diag  = list(continuous = GGally::wrap("densityDiag", fill = color, alpha = 0.4))
      ) +
        ta_plot_theme(base_size = base_size) +
        ggplot2::theme(
          strip.text = ggplot2::element_text(size = 9),
          panel.grid.major = ggplot2::element_blank(),
          panel.grid.minor = ggplot2::element_blank(),
          axis.line = ggplot2::element_line(color = "#9ca3af"),
          axis.ticks = ggplot2::element_line(color = "#9ca3af"),
          plot.margin = ggplot2::margin(t = 10, r = 14, b = 10, l = 24, unit = "pt")
        )

      if (!is.null(title)) p <- p + ggplot2::labs(title = title)

      # wrap ggmatrix into a real ggplot object
      gtable <- GGally::ggmatrix_gtable(p)
      ggplot2::ggplot() +
        ta_plot_theme_void() +
        ggplot2::annotation_custom(
          grob = gtable,
          xmin = -Inf, xmax = Inf,
          ymin = -Inf, ymax = Inf
        )
    }
    
    # ---- Unified compute plot_info() -----------------------------------------
    plot_info <- eventReactive(apply_trigger(), {
      req(isTRUE(apply_trigger() > 0))
      s <- state()
      dat <- s$data
      info <- s$info

      validate(need(!is.null(dat) && nrow(dat) > 0, "No data available."))
      validate(need(!is.null(info), "Correlation info missing."))
      
      results <- resolve_reactive(info$results)
      validate(need(!is.null(results), "Run the correlation analysis."))
      
      selected <- resolve_reactive(results$selected_vars)
      if (is.null(selected) || length(selected) < 2)
        selected <- names(dat)[vapply(dat, is.numeric, logical(1))]
      
      validate(need(length(selected) >= 2, "Need â‰¥2 numeric variables."))
      
      gvar <- s$group_var
      
      # --- No strata â†’ single big plot ---------------------------------------
      if (is.null(gvar)) {
        pd <- dat[, selected, drop = FALSE]
        col <- resolve_single_color(s$colors)
        plot <- build_ggpairs_plot(pd, col, title = NULL, base_size = s$base_size)
        defaults <- compute_default_grid(1L)
        return(list(
          plot = plot,
          layout = list(rows = defaults$rows, cols = defaults$cols),
          panels = 1L,
          warning = NULL,
          defaults = defaults,
          plot_w = s$plot_w,
          plot_h = s$plot_h
        ))
      }
      
      # --- Strata case --------------------------------------------------------
      lvls <- names(results$matrices)
      if (!length(lvls)) lvls <- unique(as.character(dat[[gvar]]))
      if (length(s$strata_order)) lvls <- s$strata_order[s$strata_order %in% lvls]
      lvls <- lvls[nzchar(lvls)]
      validate(need(length(lvls) > 0, "No valid strata levels."))
      
      palette <- resolve_palette_for_levels(lvls, custom = s$colors)
      
      plot_list <- lapply(lvls, function(lvl) {
        rows <- as.character(dat[[gvar]]) == lvl
        sub <- dat[rows, selected, drop = FALSE]
        if (!nrow(sub)) return(NULL)
        build_ggpairs_plot(sub, palette[[lvl]], title = lvl, base_size = s$base_size)
      })
      
      plot_list <- Filter(Negate(is.null), plot_list)
      validate(need(length(plot_list) > 0, "No data for strata."))
      
      n_panels <- length(plot_list)
      defaults <- compute_default_grid(n_panels)
      
      layout <- basic_grid_layout(
        rows = s$rows,
        cols = s$cols,
        default_rows = defaults$rows,
        default_cols = defaults$cols
      )
      val <- validate_grid(n_panels, layout$nrow, layout$ncol)
      
      combined <- NULL
      if (isTRUE(val$valid)) {
        combined <- patchwork::wrap_plots(plot_list,
                                          nrow = layout$nrow,
                                          ncol = layout$ncol
        )
      }

      list(
        plot = combined,
        layout = list(rows = layout$nrow, cols = layout$ncol),
        panels = n_panels,
        warning = val$message,
        defaults = defaults,
        plot_w = s$plot_w,
        plot_h = s$plot_h
      )
    }, ignoreNULL = TRUE, ignoreInit = TRUE)

    observeEvent(plot_info(), {
      info <- plot_info()
      apply_grid_defaults_if_empty(input, session, "plot_grid", info$defaults, n_items = info$panels)
    }, ignoreNULL = TRUE)

    # ---- Unified sizing -------------------------------------------------------
    plot_dimensions <- reactive({
      info <- plot_info()
      if (is.null(info)) {
        return(list(width = 800, height = 600))
      }

      lay <- info$layout
      plot_w <- info$plot_w %||% 800
      plot_h <- info$plot_h %||% 600

      list(
        width  = max(200, plot_w * (lay$cols %||% 1)),
        height = max(200, plot_h * (lay$rows %||% 1))
      )
    })

    # ---- Outputs --------------------------------------------------------------
    output$plot <- renderPlot({
      info <- plot_info()
      if (is.null(info) || !is.null(info$warning)) return(NULL)
      p <- info$plot
      validate(need(!is.null(p), "Plot not ready"))
      print(p)
    },
    width  = function() plot_dimensions()$width,
    height = function() plot_dimensions()$height,
    res = 96)

    outputOptions(output, "plot", suspendWhenHidden = TRUE)

    list(
      warning = reactive({
        info <- plot_info()
        if (is.null(info)) NULL else info$warning
      }),
      plot = reactive({
        info <- plot_info()
        if (is.null(info) || !is.null(info$warning)) return(NULL)
        info$plot
      }),
      width = reactive(plot_dimensions()$width),
      height = reactive(plot_dimensions()$height),
      dimensions = reactive(plot_dimensions())
    )
  })
}

# ===============================================================
# ðŸ§ª Table Analyzer â€” PCA Module
# ===============================================================

pca_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("vars_ui")),
      tags$details(
        tags$summary(strong("Advanced options")),
        helpText(paste(
          "Stratify by is not available for PCA because the principal components are computed on the full numeric matrix.",
          "Splitting the data by groups would produce different coordinate systems, making the loadings and scores incomparable across groups."
        ))
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run_pca"), "Show PCA summary", width = "100%"),
          "Compute the principal components for the selected variables."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
          "Export the PCA summaries, loadings, and diagnostics to a text file."
        ))
      )
    ),
    results = tagList(
      h5("PCA summary and loadings"),
      verbatimTextOutput(ns("summary")),
      uiOutput(ns("excluded_rows_section"))
    )
  )
}

pca_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(filtered_data())

    # Dynamically populate numeric variable list (re-rendered with UI)
    output$vars_ui <- renderUI({
      data <- req(df())
      num_vars <- names(data)[vapply(data, is.numeric, logical(1))]

      with_help_tooltip(
        selectInput(ns("vars"), "Numeric variables", choices = num_vars, selected = num_vars, multiple = TRUE),
        "Pick the numeric variables whose combined patterns you want PCA to capture."
      )
    })

    `%||%` <- function(x, y) if (is.null(x)) y else x

    format_usage_line <- function(entry) {
      sprintf(
        "Rows used for PCA: %d of %d (excluded %d due to missing values in the selected variables).\n\n",
        entry$used_n %||% 0,
        entry$original_n %||% 0,
        entry$excluded_n %||% 0
      )
    }

    append_row_numbers <- function(rows, keep) {
      if (!any(!keep)) {
        return(NULL)
      }

      excluded_rows <- rows[!keep, , drop = FALSE]
      out <- cbind(
        data.frame(`Row #` = seq_len(nrow(rows))[!keep], check.names = FALSE),
        excluded_rows
      )
      rownames(out) <- NULL
      out
    }

    run_pca_on_subset <- function(subset_data, selected_vars) {
      if (is.null(subset_data) || nrow(subset_data) == 0) {
        return(list(model = NULL, data = subset_data, message = "No data available for PCA."))
      }

      numeric_subset <- subset_data[, selected_vars, drop = FALSE]
      complete_idx <- stats::complete.cases(numeric_subset)
      numeric_subset <- numeric_subset[complete_idx, , drop = FALSE]
      plot_data <- subset_data[complete_idx, , drop = FALSE]

      details <- list(
        original_n = nrow(subset_data),
        used_n = nrow(plot_data)
      )
      details$excluded_n <- details$original_n - details$used_n
      details$excluded_rows <- append_row_numbers(subset_data, complete_idx)

      if (nrow(numeric_subset) < 2) {
        return(c(
          list(
            model = NULL,
            data = plot_data,
            message = "Not enough complete observations to compute PCA."
          ),
          details
        ))
      }

      model <- purrr::safely(prcomp)(numeric_subset, center = TRUE, scale. = TRUE)

      if (!is.null(model$error)) {
        return(c(
          list(
            model = NULL,
            data = plot_data,
            message = conditionMessage(model$error),
            message_title = "PCA computation failed"
          ),
          details
        ))
      }

      c(
        list(
          model = model$result,
          data = plot_data,
          message = NULL
        ),
        details
      )
    }

    # Run PCA
    pca_result <- eventReactive(input$run_pca, {
      req(df())

      data <- df()
      validate(need(nrow(data) > 0, "No data available for PCA."))

      numeric_vars <- names(data)[vapply(data, is.numeric, logical(1))]
      selected_vars <- intersect(input$vars, numeric_vars)
      validate(need(length(selected_vars) > 1, "Select at least two numeric variables for PCA."))

      result <- run_pca_on_subset(data, selected_vars)

      list(
        selected_vars = selected_vars,
        result = result,
        data_used = result$data
      )
    })

    # Verbatim output: summary + loadings
    output$summary <- renderPrint({
      results <- pca_result()
      validate(need(!is.null(results), "Run the PCA analysis to view results."))

      entry <- results$result
      if (is.null(entry) || is.null(entry$model)) {
        if (!is.null(entry)) cat(format_usage_line(entry))

        if (!is.null(entry) && !is.null(entry$message) && nzchar(entry$message)) {
          if (!is.null(entry$message_title)) {
            cat(format_safe_error_message(entry$message_title, entry$message))
          } else {
            cat(entry$message)
          }
        } else {
          cat("Not enough data to compute PCA.")
        }
        return(invisible())
      }

      model <- entry$model
      cat(format_usage_line(entry))
      cat("â”€â”€ PCA Summary â”€â”€\n")
      print(summary(model))
      cat("\nâ”€â”€ PCA Loadings (rotation matrix) â”€â”€\n")
      print(round(model$rotation, 3))
      cat("\nâ”€â”€ PCA Explained Variance (%) â”€â”€\n")
      var_exp <- 100 * model$sdev^2 / sum(model$sdev^2)
      print(round(var_exp, 2))
      cat("\n")

      invisible()
    })

    # Download combined results
    output$download_all <- downloadHandler(
      filename = function() paste0("PCA_results_", Sys.Date(), ".txt"),
      content = function(file) {
        results <- pca_result()
        req(results)

        sink(file)
        on.exit(sink(), add = TRUE)

        entry <- results$result
        if (!is.null(entry)) cat(format_usage_line(entry))

        if (is.null(entry) || is.null(entry$model)) {
          if (!is.null(entry) && !is.null(entry$message) && nzchar(entry$message)) {
            msg <- if (!is.null(entry$message_title)) {
              format_safe_error_message(entry$message_title, entry$message)
            } else {
              entry$message
            }
            cat(msg, "\n", sep = "")
          } else {
            cat("Not enough data to compute PCA.\n")
          }
          return()
        }

        model <- entry$model
        cat("â”€â”€ PCA Summary â”€â”€\n")
        print(summary(model))
        cat("\nâ”€â”€ PCA Loadings (rotation matrix) â”€â”€\n")
        print(round(model$rotation, 3))
        cat("\nâ”€â”€ PCA Explained Variance (%) â”€â”€\n")
        var_exp <- 100 * model$sdev^2 / sum(model$sdev^2)
        print(round(var_exp, 2))
        cat("\n")
      }
    )

    analysis_result <- reactive({
      details <- pca_result()
      if (is.null(details)) {
        return(list(
          analysis_type = "PCA",
          type = "pca",
          data_used = df(),
          model = NULL,
          summary = NULL,
          posthoc = NULL,
          effects = NULL,
          stats = if (!is.null(df())) list(n = nrow(df()), vars = names(df())) else NULL,
          selected_vars = input$vars,
          group_var = NULL,
          strata_levels = NULL,
          complete_cases = NULL,
          excluded_rows = NULL,
          excluded_n = NULL,
          original_n = NULL,
          messages = NULL
        ))
      }

      entry <- details$result

      data_used <- details$data_used

      compiled <- NULL
      messages <- NULL
      if (!is.null(entry)) {
        messages <- if (!is.null(entry$message)) list(PCA = entry$message) else NULL

        if (!is.null(entry$model)) {
          model <- entry$model
          rotation_tbl <- as.data.frame(as.table(model$rotation), stringsAsFactors = FALSE)
          colnames(rotation_tbl) <- c("Variable", "Component", "Loading")

          variance_vals <- 100 * model$sdev^2 / sum(model$sdev^2)
          variance_tbl <- data.frame(
            Component = paste0("PC", seq_along(variance_vals)),
            Variance = variance_vals,
            stringsAsFactors = FALSE
          )

          compiled <- list(
            summary = list(PCA = rotation_tbl),
            effects = list(PCA = variance_tbl)
          )
        }
      }

      list(
        analysis_type = "PCA",
        type = "pca",
        data_used = data_used,
        model = entry,
        summary = if (!is.null(compiled)) compiled$summary else NULL,
        posthoc = NULL,
        effects = if (!is.null(compiled)) compiled$effects else NULL,
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        selected_vars = details$selected_vars,
        group_var = NULL,
        strata_levels = NULL,
        complete_cases = if (!is.null(entry)) entry$data else NULL,
        excluded_rows = if (!is.null(entry)) entry$excluded_rows else NULL,
        excluded_n = if (!is.null(entry)) entry$excluded_n else NULL,
        original_n = if (!is.null(entry)) entry$original_n else NULL,
        messages = messages
      )
    })

    output$excluded_rows_section <- renderUI({
      results <- pca_result()
      req(results)

      entry <- results$result
      if (is.null(entry) || is.null(entry$excluded_n) || entry$excluded_n == 0) {
        return(tags$p("No rows were excluded when computing the PCA."))
      }

      tagList(
        h5(sprintf("Excluded rows (%d)", entry$excluded_n)),
        DT::DTOutput(ns("excluded_table"))
      )
    })

    output$excluded_table <- DT::renderDT({
      results <- pca_result()
      req(results)
      
      entry <- results$result
      req(entry$excluded_rows)
      
      DT::datatable(
        entry$excluded_rows,
        options = list(
          scrollX = TRUE,
          pageLength = 5,
          columnDefs = list(list(targets = "_all", className = "dt-nowrap"))
        ),
        rownames = FALSE,
        class = "compact stripe"
      )
    })
    

    analysis_result
  })
}
# ===============================================================
# Visualization Module - PCA (Biplot)
# ===============================================================

# Helper to detect categorical columns ----------------------------------------
.is_categorical <- function(x) {
  is.factor(x) || is.character(x) || is.logical(x)
}

.pca_aesthetic_choices <- function(data, max_levels = NULL) {
  if (missing(data) || is.null(data) || !is.data.frame(data) || ncol(data) == 0) {
    return(c("None" = "None"))
  }

  keep <- vapply(data, .is_categorical, logical(1))
  cat_cols <- names(data)[keep]

  if (!is.null(max_levels) && length(cat_cols) > 0) {
    within_limit <- vapply(cat_cols, function(column_name) {
      column <- data[[column_name]]
      if (is.null(column)) {
        return(FALSE)
      }
      if (is.factor(column)) {
        levels_count <- length(levels(base::droplevels(column)))
      } else {
        unique_values <- unique(as.character(column[!is.na(column)]))
        levels_count <- length(unique_values)
      }
      levels_count <= max_levels
    }, logical(1))
    cat_cols <- cat_cols[within_limit]
  }

  if (length(cat_cols) == 0) {
    return(c("None" = "None"))
  }

  c("None" = "None", stats::setNames(cat_cols, cat_cols))
}

visualize_pca_ui <- function(id, filtered_data = NULL) {
  ns <- NS(id)
  all_choices <- .pca_aesthetic_choices(filtered_data)

  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize principal component analysis (PCA)"),
      p("Visualize multivariate structure using a PCA biplot."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c("PCA biplot" = "biplot"),
          selected = "biplot"
        ),
        "Pick how the PCA results should be displayed."
      ),
      with_help_tooltip(
        uiOutput(ns("pca_color_ui")),
        "Colour the samples using a grouping variable to spot patterns. Variables with more than 10 categories are not allowed."
      ),
      with_help_tooltip(
        uiOutput(ns("pca_shape_ui")),
        "Change the point shapes using a grouping variable for extra contrast. Variables with more than 10 categories are not allowed."
      ),
      with_help_tooltip(
        selectInput(
          ns("pca_label"),
          label = "Label points by",
          choices = all_choices,
          selected = "None"
        ),
        "Add text labels from a column to identify each sample."
      ),
      with_help_tooltip(
        numericInput(
          ns("pca_label_size"),
          label = "Label size",
          value = 2,
          min = 0.5,
          max = 6,
          step = 0.5
        ),
        "Control how large the text labels assigned to points appear on the plot."
      ),
      with_help_tooltip(
        selectInput(
          ns("facet_var"),
          label = "Facet by variable",
          choices = all_choices,
          selected = "None"
        ),
        "Split the plot into small multiples based on a grouping variable."
      ),
      uiOutput(ns("layout_controls")),
      with_help_tooltip(
        checkboxInput(
          ns("show_loadings"),
          label = "Show loadings",
          value = FALSE
        ),
        "Display arrows that show how each original variable contributes to the components."
      ),
      with_help_tooltip(
        numericInput(
          ns("loading_scale"),
          label = "Loading arrow scale",
          value = 1.2, min = 0.1, max = 5, step = 0.1
        ),
        "Stretch or shrink the loading arrows to make them easier to read."
      ),
      fluidRow(
        column(
          width = 6,
          with_help_tooltip(
            numericInput(
              ns("plot_width"),
              label = "Plot width (px)",
              value = 800,
              min = 200,
              max = 2000,
              step = 50
            ),
            "Set the width of the PCA plot in pixels."
          )
        ),
        column(
          width = 6,
          with_help_tooltip(
            numericInput(
              ns("plot_height"),
              label = "Plot height (px)",
              value = 600,
              min = 200,
              max = 2000,
              step = 50
            ),
            "Set the height of the PCA plot in pixels."
          )
        )
      ),
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = TRUE)),
        column(6, base_size_ui(
          ns,
          default = 13,
          help_text = "Adjust the base font size used for PCA plots."
        ))
      ),
      br(),
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, with_help_tooltip(
          downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
          "Save the PCA figure as an image file."
        ))
      )
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"))
    )
  )
}

visualize_pca_server <- function(id, filtered_data, model_fit) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    # -- Reactives ------------------------------------------------------------
    model_info <- reactive({
      info <- model_fit()
      validate(need(!is.null(info) && identical(info$type, "pca"), "Run PCA first."))
      info
    })

    pca_entry <- reactive({
      info <- model_info()
      entry <- info$model
      validate(need(!is.null(entry), "PCA model missing."))
      entry
    })

    validate_choice <- function(value, pool) {
      if (is.null(value) || identical(value, "None") || !nzchar(value)) {
        return(NULL)
      }
      if (length(pool) == 0 || !(value %in% pool)) {
        return(NULL)
      }
      value
    }

    color_data <- reactive({
      entry <- pca_entry()
      if (!is.null(entry) && !is.null(entry$data)) {
        entry$data
      } else {
        resolve_reactive(filtered_data)
      }
    })

    available_choices_all <- reactive(.pca_aesthetic_choices(color_data()))

    valid_column <- function(var) {
      if (is.null(var) || identical(var, "None") || !nzchar(var)) {
        return(NULL)
      }
      data <- color_data()
      if (is.null(data) || !is.data.frame(data) || !var %in% names(data)) {
        return(NULL)
      }
      var
    }

    color_var_reactive <- reactive(valid_column(input$pca_color))

    color_level_order <- reactive({
      var <- color_var_reactive()
      if (is.null(var)) {
        return(NULL)
      }

      data <- color_data()
      if (is.null(data) || !is.data.frame(data) || !var %in% names(data)) {
        return(NULL)
      }

      column <- data[[var]]
      levels_vec <- if (is.factor(column)) {
        levels(base::droplevels(column))
      } else {
        unique(as.character(column[!is.na(column)]))
      }

      levels_vec <- as.character(levels_vec)
      levels_vec <- levels_vec[!is.na(levels_vec) & nzchar(levels_vec)]
      if (!length(levels_vec)) NULL else levels_vec
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = color_data,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE,
      level_order_reactive = color_level_order
    )

    base_size <- base_size_server(
      input = input,
      default = 14
    )

    max_levels <- if (exists("MAX_STRATIFICATION_LEVELS")) MAX_STRATIFICATION_LEVELS else 10L

    level_check <- function(var) {
      if (is.null(var) || identical(var, "None") || !nzchar(var)) {
        return(list(levels = NULL, valid = TRUE, message = NULL))
      }

      data <- color_data()
      if (is.null(data) || !is.data.frame(data) || !var %in% names(data)) {
        return(list(levels = NULL, valid = TRUE, message = NULL))
      }

      column <- data[[var]]
      values <- if (is.factor(column)) {
        levels(base::droplevels(column))
      } else {
        unique(as.character(column[!is.na(column)]))
      }

      values <- values[!is.na(values) & nzchar(values)]
      n_levels <- length(values)

      list(
        levels = values,
        valid = n_levels <= max_levels,
        message = if (n_levels > max_levels) sprintf("'%s' has too many levels (%d > %d).", var, n_levels, max_levels) else NULL
      )
    }

    output$pca_color_ui <- renderUI({
      choices <- available_choices_all()
      pool <- unname(choices)
      selected <- if (!is.null(input$pca_color) && input$pca_color %in% pool) input$pca_color else "None"
      check <- level_check(selected)

      tagList(
        selectInput(
          ns("pca_color"),
          label = "Color points by",
          choices = choices,
          selected = selected
        ),
        if (!is.null(check$message)) div(class = "text-danger small", check$message)
      )
    })

    output$pca_shape_ui <- renderUI({
      choices <- available_choices_all()
      pool <- unname(choices)
      selected <- if (!is.null(input$pca_shape) && input$pca_shape %in% pool) input$pca_shape else "None"
      check <- level_check(selected)

      tagList(
        selectInput(
          ns("pca_shape"),
          label = "Shape points by",
          choices = choices,
          selected = selected
        ),
        if (!is.null(check$message)) div(class = "text-danger small", check$message)
      )
    })

    facet_grid_inputs <- plot_grid_server("facet_grid")

    observeEvent(available_choices_all(), {
      all_choices <- available_choices_all()

      update_input <- function(id, current, choices) {
        pool <- unname(choices)
        selected <- if (!is.null(current) && current %in% pool) current else "None"
        updateSelectInput(session, id, choices = choices, selected = selected)
      }

      update_input("pca_label", input$pca_label, all_choices)
      update_input("facet_var", input$facet_var, all_choices)
    }, ignoreNULL = FALSE)

    output$layout_controls <- renderUI({
      facet_info <- facet_selection()
      if (is.null(facet_info$var) || length(facet_info$levels) <= 1) {
        return(NULL)
      }

      plot_grid_ui(
        id = session$ns("facet_grid"),
        rows_help = "Decide how many rows of panels to show when faceting the PCA plot.",
        cols_help = "Decide how many columns of panels to show when faceting the PCA plot."
      )
    })
    empty_facet <- list(var = NULL, levels = NULL, column = NULL)

    facet_selection <- reactive({
      data <- color_data()
      if (is.null(data) || !is.data.frame(data) || nrow(data) == 0) {
        return(empty_facet)
      }

      facet_var <- valid_column(input$facet_var)
      if (is.null(facet_var)) {
        return(empty_facet)
      }

      column <- data[[facet_var]]
      if (is.null(column)) {
        return(empty_facet)
      }

      levels <- if (is.factor(column)) {
        levels(droplevels(column))
      } else {
        unique(as.character(column[!is.na(column)]))
      }

      levels <- levels[!is.na(levels)]

      list(var = facet_var, levels = levels, column = column)
    })

    build_message_panel <- function(title, message, show_title = TRUE) {
      has_title <- isTRUE(show_title) && !is.null(title) && nzchar(title)
      ggplot() +
        ta_plot_theme_void() +
        annotate("text", x = 0.5, y = 0.5, label = message, size = 4, hjust = 0.5, vjust = 0.5) +
        coord_cartesian(xlim = c(0, 1), ylim = c(0, 1), clip = "off") +
        labs(title = if (has_title) title else NULL) +
        theme(plot.title = if (has_title) element_text(size = 14, face = "bold", hjust = 0.5) else element_blank())
    }

    sanitize_suffix <- function(value) {
      value <- value[1]
      safe <- gsub("[^A-Za-z0-9]+", "_", value)
      safe <- gsub("_+", "_", safe)
      safe <- gsub("^_|_$", "", safe)
      if (!nzchar(safe)) {
        "facet"
      } else {
        tolower(safe)
      }
    }

    plot_info <- eventReactive(input$apply_plot, {
      req(isTRUE(input$apply_plot > 0))
      req(input$plot_type)
      validate(need(input$plot_type == "biplot", "Unsupported plot type."))

      entry <- pca_entry()
      plot_w <- ifelse(is.na(input$plot_width) || input$plot_width <= 0, 800, input$plot_width)
      plot_h <- ifelse(is.na(input$plot_height) || input$plot_height <= 0, 600, input$plot_height)

      empty_result <- function(message) {
        defaults <- compute_default_grid(1L)
        layout <- basic_grid_layout(rows = 1, cols = 1, default_rows = 1, default_cols = 1)
        list(
          plot = build_message_panel(title = NULL, message = message, show_title = FALSE),
          layout = layout,
          facet_levels = NULL,
          panels = 1L,
          warning = NULL,
          defaults = defaults,
          facet_var = NULL,
          plot_width = plot_w,
          plot_height = plot_h
        )
      }

      if (is.null(entry) || is.null(entry$model)) {
        message <- if (!is.null(entry$message) && nzchar(entry$message)) entry$message else "No PCA results available."
        return(empty_result(message))
      }

      if (is.null(entry$model$x) || nrow(entry$model$x) < 2) {
        return(empty_result("PCA scores not available."))
      }

      data <- entry$data
      if (is.null(data) || nrow(data) == 0) {
        return(empty_result("PCA data unavailable."))
      }

      all_pool <- unname(available_choices_all())
      color_var <- validate_choice(input$pca_color, all_pool)
      shape_var <- validate_choice(input$pca_shape, all_pool)
      label_var <- validate_choice(input$pca_label, all_pool)
      label_size <- ifelse(is.null(input$pca_label_size) || is.na(input$pca_label_size), 2, input$pca_label_size)
      show_loadings <- isTRUE(input$show_loadings)
      loading_scale <- ifelse(is.null(input$loading_scale) || is.na(input$loading_scale), 1.2, input$loading_scale)

      max_levels <- if (exists("MAX_STRATIFICATION_LEVELS")) MAX_STRATIFICATION_LEVELS else 10L

      validate_levels <- function(var) {
        if (is.null(var) || !var %in% names(data)) {
          return(NULL)
        }

        column <- data[[var]]
        values <- if (is.factor(column)) {
          levels(base::droplevels(column))
        } else {
          unique(as.character(column[!is.na(column)]))
        }

        values <- values[!is.na(values) & nzchar(values)]
        n_levels <- length(values)

        validate(need(
          n_levels <= max_levels,
          sprintf("'%s' has too many levels (%d > %d).", var, n_levels, max_levels)
        ))

        values
      }

      facet_info <- facet_selection()
      facet_var <- facet_info$var
      facet_levels <- facet_info$levels
      facet_column <- facet_info$column

      subset_list <- if (is.null(facet_var)) {
        list(All = seq_len(nrow(data)))
      } else if (length(facet_levels) > 0) {
        facet_values <- as.character(if (is.factor(facet_column)) droplevels(facet_column) else facet_column)
        stats::setNames(lapply(facet_levels, function(level) {
          which(!is.na(facet_values) & facet_values == level)
        }), facet_levels)
      } else {
        list(`No data` = integer())
      }

      color_check <- level_check(color_var)
      shape_check <- level_check(shape_var)

      validate(need(color_check$valid, color_check$message))
      validate(need(shape_check$valid, shape_check$message))

      scores <- as.data.frame(entry$model$x[, 1:2, drop = FALSE])
      names(scores)[1:2] <- c("PC1", "PC2")

      adjust_limits <- function(values) {
        if (length(values) != 2 || any(!is.finite(values))) {
          return(c(-1, 1))
        }
        rng <- range(values)
        if (diff(rng) == 0) {
          center <- rng[1]
          width <- if (abs(center) < 1) 1 else abs(center) * 0.1
          return(c(center - width, center + width))
        }
        rng
      }

      x_limits <- adjust_limits(range(scores$PC1, na.rm = TRUE))
      y_limits <- adjust_limits(range(scores$PC2, na.rm = TRUE))

      plot_list <- lapply(names(subset_list), function(key) {
        idx <- subset_list[[key]]
        if (length(idx) == 0) {
          return(build_message_panel(title = key, message = "No data available for this facet.", show_title = TRUE))
        }

        local_color <- if (!is.null(color_var) && color_var %in% names(data)) color_var else NULL
        local_shape <- if (!is.null(shape_var) && shape_var %in% names(data)) shape_var else NULL
        local_label <- if (!is.null(label_var) && label_var %in% names(data)) label_var else NULL

        plot_obj <- build_pca_biplot(
          pca_obj = entry$model,
          data = data,
          color_var = local_color,
          shape_var = local_shape,
          label_var = local_label,
          label_size = label_size,
          show_loadings = show_loadings,
          loading_scale = loading_scale,
          custom_colors = custom_colors(),
          subset_rows = idx,
          color_levels = NULL,
          x_limits = x_limits,
          y_limits = y_limits,
          base_size = base_size()
        )

        if (!is.null(facet_var)) {
          plot_obj <- plot_obj + ggtitle(key) + theme(plot.title = element_text(size = 14, face = "bold"))
        }

        plot_obj
      })
      names(plot_list) <- names(subset_list)

      plot_list <- Filter(Negate(is.null), plot_list)
      validate(need(length(plot_list) > 0, "No PCA plots available."))

      panel_count <- length(plot_list)
      defaults <- compute_default_grid(panel_count)

      use_custom_layout <- !is.null(facet_var) && panel_count > 1
      rows_input <- if (use_custom_layout) facet_grid_inputs$rows() else NA
      cols_input <- if (use_custom_layout) facet_grid_inputs$cols() else NA

      layout <- basic_grid_layout(
        rows = rows_input,
        cols = cols_input,
        default_rows = defaults$rows,
        default_cols = defaults$cols
      )

      validation <- validate_grid(panel_count, layout$nrow, layout$ncol)

      combined <- NULL
      if (isTRUE(validation$valid)) {
        combined <- patchwork::wrap_plots(
          plotlist = plot_list,
          nrow = layout$nrow,
          ncol = layout$ncol
        ) +
          patchwork::plot_layout(guides = "collect")
      }

      list(
        plot = combined,
        layout = layout,
        facet_levels = if (!is.null(facet_var)) names(plot_list) else NULL,
        panels = panel_count,
        warning = validation$message,
        defaults = defaults,
        facet_var = facet_var,
        plot_width = plot_w,
        plot_height = plot_h
      )
    }, ignoreNULL = TRUE, ignoreInit = TRUE)

    observeEvent(plot_info(), {
      info <- plot_info()
      apply_grid_defaults_if_empty(input, session, "facet_grid", info$defaults, n_items = info$panels)
    }, ignoreNULL = TRUE)

    plot_dimensions <- reactive({
      info <- plot_info()
      if (is.null(info)) {
        return(list(w = 800, h = 600))
      }

      layout <- info$layout

      plot_w <- info$plot_width %||% 800
      plot_h <- info$plot_height %||% 600

      ncol <- if (!is.null(layout$ncol)) max(1, layout$ncol) else 1
      nrow <- if (!is.null(layout$nrow)) max(1, layout$nrow) else 1

      list(w = plot_w * ncol, h = plot_h * nrow)
    })
    
    output$plot_warning <- renderUI({
      info <- plot_info()
      if (is.null(info)) return(NULL)
      if (!is.null(info$warning)) {
        div(class = "alert alert-warning", info$warning)
      } else {
        NULL
      }
    })

    output$plot <- renderPlot({
      info <- plot_info()
      if (is.null(info) || !is.null(info$warning) || is.null(info$plot)) return(NULL)
      info$plot
    },
    width = function() plot_dimensions()$w,
    height = function() plot_dimensions()$h,
    res = 96)
    
    output$download_plot <- downloadHandler(
      filename = function() {
        info <- plot_info()
        facet_var <- info$facet_var
        suffix <- if (!is.null(facet_var)) {
          paste0("_facet_", sanitize_suffix(facet_var))
        } else {
          "_global"
        }
        paste0("pca_biplot", suffix, "_", Sys.Date(), ".png")
      },
      content = function(file) {
        info <- plot_info()
        req(!is.null(info))
        req(is.null(info$warning))
        s <- plot_dimensions()
        ggsave(
          filename = file,
          plot = info$plot,
          device = "png",
          dpi = 300,
          width  = s$w / 96,
          height = s$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}


build_pca_biplot <- function(pca_obj, data, color_var = NULL, shape_var = NULL,
                             label_var = NULL, label_size = 2,
                             show_loadings = FALSE, loading_scale = 1.2,
                             custom_colors = NULL, subset_rows = NULL,
                             color_levels = NULL, x_limits = NULL,
                             y_limits = NULL, base_size = 13) {
  stopifnot(!is.null(pca_obj$x))

  scores <- as.data.frame(pca_obj$x[, 1:2])
  names(scores)[1:2] <- c("PC1", "PC2")

  if (!is.null(subset_rows)) {
    subset_rows <- unique(subset_rows)
    subset_rows <- subset_rows[subset_rows >= 1 & subset_rows <= nrow(scores)]
    scores <- scores[subset_rows, , drop = FALSE]
    if (!is.null(data)) {
      data <- data[subset_rows, , drop = FALSE]
    }
  }

  var_exp <- 100 * (pca_obj$sdev^2 / sum(pca_obj$sdev^2))
  x_lab <- sprintf("PC1 (%.1f%%)", var_exp[1])
  y_lab <- sprintf("PC2 (%.1f%%)", var_exp[2])

  if (!is.null(data) && nrow(data) == nrow(scores)) {
    plot_data <- cbind(scores, data)
  } else {
    plot_data <- scores
  }
  
  if (!is.null(label_var) && !identical(label_var, "") && !is.null(plot_data[[label_var]])) {
    label_values <- as.character(plot_data[[label_var]])
    label_values[is.na(label_values) | trimws(label_values) == ""] <- NA_character_
    if (any(!is.na(label_values))) {
      plot_data$label_value <- label_values
    } else {
      label_var <- NULL
    }
  } else {
    label_var <- NULL
  }
  
  if (!is.null(color_var) && !is.null(plot_data[[color_var]])) {
    if (is.null(color_levels)) {
      color_levels <- if (is.factor(plot_data[[color_var]])) {
        levels(plot_data[[color_var]])
      } else {
        unique(as.character(plot_data[[color_var]]))
      }
    }
    color_levels <- unique(color_levels[!is.na(color_levels)])
    plot_data[[color_var]] <- factor(as.character(plot_data[[color_var]]), levels = color_levels)
  }
  
  aes_mapping <- aes(x = PC1, y = PC2)
  if (!is.null(color_var)) aes_mapping <- modifyList(aes_mapping, aes(color = .data[[color_var]]))
  if (!is.null(shape_var)) aes_mapping <- modifyList(aes_mapping, aes(shape = .data[[shape_var]]))
  
  single_color <- resolve_single_color(custom_colors)
  g <- ggplot(plot_data, aes_mapping) +
    geom_point(
      size = 3,
      shape = if (is.null(shape_var)) 16 else NULL,
      color = if (is.null(color_var)) single_color else NULL
    ) +
    ta_plot_theme(base_size = base_size) +
    labs(
      x = x_lab,
      y = y_lab,
      color = if (!is.null(color_var)) color_var else NULL,
      shape = if (!is.null(shape_var)) shape_var else NULL
    ) +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af"),
      legend.position = "right"
    )
  
  if (!is.null(color_var)) {
    palette <- resolve_palette_for_levels(levels(plot_data[[color_var]]), custom = custom_colors)
    g <- g + scale_color_manual(values = palette)
  }
  
  if (!is.null(x_limits) || !is.null(y_limits)) {
    g <- g + coord_cartesian(xlim = x_limits, ylim = y_limits)
  }

  if (!is.null(label_var)) {
    g <- g + ggrepel::geom_text_repel(
      aes(label = label_value),
      color = if (is.null(color_var)) single_color else NULL,
      size = label_size,
      max.overlaps = Inf,
      min.segment.length = 0,
      box.padding = 0.3,
      point.padding = 0.2,
      segment.size = 0.2,
      na.rm = TRUE
    )
  }
  
  # ---- Loadings as arrows (optional) ----
  if (isTRUE(show_loadings) && !is.null(pca_obj$rotation)) {
    R <- as.data.frame(pca_obj$rotation[, 1:2, drop = FALSE])
    R$variable <- rownames(pca_obj$rotation)
    
    # scale arrows to score space
    rx <- diff(range(pca_obj$x[, 1], na.rm = TRUE))
    ry <- diff(range(pca_obj$x[, 2], na.rm = TRUE))
    sx <- ifelse(is.finite(rx) && rx > 0, rx, 1)
    sy <- ifelse(is.finite(ry) && ry > 0, ry, 1)
    
    arrows_df <- transform(
      R,
      x = 0, y = 0,
      xend = PC1 * sx * loading_scale,
      yend = PC2 * sy * loading_scale
    )
    
    g <- g +
      geom_segment(
        data = arrows_df,
        aes(x = x, y = y, xend = xend, yend = yend),
        inherit.aes = FALSE,
        arrow = grid::arrow(length = grid::unit(0.02, "npc")),
        linewidth = 0.4,
        color = "grey30"
      ) +
      ggrepel::geom_text_repel(
        data = arrows_df,
        aes(x = xend, y = yend, label = variable),
        inherit.aes = FALSE,
        size = 3,
        color = "grey20",
        max.overlaps = Inf,
        segment.size = 0.2,
        box.padding = 0.2,
        point.padding = 0.2
      )
  }
  
  g
}
# ===============================================================
# ðŸ§¬ Common module for LM and LMM
# ===============================================================

reg_diagnostic_explanation <- paste(
  "The Residuals vs Fitted plot shows how far the model's predictions are from the observed values.",
  "A healthy model has points that bounce randomly around the dashed zero line; clear curves or a funnel shape mean the model is missing structure or the error size changes across fitted values.",
  "The Normal Q-Q plot checks whether the residuals follow a roughly normal distribution.",
  "Points that stay close to the dashed line support the normality assumption, while steady bends or extreme outliers hint at skewed or heavy-tailed errors.",
  "If you spot strong patterns in either plot, consider transforming variables, adding predictors, or trying a different model to improve the fit."
)

fit_all_models <- function(df, responses, rhs, strat_details, engine, allow_multi_response) {
  safe_fit <- purrr::safely(reg_fit_model)

  make_entry <- function(label = NULL, display = label, model = NULL, error = NULL) {
    list(label = label, display = display, model = model, error = error)
  }

  record_success <- function(resp, model_obj, model_key, stratum_label = NULL) {
    success_resps <<- c(success_resps, resp)
    current <- success_models[[resp]]
    if (is.null(current)) current <- list()
    current[[model_key]] <- model_obj
    success_models[[resp]] <<- current

    flat_models[[length(flat_models) + 1]] <<- list(
      response = resp,
      stratum = stratum_label,
      model = model_obj
    )
    if (is.null(primary_model)) primary_model <<- model_obj
  }

  record_error <- function(resp, message) {
    error_resps <<- c(error_resps, resp)
    error_messages[[resp]] <<- message
    if (is.null(primary_error)) primary_error <<- message
  }

  fits <- list()
  success_resps <- character(0)
  error_resps <- character(0)
  success_models <- list()
  error_messages <- list()
  flat_models <- list()
  primary_model <- NULL
  primary_error <- NULL

  for (resp in responses) {
    if (is.null(strat_details$var)) {
      result <- safe_fit(resp, rhs, df, engine = engine)
      strata_entry <- make_entry(display = "Overall")

      if (is.null(result$error)) {
        strata_entry$model <- result$result
        record_success(resp, result$result, "Overall")
      } else {
        strata_entry$error <- result$error$message
        record_error(resp, strata_entry$error)
      }

      fits[[resp]] <- list(stratified = FALSE, strata = list(strata_entry))
    } else {
      strata_entries <- list()
      successful_strata <- list()

      for (level in strat_details$levels) {
        entry <- make_entry(label = level, display = level)
        subset_data <- df[df[[strat_details$var]] == level, , drop = FALSE]

        if (nrow(subset_data) == 0) {
          entry$error <- paste0("No observations available for stratum '", level, "'.")
        } else {
          result <- safe_fit(resp, rhs, subset_data, engine = engine)
          if (is.null(result$error)) {
            entry$model <- result$result
            successful_strata[[level]] <- result$result
            record_success(resp, result$result, level, stratum_label = level)
          } else {
            entry$error <- result$error$message
          }
        }

        strata_entries[[length(strata_entries) + 1]] <- entry
      }

      fits[[resp]] <- list(stratified = TRUE, strata = strata_entries)

      if (length(successful_strata) > 0) {
        success_models[[resp]] <- successful_strata
      } else {
        errors_vec <- vapply(
          strata_entries,
          function(entry) {
            if (!is.null(entry$error) && nzchar(entry$error)) {
              paste0(entry$display, ": ", entry$error)
            } else {
              NA_character_
            }
          },
          character(1)
        )
        errors_vec <- errors_vec[!is.na(errors_vec)]
        combined_error <- if (length(errors_vec) > 0) {
          paste(errors_vec, collapse = "\n")
        } else {
          "Model fitting failed."
        }
        record_error(resp, combined_error)
      }
    }
  }

  list(
    responses = responses,
    success_responses = unique(success_resps),
    error_responses = unique(error_resps),
    fits = fits,
    models = success_models,
    flat_models = flat_models,
    model = primary_model,
    errors = error_messages,
    error = primary_error,
    rhs = rhs,
    allow_multi = allow_multi_response,
    stratification = strat_details
  )
}

render_model_summary <- function(engine, model_obj) {
  if (engine == "lm") {
    reg_display_lm_summary(model_obj)
  } else {
    reg_display_lmm_summary(model_obj)
  }
}

render_residual_plot <- function(model_obj) {
  plot_df <- data.frame(
    fitted = stats::fitted(model_obj),
    residuals = stats::residuals(model_obj)
  )

  ggplot2::ggplot(plot_df, ggplot2::aes(x = fitted, y = residuals)) +
    ggplot2::geom_point(color = "steelblue", alpha = 0.8) +
    ggplot2::geom_hline(yintercept = 0, linetype = "dashed") +
    ggplot2::labs(
      title = "Residuals vs Fitted",
      x = "Fitted values",
      y = "Residuals"
    ) +
    ta_plot_theme(base_size = 13) +
    ggplot2::theme(
      panel.grid.major = ggplot2::element_blank(),
      panel.grid.minor = ggplot2::element_blank(),
      axis.line = ggplot2::element_line(color = "#9ca3af"),
      axis.ticks = ggplot2::element_line(color = "#9ca3af")
    )
}

render_qq_plot <- function(model_obj) {
  resid_vals <- stats::residuals(model_obj)
  qq_base <- stats::qqnorm(resid_vals, plot.it = FALSE)
  
  qq_df <- data.frame(
    theoretical = qq_base$x,
    sample = qq_base$y
  )
  
  resid_mean <- mean(resid_vals)
  resid_sd <- sd(resid_vals)
  
  ggplot2::ggplot(qq_df, ggplot2::aes(x = theoretical, y = sample)) +
    ggplot2::geom_point(color = "steelblue", alpha = 0.8) +
    ggplot2::geom_abline(
      slope = resid_sd,
      intercept = resid_mean,
      linetype = "dashed"
    ) +
    ggplot2::labs(
      title = "Normal Q-Q",
      x = "Theoretical quantiles",
      y = "Sample quantiles"
    ) +
    ta_plot_theme(base_size = 13) +
    ggplot2::theme(
      panel.grid.major = ggplot2::element_blank(),
      panel.grid.minor = ggplot2::element_blank(),
      axis.line = ggplot2::element_line(color = "#9ca3af"),
      axis.ticks = ggplot2::element_line(color = "#9ca3af")
    )
}


assign_download_handler <- function(output, id, engine, response, stratum_display, model_obj) {
  output[[id]] <- downloadHandler(
    filename = function() {
      parts <- c(engine, "results", response)
      if (!is.null(stratum_display)) parts <- c(parts, stratum_display)
      paste0(paste(parts, collapse = "_"), "_", Sys.Date(), ".docx")
    },
    content = function(file) {
      write_lm_docx(model_obj, file)
    }
  )
}

assign_model_outputs <- function(output, engine, response, idx, model_obj, stratum_idx = NULL, stratum_display = NULL) {
  suffix <- if (is.null(stratum_idx)) idx else paste(idx, stratum_idx, sep = "_")
  summary_id <- paste0("summary_", suffix)
  resid_id <- paste0("resid_", suffix)
  qq_id <- paste0("qq_", suffix)
  download_id <- paste0("download_", suffix)

  output[[summary_id]] <- renderPrint({
    render_model_summary(engine, model_obj)
  })

  output[[resid_id]] <- renderPlot({
    render_residual_plot(model_obj)
  })

  output[[qq_id]] <- renderPlot({
    render_qq_plot(model_obj)
  })

  assign_download_handler(output, download_id, engine, response, stratum_display, model_obj)
}

build_diagnostic_block <- function(ns, suffix, tooltip_text) {
  tagList(
    verbatimTextOutput(ns(paste0("summary_", suffix))),
    br(),
    h5("Diagnostics"),
    br(),
    fluidRow(
      column(6, plotOutput(ns(paste0("resid_", suffix)))),
      column(6, plotOutput(ns(paste0("qq_", suffix))))
    ),
    br(),
    helpText(reg_diagnostic_explanation),
    br(),
    br(),
    with_help_tooltip(
      downloadButton(ns(paste0("download_", suffix)), "Download results", style = "width: 100%;"),
      tooltip_text
    )
  )
}

build_response_content <- function(ns, idx, fit_entry) {
  if (!isTRUE(fit_entry$stratified)) {
    return(build_diagnostic_block(ns, idx, "Save the model summary and diagnostics for this response."))
  }

  strata <- fit_entry$strata
  stratum_tabs <- lapply(seq_along(strata), function(j) {
    stratum <- strata[[j]]
    label <- if (!is.null(stratum$display)) stratum$display else paste("Stratum", j)

    content <- if (!is.null(stratum$model)) {
      build_diagnostic_block(ns, paste(idx, j, sep = "_"), "Save the model summary and diagnostics for this stratum.")
    } else {
      tags$pre(format_safe_error_message("Model fitting failed", stratum$error))
    }

    tabPanel(title = label, content)
  })

  do.call(
    tabsetPanel,
    c(list(id = ns(paste0("strata_tabs_", idx))), stratum_tabs)
  )
}

build_model_ui <- function(ns, models_info) {
  success_resps <- models_info$success_responses
  error_resps <- models_info$error_responses
  fits <- models_info$fits

  error_block <- NULL
  if (!is.null(error_resps) && length(error_resps) > 0) {
    error_block <- lapply(error_resps, function(resp) {
      err <- models_info$errors[[resp]]
      tags$pre(
        format_safe_error_message(
          paste("Model fitting failed for", resp),
          if (!is.null(err)) err else ""
        )
      )
    })
  }

  if (is.null(success_resps) || length(success_resps) == 0) {
    if (!is.null(error_block)) return(do.call(tagList, error_block))
    return(NULL)
  }

  panels <- lapply(seq_along(success_resps), function(idx) {
    response <- success_resps[idx]
    fit_entry <- fits[[response]]
    content <- build_response_content(ns, idx, fit_entry)

    if (length(success_resps) > 1) {
      tabPanel(title = response, content)
    } else {
      content
    }
  })

  results_block <- if (length(success_resps) > 1) {
    do.call(tabsetPanel, c(list(id = ns("results_tabs")), panels))
  } else {
    panels[[1]]
  }

  elements <- c(if (!is.null(error_block)) error_block, list(results_block))
  do.call(tagList, elements)
}

render_model_outputs <- function(output, models_info, engine) {
  success_resps <- models_info$success_responses
  fits <- models_info$fits

  if (is.null(success_resps) || length(success_resps) == 0) return()

  for (idx in seq_along(success_resps)) {
    response <- success_resps[idx]
    fit_entry <- fits[[response]]
    strata <- fit_entry$strata

    for (j in seq_along(strata)) {
      stratum <- strata[[j]]
      if (is.null(stratum$model)) next
      is_stratified <- isTRUE(fit_entry$stratified)
      assign_model_outputs(
        output,
        engine,
        response,
        idx,
        stratum$model,
        stratum_idx = if (is_stratified) j else NULL,
        stratum_display = if (is_stratified) stratum$display else NULL
      )
      if (!is_stratified) break
    }
  }
}

regression_ui <- function(id, engine = c("lm", "lmm"), allow_multi_response = FALSE) {
  ns <- NS(id)
  engine <- match.arg(engine)
  allow_multi_response <- isTRUE(allow_multi_response)

  list(
    config = tagList(
      if (allow_multi_response) multi_response_ui(ns("response")) else uiOutput(ns("response_ui")),
      uiOutput(ns("fixed_selector")),
      uiOutput(ns("level_order")),
      uiOutput(ns("covar_selector")),
      if (engine == "lmm") uiOutput(ns("random_selector")),
      uiOutput(ns("interaction_select")),
      uiOutput(ns("formula_preview")),
      br(),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show results", width = "100%"),
          "Fit the model using the chosen predictors and options."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_model"), "Download all results", style = "width: 100%;"),
          "Export the model outputs, tables, and summaries to your computer."
        ))
      )
    ),
    results = tagList(
      uiOutput(ns("results_ui"))
    )
  )
}

regression_server <- function(id, data, engine = c("lm", "lmm"), allow_multi_response = FALSE) {
  engine <- match.arg(engine)
  allow_multi_response <- isTRUE(allow_multi_response)

  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    strat_info <- stratification_server("strat", data)

    if (allow_multi_response) {
      selected_responses <- multi_response_server("response", data)
    } else {
      output$response_ui <- renderUI({
        req(data())
        types <- reg_detect_types(data())
        with_help_tooltip(
          selectInput(ns("dep"), "Response variable (numeric)", choices = types$num),
          "Choose the outcome that the model should predict."
        )
      })

      selected_responses <- reactive({
        req(input$dep)
        input$dep
      })
    }

    output$fixed_selector <- renderUI({
      req(data())
      types <- reg_detect_types(data())
      with_help_tooltip(
        selectInput(
          ns("fixed"),
          "Categorical predictors",
          choices = types$fac,
          multiple = TRUE
        ),
        "Pick factor variables that might explain differences in the response."
      )
    })

    output$level_order <- renderUI({
      req(data())
      req(input$fixed)

      df <- data()
      fac_vars <- input$fixed

      if (length(fac_vars) == 0) return(NULL)

      tagList(
        lapply(fac_vars, function(var) {
          values <- df[[var]]
          lvls <- resolve_order_levels(values)
          with_help_tooltip(
            selectInput(
              ns(paste0("order_", var)),
              paste("Order of levels (first = reference)", var),
              choices = lvls,
              selected = lvls,
              multiple = TRUE
            ),
            sprintf("Arrange the levels of %s; the first level becomes the model reference.", var)
          )
        })
      )
    })

    output$covar_selector <- renderUI({
      req(data())
      types <- reg_detect_types(data())
      with_help_tooltip(
        selectInput(
          ns("covar"),
          "Numeric predictors",
          choices = types$num,
          multiple = TRUE
        ),
        "Pick numeric predictors that could help explain the response."
      )
    })

    if (engine == "lmm") {
      output$random_selector <- renderUI({
        req(data())
        types <- reg_detect_types(data())
        with_help_tooltip(
          selectInput(
            ns("random"),
            "Random effect (categorical)",
            choices = types$fac,
            selected = NULL
          ),
          "Choose a grouping factor for random intercepts in the mixed model."
        )
      })
    }

    output$interaction_select <- renderUI({
      req(data())
      types <- reg_detect_types(data())
      reg_interactions_ui(ns, input$fixed, types$fac)
    })

    output$formula_preview <- renderUI({
      responses <- selected_responses()
      req(length(responses) > 0)
      rhs <- reg_compose_rhs(
        input$fixed,
        input$covar,
        input$interactions,
        if (engine == "lmm") input$random else NULL,
        engine = engine
      )
      reg_formula_preview_ui(ns, responses[1], rhs)
    })

    models <- eventReactive(input$run, {
      req(data())
      df <- data()
      responses <- selected_responses()
      req(length(responses) > 0)
      validate_numeric_columns(df, responses, "response variable(s)")

      rhs <- reg_compose_rhs(
        input$fixed,
        input$covar,
        input$interactions,
        if (engine == "lmm") input$random else NULL,
        engine = engine
      )

      strat_details <- strat_info()
      fit_all_models(df, responses, rhs, strat_details, engine, allow_multi_response)
    })

    output$results_ui <- renderUI({
      mod <- models()
      req(mod)
      build_model_ui(ns, mod)
    })

    observeEvent(models(), {
      mod <- models()
      req(mod)
      render_model_outputs(output, mod, engine)
    }, ignoreNULL = FALSE)

    output$download_model <- downloadHandler(
      filename = function() {
        mod <- models()
        if (is.null(mod) || length(mod$flat_models) == 0) {
          return(paste0(engine, "_results_", Sys.Date(), ".docx"))
        }

        if (length(mod$flat_models) == 1) {
          entry <- mod$flat_models[[1]]
          parts <- c(engine, "results", entry$response)
          if (!is.null(entry$stratum)) parts <- c(parts, entry$stratum)
          paste0(paste(parts, collapse = "_"), "_", Sys.Date(), ".docx")
        } else {
          paste0(engine, "_all_results_", Sys.Date(), ".docx")
        }
      },
      content = function(file) {
        mod <- models()
        if (is.null(mod)) stop("No models available. Please run the analysis first.")
        flat_models <- mod$flat_models
        if (length(flat_models) == 0) stop("No models available. Please run the analysis first.")

        if (length(flat_models) == 1) {
          write_lm_docx(flat_models[[1]]$model, file)
        } else {
          doc <- officer::read_docx()
          for (entry in flat_models) {
            tmp <- tempfile(fileext = ".docx")
            sublab <- if (!is.null(entry$stratum)) paste("Stratum:", entry$stratum) else NULL
            
            # pass subtitle so it appears RIGHT under the title
            write_lm_docx(entry$model, tmp, subtitle = sublab)
            
            doc <- officer::body_add_docx(doc, src = tmp)
            doc <- officer::body_add_par(doc, "", style = "Normal")
          }
          print(doc, target = file)
        }
      }
    )

    df_final <- reactive({
      data()
    })

    model_fit <- reactive({
      mod <- models()
      req(mod)
      mod$models
    })

    compiled_results <- reactive({
      mod <- models()
      req(mod)
      compile_regression_results(mod, engine)
    })

    summary_table <- reactive({
      res <- compiled_results()
      req(res)
      res$summary
    })

    effect_table <- reactive({
      res <- compiled_results()
      req(res)
      res$effects
    })

    error_table <- reactive({
      res <- compiled_results()
      req(res)
      res$errors
    })

    reactive({
      mod <- models()
      req(mod)

      data_used <- df_final()

      list(
        analysis_type = if (engine == "lm") "LM" else "LMM",
        type = if (engine == "lm") "lm" else "lmm",
        data_used = data_used,
        model = model_fit(),
        summary = summary_table(),
        posthoc = NULL,
        effects = effect_table(),
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        responses = mod$responses,
        success_responses = mod$success_responses,
        error_responses = mod$error_responses,
        errors = mod$errors,
        stratification = mod$stratification,
        rhs = mod$rhs,
        allow_multi = mod$allow_multi,
        compiled_errors = error_table(),
        flat_models = mod$flat_models,
        engine = engine
      )
    })
  })
}
# ===============================================================
# ðŸ”§ Shared helpers for LM/LMM (UI + server utilities)
# ===============================================================

# ---------------------------------------------------------------
# UI setup
# ---------------------------------------------------------------

compact_chr <- function(x) {
  if (is.null(x) || length(x) == 0) return(character(0))
  x
}

reg_protect_vars <- function(vars) {
  if (is.null(vars) || length(vars) == 0) return(vars)

  vals <- vapply(vars, function(v) {
    if (is.null(v) || is.na(v) || !nzchar(v)) return("")
    if (grepl("^`.*`$", v)) v else paste0("`", v, "`")
  }, character(1))

  vals[nzchar(vals)]
}

reg_protect_interactions <- function(interactions) {
  if (is.null(interactions) || length(interactions) == 0) return(interactions)

  vapply(interactions, function(term) {
    parts <- strsplit(term, ":", fixed = TRUE)[[1]]
    paste(reg_protect_vars(parts), collapse = ":")
  }, character(1))
}

reg_formula_text <- function(dep, rhs) {
  dep <- reg_protect_vars(dep)
  if (length(rhs) == 0) {
    paste(dep, "~ 1")
  } else {
    paste(dep, "~", paste(rhs, collapse = " + "))
  }
}

trim_output_section <- function(lines, start_pattern, end_pattern = NULL, end_offset = 0) {
  start <- grep(start_pattern, lines)[1]
  if (is.na(start)) return(lines)
  end <- if (is.null(end_pattern)) NA_integer_ else grep(end_pattern, lines)[1]
  if (!is.na(end)) {
    end <- max(start, end - end_offset)
    lines[start:end]
  } else {
    lines[start:length(lines)]
  }
}

reg_detect_types <- function(df) {
  num_vars <- names(df)[sapply(df, is.numeric)]
  fac_vars <- names(df)[sapply(df, function(x) is.factor(x) || is.character(x))]
  list(num = num_vars, fac = fac_vars)
}

reg_variable_selectors_ui <- function(ns, types, allow_random = FALSE) {
  out <- list(
    with_help_tooltip(
      selectInput(ns("dep"), "Response variable (numeric)", choices = types$num),
      "Pick the numeric outcome you want the model to explain."
    ),
    with_help_tooltip(
      selectInput(ns("fixed"), "Categorical predictors", choices = types$fac, multiple = TRUE),
      "Select group variables that might influence the response."
    ),
    with_help_tooltip(
      selectInput(ns("covar"), "Numeric predictors", choices = types$num, multiple = TRUE),
      "Select numeric predictors that could explain changes in the response."
    )
  )
  if (allow_random) {
    out <- c(out, list(
      with_help_tooltip(
        selectInput(ns("random"), "Random effect (categorical)", choices = types$fac, selected = NULL),
        "Choose a grouping factor for random intercepts when using mixed models."
      )
    ))
  }
  do.call(tagList, out)
}

reg_interactions_ui <- function(ns, fixed, fac_vars) {
  if (is.null(fixed) || length(fixed) < 2) return(NULL)
  cats_only <- intersect(fixed, fac_vars)
  if (length(cats_only) < 2) return(NULL)
  pairs <- combn(cats_only, 2, simplify = FALSE)
  pair_labels <- vapply(pairs, function(p) paste(p, collapse = " Ã— "), character(1))
  pair_values <- vapply(pairs, function(p) paste(p, collapse = ":"), character(1))
  with_help_tooltip(
    checkboxGroupInput(
      ns("interactions"),
      label = "Select 2-way interactions (optional)",
      choices = stats::setNames(pair_values, pair_labels)
    ),
    "Tick pairs of factors to let the model test if their joint effect matters."
  )
}

# ---------------------------------------------------------------
# Formula construction
# ---------------------------------------------------------------

reg_compose_rhs <- function(fixed, covar, interactions, random = NULL, engine = c("lm","lmm")) {
  engine <- match.arg(engine)
  fixed <- reg_protect_vars(compact_chr(fixed))
  covar <- reg_protect_vars(compact_chr(covar))
  interactions <- reg_protect_interactions(compact_chr(interactions))

  rhs <- c(fixed, covar, interactions)
  if (engine == "lmm" && !is.null(random) && nzchar(random)) {
    rand <- reg_protect_vars(random)
    rhs <- c(rhs, paste0("(1|", rand, ")"))
  }
  rhs
}

reg_formula_preview_ui <- function(ns, dep, rhs) {
  if (is.null(dep) || !nzchar(dep)) return(NULL)
  form_txt <- reg_formula_text(dep, rhs)
  wellPanel(
    strong("Model formula: "),
    code(form_txt)
  )
}

# ---------------------------------------------------------------
# Model computation
# ---------------------------------------------------------------

reg_fit_model <- function(dep, rhs, data, engine = c("lm","lmm")) {
  engine <- match.arg(engine)
  form <- as.formula(reg_formula_text(dep, rhs))
  if (engine == "lm") {
    lm(form, data = data)
  } else {
    # LMM: lme4 + lmerTest for p-values
    lmerTest::lmer(form, data = data)
  }
}

# ---------------------------------------------------------------
# Output composition
# ---------------------------------------------------------------

reg_display_summary <- function(model, engine = c("lm", "lmm")) {
  engine <- match.arg(engine)

  if (engine == "lm") {
    aout <- capture.output(car::Anova(model, type = 3))
    signif_idx <- grep("^Signif\\. codes", aout)
    if (length(signif_idx) > 0) {
      remove_idx <- c(signif_idx - 1, signif_idx)
      aout <- aout[-remove_idx]
    }
    cat(paste(aout, collapse = "\n"), "\n\n")

    sout <- capture.output(summary(model))
    sout <- trim_output_section(sout, "^Residuals:", "^Signif\\. codes", 2)
    cat(paste(sout, collapse = "\n"))
  } else {
    aout <- capture.output(anova(model, type = 3))
    cat(paste(aout, collapse = "\n"), "\n\n")

    sout <- capture.output(summary(model))
    sout <- trim_output_section(sout, "^Scaled residuals:", "^Correlation of Fixed Effects:", 1)

    icc_df <- compute_icc(model)
    if (!is.null(icc_df) && nrow(icc_df) > 0) {
      icc_line <- paste(paste0("ICC (", icc_df$Group, "): ", icc_df$ICC), collapse = "; ")
      random_idx <- grep("^Random effects:", sout)[1]
      if (!is.na(random_idx)) sout <- append(sout, paste0("\n", icc_line), after = random_idx + 4)
      else sout <- c(sout, icc_line)
    }
    cat(paste(sout, collapse = "\n"))
  }
}

reg_display_lm_summary <- function(m) reg_display_summary(m, "lm")

reg_display_lmm_summary <- function(m) reg_display_summary(m, "lmm")

# ---------------------------------------------------------------
# Summaries for standardized regression outputs
# ---------------------------------------------------------------

clean_regression_coef_names <- function(nms) {
  lookup <- c(
    "estimate" = "estimate",
    "std. error" = "std_error",
    "std error" = "std_error",
    "t value" = "statistic",
    "z value" = "statistic",
    "f value" = "statistic",
    "df" = "df",
    "dendf" = "dendf",
    "numdf" = "numdf"
  )

  vapply(nms, function(name) {
    name_trim <- trimws(name)
    key <- tolower(name_trim)
    val <- if (!is.na(key) && key %in% names(lookup)) lookup[[key]] else NULL
    if (!is.null(val)) return(val)
    if (grepl("^Pr\\(>", name_trim)) return("p_value")
    cleaned <- tolower(name_trim)
    cleaned <- gsub("[^[:alnum:]]+", "_", cleaned)
    cleaned <- gsub("^_+|_+$", "", cleaned)
    cleaned <- gsub("_+", "_", cleaned)
    cleaned
  }, character(1), USE.NAMES = FALSE)
}

tidy_regression_model <- function(model, engine) {
  if (is.null(model)) {
    return(list(summary = NULL, effects = NULL))
  }

  coef_mat <- tryCatch(summary(model)$coefficients, error = function(e) NULL)
  coef_df <- NULL
  if (!is.null(coef_mat)) {
    coef_df <- data.frame(
      term = rownames(coef_mat),
      coef_mat,
      row.names = NULL,
      check.names = FALSE,
      stringsAsFactors = FALSE
    )
    original_names <- names(coef_df)
    names(coef_df) <- c("term", clean_regression_coef_names(original_names[-1]))
  }

  if (inherits(model, "lm")) {
    sm <- summary(model)
    metrics <- data.frame(
      metric = c("sigma", "r_squared", "adj_r_squared", "nobs"),
      value = c(sm$sigma, sm$r.squared, sm$adj.r.squared, stats::nobs(model)),
      stringsAsFactors = FALSE
    )
  } else {
    metrics <- data.frame(
      metric = c("sigma", "logLik", "AIC", "BIC", "nobs"),
      value = c(
        stats::sigma(model),
        as.numeric(stats::logLik(model)),
        stats::AIC(model),
        stats::BIC(model),
        stats::nobs(model)
      ),
      stringsAsFactors = FALSE
    )
  }

  anova_tbl <- tryCatch({
    if (engine == "lm") {
      car::Anova(model, type = 3)
    } else {
      anova(model, type = 3)
    }
  }, error = function(e) NULL)

  if (!is.null(anova_tbl)) {
    anova_tbl <- as.data.frame(anova_tbl)
    anova_tbl$Effect <- rownames(anova_tbl)
    rownames(anova_tbl) <- NULL
    anova_tbl <- anova_tbl[, c("Effect", setdiff(names(anova_tbl), "Effect"))]
  }

  effects <- list(metrics = metrics, anova = anova_tbl)
  if (all(vapply(effects, is.null, logical(1)))) effects <- NULL

  list(summary = coef_df, effects = effects)
}

compile_regression_results <- function(model_info, engine) {
  if (is.null(model_info) || is.null(model_info$fits)) return(NULL)

  summary_list <- list()
  effects_list <- list()
  errors_list <- list()

  for (resp in names(model_info$fits)) {
    fit_entry <- model_info$fits[[resp]]
    if (is.null(fit_entry)) next

    store_results <- function(label, stratum) {
      tidy <- tidy_regression_model(stratum$model, engine)
      if (is.null(summary_list[[resp]])) summary_list[[resp]] <<- list()
      if (is.null(effects_list[[resp]])) effects_list[[resp]] <<- list()
      summary_list[[resp]][[label]] <<- tidy$summary
      effects_list[[resp]][[label]] <<- tidy$effects
      if (!is.null(stratum$error)) {
        if (is.null(errors_list[[resp]])) errors_list[[resp]] <<- list()
        errors_list[[resp]][[label]] <<- stratum$error
      }
    }

    if (isTRUE(fit_entry$stratified)) {
      for (stratum in fit_entry$strata) {
        label <- if (!is.null(stratum$display)) stratum$display else stratum$label
        if (is.null(label) || !nzchar(label)) label <- "Stratum"
        store_results(label, stratum)
      }
    } else {
      stratum <- fit_entry$strata[[1]]
      tidy <- tidy_regression_model(stratum$model, engine)
      summary_list[[resp]] <- tidy$summary
      effects_list[[resp]] <- tidy$effects
      if (!is.null(stratum$error)) {
        errors_list[[resp]] <- stratum$error
      }
    }
  }

  list(summary = summary_list, effects = effects_list, errors = errors_list)
}

# ===============================================================
# Results export
# ===============================================================

write_lm_docx <- function(model, file, subtitle = NULL) {

  # Determine model type
  is_lmm <- inherits(model, "merMod")
  dep_var <- all.vars(formula(model))[1]

  add_blank_line <- function(doc, text = "", style = "Normal") {
    body_add_par(doc, text, style = style)
  }

  # Helper for consistent table formatting
  format_table <- function(df, bold_p = TRUE) {
    ft <- flextable(df)
    ft <- fontsize(ft, part = "all", size = 10)
    ft <- bold(ft, part = "header", bold = TRUE)
    ft <- color(ft, part = "header", color = "black")
    ft <- align(ft, align = "center", part = "all")
    ft <- border_remove(ft)
    black <- fp_border(color = "black", width = 1)
    ft <- border(ft, part = "header", border.top = black)
    ft <- border(ft, part = "header", border.bottom = black)
    if (nrow(df) > 0) {
      ft <- border(ft, i = nrow(df), part = "body", border.bottom = black)
    }

    # Bold significant p-values
    if (bold_p) {
      p_cols <- names(df)[grepl("Pr", names(df), fixed = TRUE)]
      for (pcol in p_cols) {
        if (is.numeric(df[[pcol]]) || all(grepl("^[0-9.<]+$", df[[pcol]]))) {
          sig_rows <- suppressWarnings(which(as.numeric(df[[pcol]]) < 0.05))
          if (length(sig_rows) == 0) {
            # handle formatted p-values like "<0.001"
            sig_rows <- grep("<0\\.0*1", df[[pcol]])
          }
          if (length(sig_rows) > 0 && pcol %in% ft$col_keys) {
            ft <- bold(ft, i = sig_rows, j = pcol, bold = TRUE)
          }
        }
      }
    }

    ft <- set_table_properties(ft, layout = "autofit", width = 0.9)
    ft <- padding(ft, padding.top = 2, padding.bottom = 2, padding.left = 2, padding.right = 2)
    ft
  }

  # Create new Word document
  doc <- read_docx()

  # ---- Title ----
  title_text <- sprintf(
    "%s Results â€” %s",
    if (is_lmm) "Linear Mixed Model" else "Linear Model",
    dep_var
  )
  doc <- body_add_fpar(
    doc,
    fpar(ftext(title_text, prop = fp_text(bold = TRUE, font.size = 12)))
  )

  # ---- Subtitle (Stratum, if any) ----
  if (!is.null(subtitle) && nzchar(subtitle)) {
    subtitle_text <- ftext(
      subtitle,
      prop = fp_text(bold = TRUE, font.size = 11)
    )
    doc <- body_add_fpar(doc, fpar(subtitle_text))
  }

  doc <- add_blank_line(doc)

  # ==========================================================
  # ðŸ”¹ ANOVA (Type III)
  # ==========================================================
  doc <- body_add_fpar(doc, fpar(ftext("ANOVA (Type III)", prop = fp_text(bold = TRUE))))
  doc <- add_blank_line(doc)

  if (is_lmm) {
    anova_tbl <- as.data.frame(anova(model, type = 3))
  } else {
    anova_tbl <- as.data.frame(car::Anova(model, type = 3))
  }
  anova_tbl <- tibble::rownames_to_column(anova_tbl, "Effect")

  # Round numeric columns and format p-values
  for (col in names(anova_tbl)) {
    if (is.numeric(anova_tbl[[col]])) anova_tbl[[col]] <- round(anova_tbl[[col]], 3)
  }
  p_col <- grep("^Pr", names(anova_tbl), value = TRUE)
  if (length(p_col) > 0) {
    colnames(anova_tbl)[colnames(anova_tbl) == p_col[1]] <- "Pr(>F)"
  }

  ft_anova <- format_table(anova_tbl)
  doc <- body_add_flextable(doc, ft_anova)
  doc <- add_blank_line(doc)

  # ==========================================================
  # ðŸ”¹ Random Effects & ICC (LMM only)
  # ==========================================================
  if (is_lmm) {
    # ---- Random Effects ----
    doc <- body_add_fpar(doc, fpar(ftext("Random Effects", prop = fp_text(bold = TRUE))))
    doc <- add_blank_line(doc)

    rand_df <- as.data.frame(lme4::VarCorr(model))
    if (nrow(rand_df) > 0) {
      rand_df <- rand_df[, c("grp", "var1", "var2", "vcov", "sdcor"), drop = FALSE]
      rand_df$var2 <- ifelse(is.na(rand_df$var2), "-", rand_df$var2)
      names(rand_df) <- c("Grouping", "Effect 1", "Effect 2", "Variance", "Std. Dev.")
      rand_df$Variance <- round(rand_df$Variance, 3)
      rand_df$`Std. Dev.` <- round(rand_df$`Std. Dev.`, 3)
      ft_rand <- format_table(rand_df, bold_p = FALSE)
      doc <- body_add_flextable(doc, ft_rand)
    } else {
      doc <- add_blank_line(doc, "No random-effect variance components were estimated.")
    }

    # ---- ICC ----
    if (exists("compute_icc") && is.function(compute_icc)) {
      icc_df <- compute_icc(model)
    } else {
      icc_df <- NULL
    }
    if (!is.null(icc_df) && nrow(icc_df) > 0) {
      doc <- add_blank_line(doc)
      doc <- body_add_fpar(doc, fpar(ftext("Intraclass Correlation (ICC)", prop = fp_text(bold = TRUE))))
      doc <- add_blank_line(doc)
      icc_df$ICC <- round(icc_df$ICC, 3)
      ft_icc <- format_table(icc_df, bold_p = FALSE)
      doc <- body_add_flextable(doc, ft_icc)
    }

    doc <- add_blank_line(doc)
  }

  # ==========================================================
  # ðŸ”¹ Model Coefficients
  # ==========================================================
  doc <- body_add_fpar(doc, fpar(ftext("Model Coefficients", prop = fp_text(bold = TRUE))))
  doc <- add_blank_line(doc)

  coef_tbl <- as.data.frame(summary(model)$coefficients)
  coef_tbl <- tibble::rownames_to_column(coef_tbl, "Term")
  names(coef_tbl)[1] <- "Term"
  names(coef_tbl) <- gsub("Pr\\(>\\|t\\|\\)", "Pr(>|t|)", names(coef_tbl))

  for (col in names(coef_tbl)) {
    if (is.numeric(coef_tbl[[col]])) coef_tbl[[col]] <- round(coef_tbl[[col]], 4)
  }

  ft_coef <- format_table(coef_tbl)
  doc <- body_add_flextable(doc, ft_coef)

  # ==========================================================
  # ðŸ”¹ Footer
  # ==========================================================
  doc <- add_blank_line(doc)
  doc <- add_blank_line(doc, "Significance level: p < 0.05 (bold values).")
  doc <- add_blank_line(doc, sprintf("Generated by Table Analyzer on %s", Sys.Date()))

  # Save file
  print(doc, target = file)
}

# ===============================================================
# ðŸ”¤ Base size controls (compact)
# ===============================================================

base_size_ui <- function(ns,
                         input_id = "plot_base_size",
                         default = 13,
                         min = 6,
                         max = 30,
                         step = 1,
                         help_text = "Adjust the base font size used for plot text.") {
  
  style_block <- "
    .ta-base-size-input .shiny-input-container,
    .ta-base-size-input .form-group { margin-bottom: 0; }
    .ta-base-size-input input.form-control {
      height: 32px;
      padding: 4px 10px;
    }
  "
  
  tagList(
    shiny::singleton(tags$style(HTML(style_block))),
    h5("Base size"),
    div(
      class = "ta-base-size-input",
      with_help_tooltip(
        numericInput(
          inputId = ns(input_id),
          label = NULL,
          value = default,
          min = min,
          max = max,
          step = step,
          width = "100%"
        ),
        help_text
      )
    )
  )
}

base_size_server <- function(input,
                             input_id = "plot_base_size",
                             default = 13) {
  
  reactive({
    value <- input[[input_id]]
    if (is.null(value) || !is.numeric(value) || is.na(value) || length(value) == 0) {
      default
    } else {
      value
    }
  })
}

# ===============================================================
# ðŸŽ¨ Module for colors customization
# ===============================================================

# ---- Palette ----
basic_color_palette <- c(
  "steelblue" = "#4682B4",
  "red"       = "#FF0000",
  "green"     = "#008000",  # âœ… web green (not ggplot's neon)
  "blue"      = "#0000FF",
  "orange"    = "#FFA500",
  "purple"    = "#800080",
  "brown"     = "#A52A2A",
  "gold"      = "#FFD700",
  "pink"      = "#FF69B4",
  "cyan"      = "#00FFFF",
  "magenta"   = "#FF00FF",
  "yellow"    = "#FFFF00",
  "black"     = "#000000",
  "gray"      = "#808080",
  "darkgreen" = "#006400",
  "darkred"   = "#8B0000"
)

# ---- UI ----
add_color_customization_ui <- function(ns, multi_group = TRUE) {
  uiOutput(ns("color_custom_ui"))
}

# ---- Server ----
add_color_customization_server <- function(ns,
                                           input,
                                           output,
                                           data,
                                           color_var_reactive,
                                           multi_group = TRUE,
                                           level_order_reactive = NULL) {
  default_color <- "steelblue"

  # ---- Dynamic UI ----
  output$color_custom_ui <- renderUI({
    req(data())

    color_var <- color_var_reactive() %||% ""
    level_override <- if (is.null(level_order_reactive)) NULL else level_order_reactive()

    # Single color UI shown when multi-group off or no color_var available
    if (!isTRUE(multi_group) || color_var %in% c("", "None")) {
      tagList(
        h5("Color"),
        with_help_tooltip(
          color_dropdown_input(ns, "single_color", basic_color_palette, ncol = 4),
          "Choose the colour used for the entire plot."
        )
      )
    } else {
      render_color_inputs(ns, data, color_var, level_override)
    }
  })

  # ---- Reactive color mapping ----
  reactive({
    # --- Single-color mode (no grouping variable or disabled) ---
    if (!isTRUE(multi_group)) {
      return(input$single_color %||% default_color)
    }

    color_var <- color_var_reactive() %||% ""
    if (color_var %in% c("", "None")) {
      return(input$single_color %||% default_color)
    }

    dataset <- data()
    req(dataset)

    if (!color_var %in% names(dataset)) {
      return(input$single_color %||% default_color)
    }

    values <- dataset[[color_var]]
    as_factor <- as.factor(values)
    lvls <- levels(as_factor)
    unique_vals <- unique(as.character(as_factor))
    unique_vals <- unique_vals[!is.na(unique_vals)]

    level_override <- if (is.null(level_order_reactive)) NULL else level_order_reactive()
    if (!is.null(level_override) && length(level_override) > 0) {
      level_override <- unique(as.character(level_override[!is.na(level_override)]))
      remainder <- setdiff(unique_vals, level_override)
      lvls <- c(level_override, remainder)
    } else if (length(lvls) == 0) {
      lvls <- unique_vals
    }

    base_palette <- rep(basic_color_palette, length.out = length(lvls))

    cols <- vapply(seq_along(lvls), function(i) {
      input[[paste0("col_", color_var, "_", i)]] %||% base_palette[i]
    }, character(1))

    names(cols) <- lvls
    cols
  })
}

# ===============================================================
# ðŸŽ¨ UI helper to assign colors per level of a factor
# ===============================================================

render_color_inputs <- function(ns, data, color_var, level_order = NULL) {
  if (is.null(color_var) || color_var == "None") return(NULL)
  if (!color_var %in% names(data())) return(NULL)

  values <- data()[[color_var]]
  raw_levels <- if (is.factor(values)) levels(values) else unique(as.character(values))
  raw_levels <- raw_levels[!is.na(raw_levels)]

  if (!is.null(level_order) && length(level_order) > 0) {
    level_order <- unique(as.character(level_order[!is.na(level_order)]))
    remainder <- setdiff(raw_levels, level_order)
    lvls <- c(level_order, remainder)
  } else {
    lvls <- raw_levels
  }

  default_palette <- rep(basic_color_palette, length.out = length(lvls))

  tagList(
    h5("Colors"),
    lapply(seq_along(lvls), function(i) {
      selected <- default_palette[i]
      tags$div(
        style = "margin-bottom: 8px;",
        tags$label(lvls[i], style = "display:block; margin-bottom: 4px;"),
        with_help_tooltip(
          color_dropdown_input(
            ns,
            id = paste0("col_", color_var, "_", i),
            palette = basic_color_palette,
            ncol = 4,
            selected = selected
          ),
          sprintf("Pick the colour that will represent %s in the plot.", lvls[i])
        )
      )
    })
  )
}

# ===============================================================
# ðŸŽ¨ Compact dropdown-style color picker (4x4 grid)
# ===============================================================

color_dropdown_input <- function(ns, id = "color_choice", palette = basic_color_palette,
                                 ncol = 4, selected = NULL) {
  selected_color <- if (is.null(selected)) palette[1] else selected

  cell_size <- 26
  gap_size <- 4
  padding_size <- 3
  button_size <- cell_size + (2 * padding_size)
  button_height <- button_size
  dropdown_width <- cell_size * ncol + gap_size * (ncol - 1) + 2 * padding_size
  dropdown_top <- button_height + 4

  tagList(
    tags$style(HTML(sprintf(
        "        .color-dropdown {
          position: relative;
          display: inline-block;
          user-select: none;
          width: %dpx;
        }
        .color-dropdown-button {
          width: 100%%;
          border: 1px solid #ccc;
          border-radius: 6px;
          padding: %dpx;
          background-color: #fff;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .color-dropdown-swatch {
          flex: 0 0 %dpx;
          width: %dpx;
          height: %dpx;
          border-radius: 4px;
          border: 1px solid #ccc;
          box-sizing: border-box;
        }
        .color-dropdown-grid {
          display: none;
          position: absolute;
          top: %dpx;
          left: 0;
          z-index: 999;
          background: #fff;
          border: 1px solid #ccc;
          border-radius: 6px;
          padding: %dpx;
          box-shadow: 0 4px 12px rgba(0,0,0,0.08);
          width: %dpx;
          grid-template-columns: repeat(%d, %dpx);
          gap: %dpx;
          box-sizing: border-box;
        }
        .color-dropdown-grid.open {
          display: grid;
        }
        .color-cell {
          width: %dpx;
          height: %dpx;
          border-radius: 4px;
          cursor: pointer;
          border: 1px solid #ccc;
          box-sizing: border-box;
          transition: transform 0.1s ease;
        }
        .color-cell:hover {
          transform: scale(1.05);
        }
      ",
      button_size, padding_size, cell_size, cell_size, cell_size,
      dropdown_top, padding_size, dropdown_width, ncol, cell_size, gap_size,
      cell_size, cell_size
    ))),
    tags$div(
      class = "color-dropdown",
      tags$div(
        id = ns(paste0(id, "_button")),
        class = "color-dropdown-button",
        tags$span(
          class = "color-dropdown-swatch",
          style = sprintf("background-color:%s;", selected_color)
        )
      ),
      tags$div(
        id = ns(paste0(id, "_grid")),
        class = "color-dropdown-grid",
        lapply(names(palette), function(col_name) {
          hex <- palette[[col_name]]
          tags$div(
            class = "color-cell",
            title = col_name,  # tooltip shows readable color name
            style = sprintf("background-color:%s;", hex),
            onclick = sprintf(
              "      var button = $('#%s_button');
      button.find('.color-dropdown-swatch').css('background-color','%s');
      $('#%s_grid').removeClass('open');
      Shiny.setInputValue('%s','%s',{priority:'event'});
      ",
              ns(id), hex, ns(id), ns(id), hex
            )
          )
        })

      )
    ),
    tags$script(HTML(sprintf(
        "        $('#%s_button').on('click', function(e){
          e.stopPropagation();
          var grid = $('#%s_grid');
          $('.color-dropdown-grid').not(grid).removeClass('open');
          grid.toggleClass('open');
        });
        $(document).on('click', function(){
          $('.color-dropdown-grid').removeClass('open');
        });
        Shiny.setInputValue('%s','%s',{priority:'event'});
      ",
      ns(id), ns(id), ns(id), selected_color
    )))
  )
}

# ===============================================================
# ðŸ›ˆ Consistent tooltip helper for UI widgets
# ===============================================================

with_help_tooltip <- function(widget, text) {
  tags$div(
    class = "ta-help-tooltip",
    title = text,
    widget
  )
}

# ===============================================================
# ðŸŽ¨ Palette resolution helpers
# ===============================================================

resolve_palette_for_levels <- function(levels, custom = NULL) {
  if (is.null(levels) || length(levels) == 0) {
    return(resolve_single_color())
  }

  unique_levels <- unique(as.character(levels))
  palette_size <- length(basic_color_palette)
  n_levels <- length(unique_levels)

  if (!is.null(custom) && length(custom) > 0) {
    if (!is.null(names(custom))) {
      ordered <- custom[unique_levels]
      if (all(!is.na(ordered))) {
        return(ordered)
      }
    } else if (length(custom) >= n_levels) {
      return(stats::setNames(custom[seq_len(n_levels)], unique_levels))
    }
  }

  if (n_levels <= palette_size) {
    palette <- basic_color_palette[seq_len(n_levels)]
  } else {
    repeats <- ceiling(n_levels / palette_size)
    palette <- rep(basic_color_palette, repeats)[seq_len(n_levels)]
  }

  stats::setNames(palette, unique_levels)
}

resolve_single_color <- function(custom = NULL) {
  if (!is.null(custom) && length(custom) > 0) {
    candidate <- unname(custom[[1]])
    if (!is.null(candidate) && nzchar(candidate)) {
      return(candidate)
    }
  }
  basic_color_palette[1]
}
# ===============================================================
# ðŸ” Multi-Response Selector Module (final simple version)
# ===============================================================

multi_response_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(
        ns("multi_resp"),
        "Allow multiple response variables",
        value = FALSE
      ),
      "Tick this to analyse several response variables one after another."
    ),
    uiOutput(ns("response_ui"))
  )
}

multi_response_server <- function(id, data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    df <- reactive({
      d <- if (is.function(data)) data() else data
      req(is.data.frame(d))
      d
    })
    
    # --- Re-render only when multi-select mode changes
    output$response_ui <- renderUI({
      d <- req(df())
      num_vars <- names(d)[sapply(d, is.numeric)]
      validate(need(length(num_vars) > 0, "No numeric variables available."))
      
      with_help_tooltip(
        selectInput(
          ns("response"),
          label = if (isTRUE(input$multi_resp))
            "Response variables (numeric)"
          else
            "Response variable (numeric)",
          choices = num_vars,
          selected = num_vars[1],
          multiple = isTRUE(input$multi_resp)
        ),
        "Choose the numeric outcomes the model should process."
      )
    })
    
    # --- Reactive standardized vector
    reactive({
      res <- req(input$response)
      if (!isTRUE(input$multi_resp)) res <- res[1]
      unique(res)
    })
  })
}
# ===============================================================
# ðŸ§© Plot grid module
# ===============================================================

compute_default_grid <- function(n) {
  n <- coerce_grid_value(n, default = 1L)
  rows <- ceiling(sqrt(n))
  list(rows = rows, cols = ceiling(n / rows))
}

coerce_grid_value <- function(value,
                              default = 1L,
                              min_value = 1L,
                              max_value = NULL) {
  raw <- suppressWarnings(as.integer(value[1]))
  if (length(value) == 0 || is.na(raw)) raw <- default
  raw <- max(as.integer(min_value), raw)
  if (!is.null(max_value)) raw <- min(as.integer(max_value), raw)
  as.integer(raw)
}

validate_grid <- function(n_items, rows, cols) {
  n_items <- coerce_grid_value(n_items, default = 1L)
  rows <- coerce_grid_value(rows, default = 1L)
  cols <- coerce_grid_value(cols, default = 1L)

  too_small <- rows * cols < n_items
  empty_row <- n_items <= (rows - 1L) * cols
  empty_col <- n_items <= rows * (cols - 1L)

  if (too_small) {
    return(list(
      valid = FALSE,
      message = sprintf("âš ï¸ Grid %dx%d too small for %d subplots.", rows, cols, n_items)
    ))
  }

  if (empty_row || empty_col) {
    return(list(
      valid = FALSE,
      message = sprintf("âš ï¸ Grid %dx%d too large for %d subplots.", rows, cols, n_items)
    ))
  }

  list(valid = TRUE, message = NULL)
}

basic_grid_layout <- function(rows = NULL,
                              cols = NULL,
                              default_rows = 1L,
                              default_cols = 1L,
                              min_rows = 1L,
                              min_cols = 1L,
                              max_rows = 10L,
                              max_cols = 10L) {
  list(
    nrow = coerce_grid_value(rows, default_rows, min_rows, max_rows),
    ncol = coerce_grid_value(cols, default_cols, min_cols, max_cols)
  )
}

apply_grid_defaults_if_empty <- function(input, session, grid_id, defaults, n_items = NULL) {
  if (is.null(defaults) || !is.list(defaults)) return()

  rows_default <- suppressWarnings(as.integer(defaults$rows[1]))
  cols_default <- suppressWarnings(as.integer(defaults$cols[1]))

  if (any(!is.finite(c(rows_default, cols_default)))) return()

  rows_id <- paste0(grid_id, "-rows")
  cols_id <- paste0(grid_id, "-cols")

  current_rows <- isolate(input[[rows_id]])
  current_cols <- isolate(input[[cols_id]])

  needs_reset <- function(value) {
    if (length(value) == 0) return(TRUE)
    v <- suppressWarnings(as.integer(value[1]))
    is.na(v)
  }

  reset_rows <- needs_reset(current_rows)
  reset_cols <- needs_reset(current_cols)

  if (reset_rows) {
    updateNumericInput(session, rows_id, value = rows_default)
  }

  if (reset_cols) {
    updateNumericInput(session, cols_id, value = cols_default)
  }
}

adjust_grid_layout <- function(n_items, layout) {
  if (is.null(layout) || length(layout) == 0) {
    layout <- list(nrow = 1L, ncol = 1L)
  }

  n_items <- coerce_grid_value(n_items, default = 1L)
  rows <- coerce_grid_value(layout$nrow, default = 1L)
  cols <- coerce_grid_value(layout$ncol, default = 1L)

  if (rows * cols < n_items) {
    defaults <- compute_default_grid(n_items)
    rows <- defaults$rows
    cols <- defaults$cols
  }

  while (rows > 1L && n_items <= (rows - 1L) * cols) {
    rows <- rows - 1L
  }

  while (cols > 1L && n_items <= rows * (cols - 1L)) {
    cols <- cols - 1L
  }

  list(nrow = rows, ncol = cols)
}

plot_grid_ui <- function(id,
                         rows_label = "Grid rows",
                         cols_label = "Grid columns",
                         rows_help = NULL,
                         cols_help = NULL,
                         rows_min = 1L,
                         rows_max = 10L,
                         cols_min = 1L,
                         cols_max = 10L,
                         rows_value = NA,
                         cols_value = NA) {
  ns <- NS(id)
  
  rows_input <- numericInput(
    ns("rows"),
    label = rows_label,
    value = rows_value,
    min = rows_min,
    max = rows_max,
    step = 1
  )
  
  cols_input <- numericInput(
    ns("cols"),
    label = cols_label,
    value = cols_value,
    min = cols_min,
    max = cols_max,
    step = 1
  )
  
  if (!is.null(rows_help)) rows_input <- with_help_tooltip(rows_input, rows_help)
  if (!is.null(cols_help)) cols_input <- with_help_tooltip(cols_input, cols_help)
  
  tagList(
    fluidRow(
      column(6, rows_input),
      column(6, cols_input)
    )
  )
}

plot_grid_server <- function(id,
                             rows_min = 1L,
                             rows_max = 10L,
                             cols_min = 1L,
                             cols_max = 10L) {
  moduleServer(id, function(input, output, session) {
    sanitize <- function(x, min_value, max_value) {
      if (length(x) == 0) return(NA_integer_)
      v <- suppressWarnings(as.integer(x[1]))
      if (is.na(v)) return(NA_integer_)
      v <- max(as.integer(min_value), v)
      v <- min(as.integer(max_value), v)
      as.integer(v)
    }
    
    rows_raw <- reactive(sanitize(input$rows, rows_min, rows_max))
    cols_raw <- reactive(sanitize(input$cols, cols_min, cols_max))
    
    rows <- reactive(rows_raw())
    cols <- reactive(cols_raw())
    
    list(
      rows = rows,
      cols = cols,
      values = reactive(list(rows = rows(), cols = cols()))
    )
  })
}
# ===============================================================
# ðŸ§­ Stratification helpers (shared across analysis modules)
# ===============================================================

MAX_STRATIFICATION_LEVELS <- 10

stratification_ui <- function(id, ns = NULL) {
  ns_fn <- if (is.null(ns)) {
    NS(id)
  } else if (is.function(ns)) {
    function(x) ns(paste(id, x, sep = "-"))
  } else {
    NS(id)
  }
  
  tagList(
    uiOutput(ns_fn("stratify_var_ui")),
    uiOutput(ns_fn("strata_order_ui"))
  )
}

stratification_server <- function(id, data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    df <- reactive({
      d <- if (is.function(data)) data() else data
      req(is.data.frame(d))
      validate(need(nrow(d) > 0, "No data available for stratification."))
      d
    })
    
    # ---- UI: variable selector ----
    output$stratify_var_ui <- renderUI({
      d <- req(df())
      cat_cols <- names(d)[vapply(d, function(x) is.factor(x) || is.character(x), logical(1))]
      with_help_tooltip(
        selectInput(
          ns("stratify_var"),
          "Stratify by",
          choices = c("None", cat_cols),
          selected = "None"
        ),
        "Pick a categorical variable if you want separate summaries for each group."
      )
    })
    
    # ---- UI: order/levels selector ----
    output$strata_order_ui <- renderUI({
      req(input$stratify_var)
      if (input$stratify_var == "None") return(NULL)
      d <- req(df())
      
      values <- d[[input$stratify_var]]
      available_levels <- resolve_order_levels(values)
      
      n_levels <- length(available_levels)
      validate(need(n_levels <= MAX_STRATIFICATION_LEVELS,
                    sprintf("'%s' has too many levels (%d > %d).",
                            input$stratify_var, n_levels, MAX_STRATIFICATION_LEVELS)))
      
      with_help_tooltip(
        selectInput(
          ns("strata_order"),
          "Order of levels",
          choices = available_levels,
          selected = available_levels,
          multiple = TRUE
        ),
        "Decide which group levels to include and in what order they should appear."
      )
    })
    
    # ---- Unified reactive output ----
    reactive({
      list(
        var = if (identical(input$stratify_var, "None")) NULL else input$stratify_var,
        levels = input$strata_order
      )
    })
  })
}
  

# ===============================================================
# ðŸ“ Submodule â€” Subplot Size Controls
# ===============================================================

subplot_size_defaults <- function() {
  list(
    width = list(
      label = "Subplot width (px)",
      value = 400,
      min = 200,
      max = 2000,
      step = 50,
      help = "Adjust how wide each subplot should be in pixels."
    ),
    height = list(
      label = "Subplot height (px)",
      value = 300,
      min = 200,
      max = 2000,
      step = 50,
      help = "Adjust how tall each subplot should be in pixels."
    )
  )
}

subplot_size_ui <- function(
    ns,
    width_value = NULL,
    height_value = NULL,
    width_help = NULL,
    height_help = NULL,
    width_label = NULL,
    height_label = NULL,
    width_id = "plot_width",
    height_id = "plot_height") {
  defaults <- subplot_size_defaults()

  width_value  <- if (is.null(width_value)) defaults$width$value else width_value
  height_value <- if (is.null(height_value)) defaults$height$value else height_value
  width_help   <- if (is.null(width_help)) defaults$width$help else width_help
  height_help  <- if (is.null(height_help)) defaults$height$help else height_help
  width_label  <- if (is.null(width_label)) defaults$width$label else width_label
  height_label <- if (is.null(height_label)) defaults$height$label else height_label

  fluidRow(
    column(6, with_help_tooltip(
      numericInput(
        ns(width_id),
        width_label,
        value = width_value,
        min = defaults$width$min,
        max = defaults$width$max,
        step = defaults$width$step
      ),
      width_help
    )),
    column(6, with_help_tooltip(
      numericInput(
        ns(height_id),
        height_label,
        value = height_value,
        min = defaults$height$min,
        max = defaults$height$max,
        step = defaults$height$step
      ),
      height_help
    ))
  )
}
# ===============================================================
# ðŸŽ¨ Shared plot theming utilities
# ===============================================================

# Consistent minimalist theme for Table Analyzer plots.
ta_plot_theme <- function(base_size = 12) {
  ggplot2::theme_minimal(base_size = base_size) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold", color = "#1f2d3d"),
      plot.subtitle = ggplot2::element_text(color = "#4b5563"),
      plot.caption = ggplot2::element_text(color = "#6b7280", size = ggplot2::rel(0.85)),
      axis.title = ggplot2::element_text(face = "plain", color = "#111827"),
      axis.text = ggplot2::element_text(color = "#1f2937"),
      panel.grid.major = ggplot2::element_line(color = "#e5e7eb"),
      panel.grid.minor = ggplot2::element_blank(),
      strip.background = ggplot2::element_rect(fill = "#e5ecf6", color = NA),
      strip.text = ggplot2::element_text(face = "bold", color = "#111827"),
      legend.title = ggplot2::element_text(face = "plain"),
      legend.background = ggplot2::element_rect(fill = "white", color = NA)
    )
}

# Theme for plots that intentionally hide axes while keeping typographic harmony.
ta_plot_theme_void <- function(base_size = 12) {
  ggplot2::theme_void(base_size = base_size) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold", color = "#1f2d3d"),
      plot.subtitle = ggplot2::element_text(color = "#4b5563"),
      plot.caption = ggplot2::element_text(color = "#6b7280", size = ggplot2::rel(0.85)),
      strip.text = ggplot2::element_text(face = "bold", color = "#111827"),
      legend.title = ggplot2::element_text(face = "plain"),
      legend.background = ggplot2::element_rect(fill = "white", color = NA)
    )
}
