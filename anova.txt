# ===============================================================
# ðŸ§ª Table Analyzer â€” One-way ANOVA Module (Validated Version)
# ===============================================================

one_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(
          6,
          with_help_tooltip(
            actionButton(ns("run"), "Show results", width = "100%"),
            "Run the ANOVA using the selected response and group variable."
          )
        ),
        column(
          6,
          with_help_tooltip(
            downloadButton(ns("download_all"), "Download results", style = "width: 100%;"),
            "Export the ANOVA summaries, post-hoc tests, and diagnostics."
          )
        )
      )
    ),
    results = uiOutput(ns("summary_ui"))
  )
}

one_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    responses <- multi_response_server("response", filtered_data)
    strat_info <- stratification_server("strat", filtered_data)
    
    # -----------------------------------------------------
    # UI inputs
    # -----------------------------------------------------
    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      
      cat_cols <- names(data)[sapply(data, is.factor) | sapply(data, is.character)]
      
      validate(
        need(length(cat_cols) > 0,
             "No categorical predictors found. At least one factor or character variable is required.")
      )
      
      tagList(
        multi_response_ui(ns("response")),
        with_help_tooltip(
          selectInput(
            ns("group"),
            "Categorical predictor",
            choices = cat_cols,
            selected = cat_cols[1]
          ),
          "Choose the grouping variable that defines the comparison categories."
        )
      )
    })
    
    # -----------------------------------------------------
    # Order of levels
    # -----------------------------------------------------
    output$level_order <- renderUI({
      req(filtered_data(), input$group)
      levels <- resolve_order_levels(filtered_data()[[input$group]])
      
      with_help_tooltip(
        selectInput(
          ns("order"),
          "Order of levels (first = reference)",
          choices = levels,
          selected = levels,
          multiple = TRUE
        ),
        "Arrange the group levels; the first level is used as the reference in outputs."
      )
    })
    
    # -----------------------------------------------------
    # Run models
    # -----------------------------------------------------
    models <- eventReactive(input$run, {
      df <- filtered_data()
      req(df, input$group, input$order)
      
      resp_vals <- responses()
      
      # ------------------------
      # Validations
      # ------------------------
      
      validate(
        need(length(resp_vals) > 0,
             "Select at least one response variable.")
      )
      
      validate(
        need(all(sapply(df[resp_vals], is.numeric)),
             "All selected response variables must be numeric.")
      )
      
      # Response variance
      for (r in resp_vals) {
        validate(
          need(stats::var(df[[r]], na.rm = TRUE) > 0,
               paste("Response", r, "has zero variance and cannot be analyzed."))
        )
      }
      
      # Group must have >= 2 levels
      grp <- df[[input$group]]
      validate(
        need(dplyr::n_distinct(grp) > 1,
             "The categorical predictor must contain at least two distinct levels.")
      )
      
      # Order must have >= 2 items
      validate(
        need(length(input$order) > 1,
             "The order list must contain at least two levels.")
      )
      
      # Order must match data
      actual_levels <- unique(grp)
      missing_levels <- setdiff(input$order, actual_levels)
      validate(
        need(length(missing_levels) == 0,
             paste("Some selected levels are not present in the filtered data:",
                   paste(missing_levels, collapse = ", ")))
      )
      
      # Stratification checks
      if (!is.null(strat_info()$active) && strat_info()$active) {
        s_info <- strat_info()
        
        for (lev in s_info$levels) {
          sub_df <- df[df[[s_info$var]] == lev, ]
          
          k <- dplyr::n_distinct(sub_df[[input$group]])
          validate(
            need(k > 1,
                 paste0("Stratum '", lev,
                        "' contains less than two levels of the grouping variable."))
          )
        }
      }
      
      # -----------------------------------------------------
      # Run the main stratified ANOVA preparation
      # -----------------------------------------------------
      prepare_stratified_anova(
        df = df,
        responses = resp_vals,
        model = "oneway_anova",
        factor1_var = input$group,
        factor1_order = input$order,
        stratification = strat_info()
      )
    })
    
    # -----------------------------------------------------
    # Download handler
    # -----------------------------------------------------
    output$download_all <- downloadHandler(
      filename = function() {
        info <- models()
        n_resp <- length(info$responses)
        n_strata <- length(info$strata$levels %||% NULL)
        label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        paste0("anova_results_", n_resp, "resp_", label, "_",
               format(Sys.time(), "%Y%m%d-%H%M"), ".docx")
      },
      content = function(file) download_all_anova_results(models(), file)
    )
    
    # -----------------------------------------------------
    # Summary UI
    # -----------------------------------------------------
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "One-way ANOVA")
    })
    
    # Forwarding other outputs
    bind_anova_outputs(ns, output, models)
    
    # -----------------------------------------------------
    # Exportable ANOVA results object
    # -----------------------------------------------------
    anova_results <- reactive({
      mod <- models()
      req(mod)
      res <- compile_anova_results(mod)
      
      list(
        analysis_type = "ANOVA",
        type = "oneway_anova",
        data_used = mod$data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = list(
          n = nrow(mod$data_used),
          vars = names(mod$data_used)
        ),
        errors = res$errors,
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })
    
    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” One-way ANOVA (Apply-button version)
# ===============================================================

visualize_oneway_ui <- function(id) {
  ns <- NS(id)
  
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize one-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      
      selectInput(
        ns("plot_type"),
        label = "Select visualization type",
        choices = c(
          "Lineplots (mean Â± SE)" = "lineplot_mean_se",
          "Barplots (mean Â± SE)"  = "barplot_mean_se"
        ),
        selected = "lineplot_mean_se"
      ),
      
      conditionalPanel(
        condition = sprintf("input['%s'] === 'lineplot_mean_se'", ns("plot_type")),
        fluidRow(
          column(6, checkboxInput(ns("lineplot_show_lines"),  "Connect means with lines", value = TRUE)),
          column(6, checkboxInput(ns("lineplot_show_jitter"), "Overlay jittered data",  value = FALSE))
        )
      ),
      
      checkboxInput(
        ns("share_y_axis"),
        "Use common y-axis across plots",
        value = FALSE
      ),
      
      subplot_size_ui(ns),
      uiOutput(ns("layout_controls")),
      
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = FALSE)),
        column(6, base_size_ui(ns, default = 13))
      ),
      
      br(),
      
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"))
      )
    ),
    
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}


visualize_oneway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL,
      plot_width = NULL,
      plot_height = NULL
    )
    
    df <- reactive(filtered_data())
    
    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = reactive(NULL),
      multi_group = FALSE
    )
    
    base_size <- base_size_server(input = input, default = 14)
    
    strata_grid <- plot_grid_server("strata_grid")
    response_grid <- plot_grid_server("response_grid")
    
    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })
    
    observeEvent(input$apply_plot, {
      data <- df()
      info <- model_info()
      
      stored$plot_width  <- input$plot_width  %||% 600
      stored$plot_height <- input$plot_height %||% 600
      
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data or ANOVA results available."
        stored$plot <- NULL
        stored$layout <- NULL
        return()
      }
      
      has_strata <- !is.null(info$strata) && !is.null(info$strata$levels)
      n_strata <- if (has_strata) length(info$strata$levels) else 1L
      
      responses <- info$responses
      n_responses <- if (!is.null(responses) && length(responses) > 0L) length(responses) else 1L
      
      layout_inputs <- list(
        strata_rows = strata_grid$rows(),
        strata_cols = strata_grid$cols(),
        resp_rows   = response_grid$rows(),
        resp_cols   = response_grid$cols()
      )
      
      results <- list(
        lineplot_mean_se = plot_anova_lineplot_meanse(
          data,
          info,
          layout_values = layout_inputs,
          line_colors   = custom_colors(),
          base_size     = base_size(),
          show_lines    = input$lineplot_show_lines,
          show_jitter   = input$lineplot_show_jitter,
          share_y_axis  = input$share_y_axis
        ),
        barplot_mean_se = plot_anova_barplot_meanse(
          data,
          info,
          layout_values = layout_inputs,
          line_colors   = custom_colors(),
          base_size     = base_size(),
          posthoc_all   = info$posthoc,
          share_y_axis  = input$share_y_axis
        )
      )
      
      chosen <- input$plot_type
      chosen_result <- results[[chosen]]
      
      stored$warning <- chosen_result$warning
      stored$plot    <- chosen_result$plot
      stored$layout  <- chosen_result$layout
    })
    
    output$plot_warning <- renderUI({
      if (!is.null(stored$warning)) {
        div(class = "alert alert-warning", HTML(stored$warning))
      }
    })
    
    output$plot <- renderPlot(
      {
        p <- stored$plot
        if (is.null(p)) return(NULL)
        print(p)
      },
      width = function() {
        lay <- stored$layout
        if (is.null(lay)) return(600)
        
        cols_strata    <- lay$strata$cols %||% 1
        cols_responses <- lay$responses$cols %||% 1
        
        (stored$plot_width %||% 600) * cols_strata * cols_responses
      },
      height = function() {
        lay <- stored$layout
        if (is.null(lay)) return(600)
        
        rows_strata    <- lay$strata$rows %||% 1
        rows_responses <- lay$responses$rows %||% 1
        
        (stored$plot_height %||% 600) * rows_strata * rows_responses
      },
      res = 96
    )
    
    output$download_plot <- downloadHandler(
      filename = function() {
        paste0("anova_plot_", Sys.Date(), ".png")
      },
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        req(!is.null(lay))
        
        cols_strata    <- lay$strata$cols %||% 1
        cols_responses <- lay$responses$cols %||% 1
        rows_strata    <- lay$strata$rows %||% 1
        rows_responses <- lay$responses$rows %||% 1
        
        total_cols <- cols_strata * cols_responses
        total_rows <- rows_strata * rows_responses
        
        w_in <- ((stored$plot_width  %||% 600) * total_cols) / 96
        h_in <- ((stored$plot_height %||% 600) * total_rows) / 96
        
        ggsave(
          filename = file,
          plot = p,
          dpi = 300,
          width = w_in,
          height = h_in,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}
#### Section: Barplot Construction ####

plot_anova_barplot_meanse <- function(data,
                                      info,
                                      layout_values = list(),
                                      line_colors = NULL,
                                      base_size = 14,
                                      posthoc_all = NULL,
                                      share_y_axis = FALSE,
                                      common_legend = FALSE,
                                      legend_position = NULL) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2

  allowed_positions <- c("bottom", "top", "left", "right")
  legend_position_value <- if (!is.null(legend_position) && legend_position %in% allowed_positions) legend_position else "bottom"

  if (is.null(factor1) || length(context$responses) == 0) {
    return(NULL)
  }

  shared_y_limits <- if (isTRUE(share_y_axis)) {
    compute_barplot_shared_limits(
      context,
      data,
      factor1,
      factor2,
      posthoc_all
    )
  } else {
    NULL
  }
  
  base_fill <- if (!is.null(line_colors) && length(line_colors) > 0) unname(line_colors)[1] else "#3E8FC4"

  response_results <- lapply(
    context$responses,
    function(resp) {
      build_response_barplot(
        resp = resp,
        context = context,
        data = data,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_fill = base_fill,
        base_size = base_size,
        shared_y_limits = shared_y_limits,
        posthoc_all = posthoc_all
      )
    }
  )

  strata_panel_count <- max(
    context$initial_strata_panels,
    vapply(response_results, function(x) x$strata_panels, integer(1))
  )

  response_plots <- lapply(response_results, `[[`, "plot")
  names(response_plots) <- context$responses
  response_plots <- Filter(Negate(is.null), response_plots)

  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = isTRUE(common_legend),
    legend_position = if (isTRUE(common_legend)) legend_position_value else NULL
  )
}

compute_barplot_shared_limits <- function(context,
                                          data,
                                          factor1,
                                          factor2,
                                          posthoc_all = NULL) {
  combined <- NULL

  for (resp in context$responses) {
    posthoc_entry <- get_posthoc_entry_for_response(posthoc_all, resp)
    stats_entries <- generate_anova_stats_entries(
      context = context,
      data = data,
      resp = resp,
      factor1 = factor1,
      factor2 = factor2,
      posthoc_entry = posthoc_entry
    )

    for (entry in stats_entries) {
      rng <- compute_barplot_panel_range(
        entry$stats_df,
        factor1,
        factor2,
        posthoc_entry = entry$posthoc,
        nested_posthoc = entry$posthoc
      )
      combined <- update_numeric_range(combined, rng)
    }
  }

  if (is.null(combined)) return(NULL)
  
  limits <- expand_axis_limits(combined, lower_mult = 0.05, upper_mult = 0.12)
  ensure_barplot_zero_baseline(limits)
}

compute_barplot_panel_range <- function(stats_df,
                                        factor1,
                                       factor2,
                                       posthoc_entry = NULL,
                                       nested_posthoc = NULL) {
  if (is.null(stats_df) || nrow(stats_df) == 0) return(NULL)
  values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
  values <- values[is.finite(values)]
  if (length(values) == 0) return(NULL)
  range(values)
}

expand_axis_limits <- function(range_vals, lower_mult = 0.05, upper_mult = 0.12) {
  if (is.null(range_vals) || length(range_vals) != 2 || any(!is.finite(range_vals))) return(range_vals)
  span <- diff(range_vals)
  if (!is.finite(span) || span == 0) span <- max(1, abs(range_vals[2]))
  c(range_vals[1] - span * lower_mult, range_vals[2] + span * upper_mult)
}

ensure_barplot_zero_baseline <- function(range_vals) {
  if (is.null(range_vals) || length(range_vals) != 2 || any(!is.finite(range_vals))) {
    return(range_vals)
  }

  if (!is.na(range_vals[1])) range_vals[1] <- 0
  range_vals
}

get_posthoc_entry_for_response <- function(posthoc_all, resp) {
  if (is.null(posthoc_all) || is.null(posthoc_all[[resp]])) return(NULL)
  posthoc_all[[resp]]
}

build_response_barplot <- function(resp,
                                   context,
                                   data,
                                   factor1,
                                   factor2,
                                   line_colors,
                                   base_fill,
                                   base_size,
                                   shared_y_limits,
                                   posthoc_all) {
  posthoc_entry <- get_posthoc_entry_for_response(posthoc_all, resp)
  stats_entries <- generate_anova_stats_entries(
    context = context,
    data = data,
    resp = resp,
    factor1 = factor1,
    factor2 = factor2,
    posthoc_entry = posthoc_entry
  )

  has_strata <- context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)
  if (has_strata) {
    stratum_plots <- lapply(stats_entries, function(entry) {
      build_bar_plot_panel(
        stats_df = entry$stats_df,
        title_text = entry$label,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_fill = base_fill,
        base_size = base_size,
        posthoc_entry = entry$posthoc,
        nested_posthoc = entry$posthoc,
        y_limits = shared_y_limits,
        response_var = resp
      )
    })
    names(stratum_plots) <- vapply(stats_entries, function(x) x$label, character(1))
    stratum_plots <- Filter(Negate(is.null), stratum_plots)

    if (!length(stratum_plots)) {
      return(list(plot = NULL, strata_panels = 0L))
    }

    return(list(
      plot = patchwork::wrap_plots(
        plotlist = stratum_plots,
        nrow = context$strata_layout$nrow,
        ncol = context$strata_layout$ncol
      ),
      strata_panels = length(stratum_plots)
    ))
  }

  if (length(stats_entries) > 0) {
    entry <- stats_entries[[1]]
    return(list(
      plot = build_bar_plot_panel(
        stats_df = entry$stats_df,
        title_text = "",
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_fill = base_fill,
        base_size = base_size,
        posthoc_entry = entry$posthoc,
        nested_posthoc = entry$posthoc,
        y_limits = shared_y_limits,
        response_var = resp
      ),
      strata_panels = 0L
    ))
  }

  list(plot = NULL, strata_panels = 0L)
}

generate_anova_stats_entries <- function(context,
                                         data,
                                         resp,
                                         factor1,
                                         factor2,
                                         posthoc_entry) {
  entries <- list()
  has_strata <- context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)

  if (has_strata) {
    for (stratum in context$strata_levels) {
      subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
      subset_data <- data[subset_rows, , drop = FALSE]
      if (nrow(subset_data) == 0) next

      stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) next

      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)

      stratum_posthoc <- NULL
      if (!is.null(posthoc_entry) && !is.null(posthoc_entry[[stratum]])) {
        stratum_posthoc <- posthoc_entry[[stratum]]
      }

      entries[[length(entries) + 1]] <- list(
        label = stratum,
        stats_df = stats_df,
        posthoc = stratum_posthoc
      )
    }
  } else {
    stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
    if (nrow(stats_df) == 0) return(entries)

    stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)

    entries[[1]] <- list(
      label = resp,
      stats_df = stats_df,
      posthoc = posthoc_entry
    )
  }

  entries
}

build_bar_plot_panel <- function(stats_df,
                                 title_text,
                                 factor1,
                                 factor2,
                                 line_colors,
                                 base_fill,
                                 base_size = 14,
                                 posthoc_entry = NULL,
                                 nested_posthoc = NULL,
                                 y_limits = NULL,
                                 response_var = NULL) {
  if (is.null(y_limits)) {
    panel_range <- compute_barplot_panel_range(
      stats_df,
      factor1,
      factor2,
      posthoc_entry = posthoc_entry,
      nested_posthoc = nested_posthoc
    )
    
    if (!is.null(panel_range)) {
      y_limits <- expand_axis_limits(panel_range, lower_mult = 0, upper_mult = 0.12)
      y_limits <- ensure_barplot_zero_baseline(y_limits)
    }
  }
  
  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    return(
      build_single_factor_barplot(
        stats_df = stats_df,
        title_text = title_text,
        factor1 = factor1,
        base_fill = base_fill,
        base_size = base_size,
        posthoc_entry = posthoc_entry,
        y_limits = y_limits,
        response_var = response_var
      )
    )
  }
  
  build_two_factor_barplot(
    stats_df = stats_df,
    title_text = title_text,
    factor1 = factor1,
    factor2 = factor2,
    line_colors = line_colors,
    base_fill = base_fill,
    base_size = base_size,
    nested_posthoc = nested_posthoc,
    y_limits = y_limits,
    response_var = response_var
  )
}

build_single_factor_barplot <- function(stats_df,
                                        title_text,
                                        factor1,
                                        base_fill,
                                        base_size,
                                        posthoc_entry,
                                        y_limits = NULL,
                                        response_var = NULL) {
  plot_obj <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean)) +
    geom_col(fill = base_fill, width = 0.6, alpha = 0.8) +
    geom_errorbar(
      aes(ymin = mean - se, ymax = mean + se),
      width = 0.15,
      color = "gray40",
      linewidth = 0.5
    ) +
    ta_plot_theme(base_size = base_size) +
    labs(
      x = factor1,
      y = if (!is.null(response_var)) response_var else "Mean Â± SE",
      title = title_text
    ) +
    theme(
      plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
      axis.title.x = element_text(margin = margin(t = 6)),
      axis.title.y = element_text(margin = margin(r = 6)),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af")
    )
  
  plot_obj <- add_significance_after_build(
    p = plot_obj,
    stats_df = stats_df,
    factor1 = factor1,
    factor2 = NULL,
    posthoc_entry = posthoc_entry
  )
  
  plot_obj
}

build_two_factor_barplot <- function(stats_df,
                                     title_text,
                                     factor1,
                                     factor2,
                                     line_colors,
                                     base_fill,
                                     base_size,
                                     nested_posthoc = NULL,
                                     y_limits = NULL,
                                     response_var = NULL) {
  group_levels <- if (is.factor(stats_df[[factor2]])) {
    levels(stats_df[[factor2]])
  } else {
    unique(as.character(stats_df[[factor2]]))
  }
  group_levels <- group_levels[!is.na(group_levels)]
  palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
  dodge <- position_dodge(width = 0.7)
  
  plot_obj <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean, fill = !!sym(factor2))) +
    geom_col(position = dodge, width = 0.6, alpha = 0.85) +
    geom_errorbar(
      aes(ymin = mean - se, ymax = mean + se),
      position = dodge,
      width = 0.2,
      color = "gray40",
      linewidth = 0.5
    ) +
    ta_plot_theme(base_size = base_size) +
    labs(
      x = factor1,
      y = if (!is.null(response_var)) response_var else "Mean Â± SE",
      fill = factor2,
      title = title_text
    ) +
    theme(
      plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
      axis.title.x = element_text(margin = margin(t = 6)),
      axis.title.y = element_text(margin = margin(r = 6)),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af")
    ) +
    scale_fill_manual(values = palette)
  
  plot_obj <- add_significance_after_build(
    p = plot_obj,
    stats_df = stats_df,
    factor1 = factor1,
    factor2 = factor2,
    posthoc_entry = nested_posthoc
  )
  
  plot_obj
}

#### Section: Significance Annotation System (ggplot_build-based) ####

extract_bar_positions <- function(p, factor1, factor2 = NULL) {
  built <- ggplot_build(p)
  layer <- built$data[[1]]
  original <- built$plot$data
  
  y_top <- if ("ymax" %in% names(layer)) layer$ymax else layer$y
  
  df <- data.frame(
    x = layer$x,
    y = y_top
  )
  
  df[[factor1]] <- as.character(original[[factor1]])
  
  if (!is.null(factor2)) {
    df[[factor2]] <- as.character(original[[factor2]])
  }
  
  df
}

clean_p_values_barplot <- function(x) {
  x <- as.character(x)
  x <- gsub("[[:space:]]", "", x)
  x <- gsub("^<\\.?0*", "0.", x)
  suppressWarnings(as.numeric(x))
}


# One-way annotation builder
build_annotations_single_factor <- function(barpos,
                                            posthoc_entry,
                                            factor1,
                                            stats_df,
                                            offset_mult = 0.5) {
  
  if (is.null(posthoc_entry) || nrow(posthoc_entry) == 0) return(NULL)
  
  # --- CLEAN bar levels (remove parentheses) ---
  levels_f1 <- gsub("[()]", "", unique(as.character(barpos[[factor1]])))
  if (length(levels_f1) < 2) return(NULL)
  reference <- levels_f1[1]
  
  # --- CLEAN posthoc contrast labels ---
  posthoc_entry <- posthoc_entry |>
    dplyr::mutate(
      p.value = clean_p_values_barplot(.data$p.value),
      contrast_clean = gsub("[()]", "", .data$contrast)
    ) |>
    dplyr::filter(!is.na(.data$p.value))
  
  if (nrow(posthoc_entry) == 0) return(NULL)
  
  res <- list()
  idx <- 0L
  
  for (lvl in levels_f1[-1]) {
    
    contrasts <- c(
      paste0(lvl, " - ", reference),
      paste0(reference, " - ", lvl)
    )
    
    # --- match using cleaned labels ---
    row <- posthoc_entry[posthoc_entry$contrast_clean %in% contrasts, , drop = FALSE]
    if (nrow(row) == 0) next
    
    p <- row$p.value[1]
    if (is.na(p) || p >= 0.05) next
    
    label <- if (p < 0.001) "***" else if (p < 0.01) "**" else "*"
    
    # --- match bar position (also cleaned) ---
    bar_row <- barpos[gsub("[()]", "", as.character(barpos[[factor1]])) == lvl, , drop = FALSE]
    if (nrow(bar_row) == 0) next
    
    mean_val <- stats_df$mean[gsub("[()]", "", as.character(stats_df[[factor1]])) == lvl]
    se_val   <- stats_df$se[gsub("[()]", "", as.character(stats_df[[factor1]])) == lvl]
    
    # --- label above SE ---
    y_ann <- (mean_val + se_val) + se_val * offset_mult
    
    idx <- idx + 1L
    res[[idx]] <- data.frame(
      x = bar_row$x[1],
      y = y_ann,
      label = label
    )
  }
  
  if (length(res) == 0) return(NULL)
  do.call(rbind, res)
}

# Two-way annotation builder
build_annotations_two_factor <- function(barpos,
                                         nested_posthoc,
                                         factor1,
                                         factor2,
                                         stats_df,
                                         offset_mult = 0.5) {
  
  if (is.null(nested_posthoc) || !is.data.frame(nested_posthoc)) return(NULL)
  needed <- c("contrast", "p.value", factor1)
  if (!all(needed %in% names(nested_posthoc))) return(NULL)
  
  df <- nested_posthoc
  df$contrast_clean <- gsub("[()]", "", df$contrast)
  df$p.value <- clean_p_values_barplot(df$p.value)
  df <- df[is.finite(df$p.value), , drop = FALSE]
  if (nrow(df) == 0) return(NULL)
  
  lev1 <- unique(as.character(barpos[[factor1]]))
  lev2 <- unique(as.character(barpos[[factor2]]))
  if (length(lev2) < 2) return(NULL)
  
  reference <- lev2[1]
  
  res <- list()
  idx <- 0L
  
  for (g1 in lev1) {
    for (lvl in lev2[lev2 != reference]) {
      
      lvl_clean <- gsub("[()]", "", lvl)
      ref_clean <- gsub("[()]", "", reference)
      
      ct1 <- paste0(lvl_clean, " - ", ref_clean)
      ct2 <- paste0(ref_clean, " - ", lvl_clean)
      
      sub <- df[
        as.character(df[[factor1]]) == g1 &
          df$contrast_clean %in% c(ct1, ct2),
        ,
        drop = FALSE
      ]
      
      if (nrow(sub) == 0) next
      
      p <- sub$p.value[1]
      if (is.na(p) || p >= 0.05) next
      
      label <- if (p < 0.001) "***" else if (p < 0.01) "**" else "*"
      
      bar_row <- barpos[
        as.character(barpos[[factor1]]) == g1 &
          as.character(barpos[[factor2]]) == lvl,
        ,
        drop = FALSE
      ]
      if (nrow(bar_row) == 0) next
      
      mean_val <- stats_df$mean[
        stats_df[[factor1]] == g1 & stats_df[[factor2]] == lvl
      ]
      se_val <- stats_df$se[
        stats_df[[factor1]] == g1 & stats_df[[factor2]] == lvl
      ]
      
      y_ann <- (mean_val + se_val) + se_val * offset_mult
      
      idx <- idx + 1L
      res[[idx]] <- data.frame(
        x = bar_row$x[1],
        y = y_ann,
        label = label
      )
    }
  }
  
  if (length(res) == 0) return(NULL)
  do.call(rbind, res)
}


# Attach significance after building the plot
add_significance_after_build <- function(p,
                                         stats_df,
                                         factor1,
                                         factor2 = NULL,
                                         posthoc_entry = NULL,
                                         text_size = 4) {
  
  if (is.null(posthoc_entry)) return(p)
  
  barpos <- extract_bar_positions(p, factor1, factor2)
  barpos <- barpos[is.finite(barpos$y), , drop = FALSE]
  if (nrow(barpos) == 0) return(p)
  
  if (is.null(factor2)) {
    ann <- build_annotations_single_factor(
      barpos = barpos,
      posthoc_entry = posthoc_entry,
      factor1 = factor1,
      stats_df = stats_df
    )
  } else {
    ann <- build_annotations_two_factor(
      barpos = barpos,
      nested_posthoc = posthoc_entry,
      factor1 = factor1,
      factor2 = factor2,
      stats_df = stats_df
    )
  }
  
  if (is.null(ann) || nrow(ann) == 0) return(p)
  
  max_y <- max(ann$y, na.rm = TRUE)
  
  p_build <- ggplot_build(p)
  current_limits <- p_build$layout$panel_params[[1]]$y.range
  
  new_upper <- max(current_limits[2], max_y * 1.05)
  
  p +
    scale_y_continuous(
      limits = c(0, new_upper),
      expand = expansion(mult = c(0, 0))
    ) +
    geom_text(
      data = ann,
      aes(x = x, y = y, label = label),
      inherit.aes = FALSE,
      color = "gray30",
      size = text_size,
      fontface = "bold"
    )
}
#### Section: Summary Calculations ####

anova_summarise_stats <- function(df_subset, resp_name, factor1, factor2) {
  if (is.null(factor1) || !factor1 %in% names(df_subset)) {
    return(tibble::tibble())
  }

  if (is.null(factor2) || !factor2 %in% names(df_subset)) {
    df_subset |>
      dplyr::group_by(.data[[factor1]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  } else {
    df_subset |>
      dplyr::group_by(.data[[factor1]], .data[[factor2]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  }
}

apply_anova_factor_levels <- function(stats_df, factor1, factor2, order1, order2) {
  if (!is.null(factor1) && factor1 %in% names(stats_df)) {
    if (!is.null(order1)) {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]), levels = order1)
    } else {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]))
    }
  }

  if (!is.null(factor2) && factor2 %in% names(stats_df)) {
    levels2 <- if (!is.null(order2)) {
      order2
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = levels2)
  }

  stats_df
}
#### Section: Lineplot Construction ####

plot_anova_lineplot_meanse <- function(data,
                                       info,
                                       layout_values,
                                       line_colors = NULL,
                                       base_size = 14,
                                       show_lines = FALSE,
                                       show_jitter = FALSE,
                                       use_dodge = FALSE,
                                       share_y_axis = FALSE,
                                       common_legend = FALSE,
                                       legend_position = NULL) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2

  allowed_positions <- c("bottom", "top", "left", "right")
  legend_position_value <- if (!is.null(legend_position) && legend_position %in% allowed_positions) {
    legend_position
  } else {
    "bottom"
  }

  shared_y_limits <- if (isTRUE(share_y_axis)) {
    compute_lineplot_shared_limits(context, data, factor1, factor2)
  } else {
    NULL
  }

  response_results <- lapply(
    context$responses,
    function(resp) {
      build_response_lineplot(
        resp = resp,
        context = context,
        data = data,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_size = base_size,
        show_lines = show_lines,
        show_jitter = show_jitter,
        use_dodge = use_dodge,
        shared_y_limits = shared_y_limits,
        common_legend = common_legend
      )
    }
  )

  strata_panel_count <- max(
    context$initial_strata_panels,
    vapply(response_results, function(x) if (is.null(x$strata_panels)) 0L else x$strata_panels, integer(1))
  )

  response_plots <- lapply(response_results, `[[`, "plot")
  names(response_plots) <- context$responses
  response_plots <- Filter(Negate(is.null), response_plots)

  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = isTRUE(common_legend),
    legend_position = if (isTRUE(common_legend)) legend_position_value else NULL
  )
}

compute_lineplot_shared_limits <- function(context, data, factor1, factor2) {
  combined <- NULL

  for (resp in context$responses) {
    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      for (stratum in context$strata_levels) {
        subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
        subset_data <- data[subset_rows, , drop = FALSE]
        if (nrow(subset_data) == 0) next

        stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
        if (nrow(stats_df) == 0) next

        stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
        y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
        combined <- update_numeric_range(combined, y_values)
      }
    } else {
      stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) next
      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
      y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
      combined <- update_numeric_range(combined, y_values)
    }
  }

  if (is.null(combined) || any(!is.finite(combined))) return(NULL)
  combined
}

build_response_lineplot <- function(resp,
                                    context,
                                    data,
                                    factor1,
                                    factor2,
                                    line_colors,
                                    base_size,
                                    show_lines,
                                    show_jitter,
                                    use_dodge,
                                    shared_y_limits,
                                    common_legend) {
  has_strata <- context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)
  if (has_strata) {
    return(build_stratified_lineplot(
      resp = resp,
      context = context,
      data = data,
      factor1 = factor1,
      factor2 = factor2,
      line_colors = line_colors,
      base_size = base_size,
      show_lines = show_lines,
      show_jitter = show_jitter,
      use_dodge = use_dodge,
      shared_y_limits = shared_y_limits,
      common_legend = common_legend
    ))
  }

  build_unstratified_lineplot(
    resp = resp,
    context = context,
    data = data,
    factor1 = factor1,
    factor2 = factor2,
    line_colors = line_colors,
    base_size = base_size,
    show_lines = show_lines,
    show_jitter = show_jitter,
    use_dodge = use_dodge,
    shared_y_limits = shared_y_limits
  )
}

build_stratified_lineplot <- function(resp,
                                      context,
                                      data,
                                      factor1,
                                      factor2,
                                      line_colors,
                                      base_size,
                                      show_lines,
                                      show_jitter,
                                      use_dodge,
                                      shared_y_limits,
                                      common_legend) {
  stratum_stats <- list()
  y_values <- c()

  for (stratum in context$strata_levels) {
    subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
    subset_data <- data[subset_rows, , drop = FALSE]
    if (nrow(subset_data) == 0) {
      next
    }

    stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
    if (nrow(stats_df) == 0) {
      next
    }

    stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
    y_values <- c(y_values, stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
    stratum_stats[[stratum]] <- list(
      stats = stats_df,
      raw = prepare_lineplot_raw_data(subset_data, resp, factor1, factor2)
    )
  }

  if (length(stratum_stats) == 0) {
    return(list(plot = NULL, strata_panels = 0L))
  }

  y_limits <- range(y_values, na.rm = TRUE)
  if (!all(is.finite(y_limits))) {
    y_limits <- NULL
  }
  y_limits_to_use <- if (!is.null(shared_y_limits)) shared_y_limits else y_limits

  strata_plot_list <- lapply(names(stratum_stats), function(stratum_name) {
    entry <- stratum_stats[[stratum_name]]
    build_line_plot_panel(
      stats_df = entry$stats,
      title_text = stratum_name,
      y_limits = y_limits_to_use,
      factor1 = factor1,
      factor2 = factor2,
      line_colors = line_colors,
      base_size = base_size,
      raw_data = entry$raw,
      response_var = resp,
      show_lines = show_lines,
      show_jitter = show_jitter,
      use_dodge = use_dodge
    )
  })

  combined <- patchwork::wrap_plots(
    plotlist = strata_plot_list,
    nrow = context$strata_layout$nrow,
    ncol = context$strata_layout$ncol
  )

  if (isTRUE(common_legend)) {
    combined <- collect_guides_safe(combined)
  }

  list(plot = combined, strata_panels = length(stratum_stats))
}

build_unstratified_lineplot <- function(resp,
                                        context,
                                        data,
                                        factor1,
                                        factor2,
                                        line_colors,
                                        base_size,
                                        show_lines,
                                        show_jitter,
                                        use_dodge,
                                        shared_y_limits) {
  stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
  if (nrow(stats_df) == 0) {
    return(list(plot = NULL, strata_panels = 0L))
  }

  stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
  y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
  y_limits <- range(y_values, na.rm = TRUE)
  if (!all(is.finite(y_limits))) {
    y_limits <- NULL
  }

  y_limits_to_use <- if (!is.null(shared_y_limits)) shared_y_limits else y_limits

  list(
    plot = build_line_plot_panel(
      stats_df = stats_df,
      title_text = "",
      y_limits = y_limits_to_use,
      factor1 = factor1,
      factor2 = factor2,
      line_colors = line_colors,
      base_size = base_size,
      raw_data = prepare_lineplot_raw_data(data, resp, factor1, factor2),
      response_var = resp,
      show_lines = show_lines,
      show_jitter = show_jitter,
      use_dodge = use_dodge
    ),
    strata_panels = 0L
  )
}

prepare_lineplot_raw_data <- function(df, response_var, factor1, factor2 = NULL) {
  if (is.null(df) || is.null(response_var) || is.null(factor1)) return(NULL)
  if (!response_var %in% names(df) || !factor1 %in% names(df)) return(NULL)

  cols <- c(factor1, factor2, response_var)
  cols <- cols[!vapply(cols, is.null, FUN.VALUE = logical(1), USE.NAMES = FALSE)]
  cols <- unique(cols)
  cols <- cols[cols %in% names(df)]
  if (!response_var %in% cols || !factor1 %in% cols) return(NULL)

  raw_subset <- df[, cols, drop = FALSE]
  raw_subset <- raw_subset[!is.na(raw_subset[[response_var]]), , drop = FALSE]
  if (nrow(raw_subset) == 0) return(NULL)
  raw_subset
}

build_line_plot_panel <- function(stats_df,
                                  title_text,
                                  y_limits,
                                  factor1,
                                  factor2,
                                  line_colors,
                                  base_size = 13,
                                  raw_data = NULL,
                                  response_var = NULL,
                                  show_lines = FALSE,
                                  show_jitter = FALSE,
                                  use_dodge = FALSE) {
  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    color_value <- if (!is.null(line_colors) && length(line_colors) > 0) {
      unname(line_colors)[1]
    } else {
      resolve_single_color()
    }
    p <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean))

    if (isTRUE(show_jitter) && !is.null(raw_data) &&
        !is.null(response_var) && response_var %in% names(raw_data) &&
        factor1 %in% names(raw_data)) {
      jitter_df <- raw_data[!is.na(raw_data[[response_var]]), , drop = FALSE]
      if (nrow(jitter_df) > 0) {
        p <- p + geom_jitter(
          data = jitter_df,
          aes(x = !!sym(factor1), y = !!sym(response_var)),
          width = 0.12,
          alpha = 0.35,
          size = 1.7,
          color = color_value,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
      }
    }

    if (isTRUE(show_lines)) {
      p <- p + geom_line(aes(group = 1), color = color_value, linewidth = 1)
    }

    p <- p +
      geom_point(size = 3, color = color_value) +
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        color = color_value
      ) +
      ta_plot_theme(base_size = base_size) +
      labs(
        x = factor1,
        y = if (!is.null(response_var)) response_var else "Mean Â± SE"
      ) +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.line = element_line(color = "#9ca3af"),
        axis.ticks = element_line(color = "#9ca3af")
      )
  } else {
    group_levels <- if (is.factor(stats_df[[factor2]])) {
      levels(stats_df[[factor2]])
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    group_levels <- group_levels[!is.na(group_levels)]
    palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = group_levels)
    dodge_width <- if (isTRUE(use_dodge)) 0.4 else NULL
    dodge <- if (!is.null(dodge_width)) position_dodge(width = dodge_width) else NULL
    jitter_dodge_width <- if (is.null(dodge_width)) 0 else dodge_width
    p <- ggplot(stats_df, aes(
      x = !!sym(factor1),
      y = mean,
      color = !!sym(factor2),
      group = !!sym(factor2)
    ))

    if (isTRUE(show_jitter) && !is.null(raw_data) && !is.null(response_var) &&
        all(c(factor1, factor2) %in% names(raw_data)) &&
        response_var %in% names(raw_data)) {
      jitter_df <- raw_data[!is.na(raw_data[[response_var]]), , drop = FALSE]
      if (nrow(jitter_df) > 0) {
        jitter_df[[factor2]] <- factor(as.character(jitter_df[[factor2]]), levels = group_levels)
        p <- p + geom_jitter(
          data = jitter_df,
          aes(x = !!sym(factor1), y = !!sym(response_var), color = !!sym(factor2)),
          position = position_jitterdodge(jitter.width = 0.15, dodge.width = jitter_dodge_width),
          size = 1.6,
          alpha = 0.4,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
      }
    }

    if (isTRUE(show_lines)) {
      if (is.null(dodge)) {
        p <- p + geom_line(linewidth = 1)
      } else {
        p <- p + geom_line(linewidth = 1, position = dodge)
      }
    }

    point_layer <- if (is.null(dodge)) {
      geom_point(size = 3)
    } else {
      geom_point(size = 3, position = dodge)
    }

    errorbar_layer <- if (is.null(dodge)) {
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15
      )
    } else {
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        position = dodge
      )
    }

    p <- p +
      point_layer +
      errorbar_layer +
      ta_plot_theme(base_size = base_size) +
      labs(
        x = factor1,
        y = if (!is.null(response_var)) response_var else "Mean Â± SE",
        color = factor2
      ) +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.line = element_line(color = "#9ca3af"),
        axis.ticks = element_line(color = "#9ca3af")
      ) +
      scale_color_manual(values = palette)
  }

  if (!is.null(y_limits) && all(is.finite(y_limits))) {
    p <- p + scale_y_continuous(limits = y_limits)
  }

  if (!is.null(title_text) && nzchar(title_text)) {
    p + ggtitle(title_text) +
      theme(
        plot.title = element_text(
          size = base_size,
          face = "bold",
          hjust = 0.5
        )
      )
  } else {
    p
  }
}

#### Section: Model Fitting & Preparation ####

prepare_stratified_anova <- function(
    df,
    responses,
    model,
    factor1_var = NULL,
    factor1_order = NULL,
    factor2_var = NULL,
    factor2_order = NULL,
    stratification = NULL,
    stratify_var = NULL,
    strata_order = NULL
) {
  req(df, responses, model)

  if (!is.null(stratification)) {
    if (!is.null(stratification$var)) {
      stratify_var <- stratification$var
    }
    if (!is.null(stratification$levels)) {
      strata_order <- stratification$levels
    }
  }

  

  df <- df |>
    set_factor_levels(factor1_var, factor1_order) |>
    set_factor_levels(factor2_var, factor2_order) |>
    set_factor_levels(stratify_var, strata_order, default_factor = TRUE)

  strata <- if (!is.null(stratify_var) && stratify_var %in% names(df)) {
    levels(df[[stratify_var]])
  } else {
    NULL
  }

  factor1_rhs <- anova_protect_vars(factor1_var)
  factor2_rhs <- anova_protect_vars(factor2_var)

  rhs <- switch(
    model,
    oneway_anova = factor1_rhs,
    twoway_anova = if (length(factor1_rhs) > 0 && length(factor2_rhs) > 0) {
      paste(factor1_rhs, factor2_rhs, sep = " *")
    } else {
      factor1_rhs
    },
    factor1_rhs
  )
  rhs <- if (is.null(rhs) || rhs == "") "1" else rhs

  build_formula <- function(resp) stats::as.formula(paste(anova_protect_vars(resp), "~", rhs))
  safe_fit <- purrr::safely(function(fml, data) stats::lm(fml, data = data))

  base_info <- list(
    type = model,
    responses = responses,
    factors = list(factor1 = factor1_var, factor2 = factor2_var),
    orders = list(order1 = factor1_order, order2 = factor2_order),
    data_used = df
  )

  if (is.null(strata)) {
    return(c(base_info, list(models = fit_models_for_data(df, responses, build_formula, safe_fit), strata = NULL)))
  }

  models <- lapply(strata, function(s) {
    subset_rows <- df[[stratify_var]] == s & !is.na(df[[stratify_var]])
    fit_models_for_data(df[subset_rows, , drop=FALSE], responses, build_formula, safe_fit)
  })
  names(models) <- strata

  c(base_info, list(models = models, strata = list(var = stratify_var, levels = strata)))
}


set_factor_levels <- function(data, var, levels = NULL, default_factor = FALSE) {
  if (is.null(var) || !var %in% names(data)) return(data)
  if (!is.null(levels)) {
    data[[var]] <- factor(as.character(data[[var]]), levels = levels)
  } else if (default_factor) {
    data[[var]] <- as.factor(as.character(data[[var]]))
  }
  data
}


fit_models_for_data <- function(data, responses, build_formula, safe_fit) {
  lapply(responses, function(resp) {
    fit_result <- safe_fit(build_formula(resp), data)
    list(
      model = fit_result$result,
      error = if (!is.null(fit_result$error)) conditionMessage(fit_result$error) else NULL
    )
  }) |>
    stats::setNames(responses)
}


compile_anova_results <- function(model_info) {
  if (is.null(model_info) || is.null(model_info$models)) return(NULL)

  factor_names <- unlist(model_info$factors)
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]

  if (is.null(model_info$strata)) {
    summary_list <- list()
    posthoc_list <- list()
    effects_list <- list()
    errors_list <- list()

    for (resp in names(model_info$models)) {
      entry <- model_info$models[[resp]]
      entry_errors <- character(0)
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_errors <- c(entry_errors, outputs$error)
          summary_list[[resp]] <- NULL
          posthoc_list[[resp]] <- NULL
          effects_list[[resp]] <- NULL
        } else {
          summary_list[[resp]] <- outputs$anova_table
          posthoc_list[[resp]] <- outputs$posthoc_table
          effects_list[[resp]] <- build_effects(outputs)
        }
      } else {
        summary_list[[resp]] <- NULL
        posthoc_list[[resp]] <- NULL
        effects_list[[resp]] <- NULL
      }
      if (!is.null(entry$error)) {
        entry_errors <- c(entry_errors, entry$error)
      }
      if (length(entry_errors) > 0) {
        errors_list[[resp]] <- paste(unique(entry_errors), collapse = "\n")
      }
    }

    return(list(
      summary = summary_list,
      posthoc = posthoc_list,
      effects = effects_list,
      errors = errors_list
    ))
  }

  summary_list <- list()
  posthoc_list <- list()
  effects_list <- list()
  errors_list <- list()

  for (stratum_name in names(model_info$models)) {
    stratum_models <- model_info$models[[stratum_name]]
    if (is.null(stratum_models)) next

    for (resp in names(stratum_models)) {
      entry <- stratum_models[[resp]]
      outputs <- NULL
      entry_error <- NULL
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_error <- outputs$error
          outputs <- NULL
        }
      }

      if (is.null(summary_list[[resp]])) summary_list[[resp]] <- list()
      if (is.null(posthoc_list[[resp]])) posthoc_list[[resp]] <- list()
      if (is.null(effects_list[[resp]])) effects_list[[resp]] <- list()
      if (is.null(errors_list[[resp]])) errors_list[[resp]] <- list()

      summary_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$anova_table else NULL
      posthoc_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$posthoc_table else NULL
      effects_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) build_effects(outputs) else NULL

      if (!is.null(entry$error)) {
        entry_error <- c(entry_error, entry$error)
      }

      if (!is.null(entry_error)) {
        errors_list[[resp]][[stratum_name]] <- paste(unique(entry_error), collapse = "\n")
      }
    }
  }


  list(
    summary = summary_list,
    posthoc = posthoc_list,
    effects = effects_list,
    errors = errors_list
  )
}


build_effects <- function(outputs) {
  if (is.null(outputs) || is.null(outputs$anova_table)) return(NULL)
  effects <- data.frame(
    Effect = outputs$anova_table$Effect,
    significant = outputs$anova_significant,
    stringsAsFactors = FALSE
  )
  if ("p.value" %in% names(outputs$anova_table)) {
    effects$p.value <- outputs$anova_table$p.value
  }
  effects
}#### Section: Plot Context Initialization ####

initialize_anova_plot_context <- function(data, info, layout_values) {
  factor1 <- info$factors$factor1
  factor2 <- info$factors$factor2
  order1 <- info$orders$order1
  order2 <- info$orders$order2

  if (!is.null(factor1) && !is.null(order1) && factor1 %in% names(data)) {
    data[[factor1]] <- factor(data[[factor1]], levels = order1)
  }
  if (!is.null(factor2) && !is.null(order2) && factor2 %in% names(data)) {
    data[[factor2]] <- factor(data[[factor2]], levels = order2)
  }

  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  strat_var <- if (has_strata) info$strata$var else NULL
  strata_levels <- if (has_strata) info$strata$levels else character(0)

  if (has_strata && (is.null(strata_levels) || length(strata_levels) == 0) &&
      !is.null(strat_var) && strat_var %in% names(data)) {
    strata_levels <- unique(as.character(stats::na.omit(data[[strat_var]])))
  }

  layout_input <- parse_anova_layout_inputs(layout_values)

  n_expected_strata <- if (has_strata) max(1L, length(strata_levels)) else 1L
  strata_defaults <- if (has_strata) {
    compute_default_grid(n_expected_strata)
  } else {
    list(rows = 1L, cols = 1L)
  }
  strata_layout <- basic_grid_layout(
    rows = layout_input$strata_rows,
    cols = layout_input$strata_cols,
    default_rows = strata_defaults$rows,
    default_cols = strata_defaults$cols
  )

  list(
    data = data,
    responses = info$responses,
    factor1 = factor1,
    factor2 = factor2,
    order1 = order1,
    order2 = order2,
    has_strata = has_strata,
    strat_var = strat_var,
    strata_levels = strata_levels,
    n_expected_strata = n_expected_strata,
    strata_defaults = strata_defaults,
    strata_layout = strata_layout,
    layout_input = layout_input,
    initial_strata_panels = if (has_strata) 0L else 1L
  )
}

parse_anova_layout_inputs <- function(layout_values) {
  list(
    strata_rows = suppressWarnings(as.numeric(layout_values$strata_rows)),
    strata_cols = suppressWarnings(as.numeric(layout_values$strata_cols)),
    resp_rows   = suppressWarnings(as.numeric(layout_values$resp_rows)),
    resp_cols   = suppressWarnings(as.numeric(layout_values$resp_cols))
  )
}

update_numeric_range <- function(current_range, values) {
  values <- values[is.finite(values)]
  if (length(values) == 0) return(current_range)
  new_range <- range(values)
  if (any(!is.finite(new_range))) return(current_range)
  if (is.null(current_range)) {
    new_range
  } else {
    c(min(current_range[1], new_range[1]), max(current_range[2], new_range[2]))
  }
}

apply_common_legend_layout <- function(plot_obj,
                                       legend_position = NULL,
                                       collect_guides = FALSE) {
  if (is.null(plot_obj)) return(plot_obj)

  updated <- plot_obj
  if (collect_guides) {
    updated <- collect_guides_safe(updated)
    updated <- updated + patchwork::plot_layout(guides = "collect")
  }

  if (!is.null(legend_position)) {
    updated <- add_theme_to_plot(
      updated,
      theme(
        legend.position = legend_position,
        legend.box = "horizontal"
      )
    )
  }

  updated
}

collect_guides_safe <- function(plot_obj) {
  if (is.null(plot_obj) || !requireNamespace("patchwork", quietly = TRUE)) {
    return(plot_obj)
  }

  is_patchwork <- inherits(plot_obj, "patchwork")
  if (!is_patchwork) {
    return(plot_obj)
  }

  exports <- tryCatch(getNamespaceExports("patchwork"), error = function(...) character())
  collected <- if ("collect_guides" %in% exports) {
    patchwork::collect_guides(plot_obj)
  } else {
    plot_obj + patchwork::plot_layout(guides = "collect")
  }

  collected + patchwork::plot_layout(guides = "collect")
}

add_theme_to_plot <- function(plot_obj, theme_obj) {
  if (inherits(plot_obj, "patchwork")) {
    plot_obj & theme_obj
  } else {
    plot_obj + theme_obj
  }
}


finalize_anova_plot_result <- function(response_plots,
                                       context,
                                       strata_panel_count,
                                       collect_guides = FALSE,
                                       legend_position = NULL) {
  if (length(response_plots) == 0) {
    return(NULL)
  }
  
  has_strata <- context$has_strata
  strata_layout <- context$strata_layout
  
  if (has_strata && strata_panel_count == 0L) {
    strata_panel_count <- context$n_expected_strata
  }

  response_defaults <- compute_default_grid(length(response_plots))
  response_layout <- basic_grid_layout(
    rows = context$layout_input$resp_rows,
    cols = context$layout_input$resp_cols,
    default_rows = response_defaults$rows,
    default_cols = response_defaults$cols
  )

  strata_validation <- if (has_strata) {
    validate_grid(max(1L, strata_panel_count), strata_layout$nrow, strata_layout$ncol)
  } else {
    list(valid = TRUE, message = NULL)
  }
  
  response_validation <- validate_grid(
    length(response_plots),
    response_layout$nrow,
    response_layout$ncol
  )
  
  warnings <- c()
  if (has_strata && !strata_validation$valid && !is.null(strata_validation$message)) {
    warnings <- c(warnings, strata_validation$message)
  }
  if (!response_validation$valid && !is.null(response_validation$message)) {
    warnings <- c(warnings, response_validation$message)
  }
  warning_text <- if (length(warnings) > 0) paste(warnings, collapse = "<br/>") else NULL
  
  panel_counts <- list(
    strata = if (has_strata) max(1L, strata_panel_count) else 1L,
    responses = length(response_plots)
  )
  
  final_plot <- NULL
  if (is.null(warning_text)) {
    if (length(response_plots) == 1) {
      final_plot <- response_plots[[1]]
      if (collect_guides && !is.null(legend_position)) {
        final_plot <- final_plot & theme(legend.position = legend_position)
      }
    } else {
      final_plot <- patchwork::wrap_plots(
        plotlist = response_plots,
        nrow = response_layout$nrow,
        ncol = response_layout$ncol
      )
    }
    if (collect_guides || !is.null(legend_position)) {
      final_plot <- apply_common_legend_layout(
        final_plot,
        legend_position = legend_position,
        collect_guides = collect_guides
      )
    }
  }
  
  list(
    plot = final_plot,
    layout = list(
      strata = list(
        rows = if (has_strata) strata_layout$nrow else 1L,
        cols = if (has_strata) strata_layout$ncol else 1L
      ),
      responses = list(
        rows = response_layout$nrow,
        cols = response_layout$ncol
      )
    ),
    warning = warning_text,
    panel_counts = panel_counts,
    defaults = list(
      strata = context$strata_defaults,
      responses = response_defaults
    )
  )
}
#### Section: ANOVA Output Processing ####

#### Section: ANOVA Output Processing ####

prepare_anova_outputs <- function(model_obj, factor_names) {
  old_contrasts <- options("contrasts")
  on.exit(options(old_contrasts), add = TRUE)
  options(contrasts = c("contr.sum", "contr.poly"))
  
  safe_anova <- purrr::safely(function(mod) {
    car::Anova(mod, type = 3)
  })
  
  anova_result <- safe_anova(model_obj)
  if (!is.null(anova_result$error)) {
    return(list(
      error = conditionMessage(anova_result$error),
      anova_object = NULL,
      anova_table = NULL,
      anova_significant = NULL,
      posthoc_details = list(),
      posthoc_table = NULL,
      posthoc_significant = NULL
    ))
  }
  
  anova_obj <- anova_result$result
  anova_df <- as.data.frame(anova_obj)
  anova_df$Effect <- rownames(anova_df)
  rownames(anova_df) <- NULL
  anova_df <- anova_df[, c("Effect", setdiff(names(anova_df), "Effect"))]
  
  # --- round numeric columns and keep raw p-values ---
  p_col <- grep("^Pr", names(anova_df), value = TRUE)
  p_col <- if (length(p_col) > 0) p_col[1] else NULL
  raw_p <- if (!is.null(p_col)) anova_df[[p_col]] else rep(NA_real_, nrow(anova_df))

  for (col in names(anova_df)) {
    if (is.numeric(anova_df[[col]])) {
      # Keep SumSq/MeanSq to 3 decimals, F to 3, leave p unrounded for label formatting
      if (!is.null(p_col) && col == p_col) {
        next
      }
      anova_df[[col]] <- round(anova_df[[col]], 4)
    }
  }
  
  anova_significant <- !is.na(raw_p) & raw_p < 0.05
  if (!is.null(p_col)) {
    names(anova_df)[names(anova_df) == p_col] <- "p.value"
  } else {
    anova_df$p.value <- NA_real_
  }
  
  # --- Post-hoc Tukey for each factor ---
  factor_names <- unique(factor_names[!is.na(factor_names) & nzchar(factor_names)])
  posthoc_details <- list()
  posthoc_combined <- NULL
  posthoc_significant <- numeric(0)
  
  # ONE-WAY POSTHOC (reference vs all)
  if (length(factor_names) == 1) {
    f1 <- factor_names[1]
    f1_spec <- anova_protect_vars(f1)
    
    if (f1 %in% names(model_obj$model)) {
      res <- tryCatch({
        
        emm <- emmeans::emmeans(model_obj, specs = as.formula(paste("~", f1_spec)))
        
        ref_lvl <- levels(model_obj$model[[f1]])[1]
        ref_idx <- which(levels(model_obj$model[[f1]]) == ref_lvl)
        
        # Only reference-vs-others contrasts (clean, robust)
        contrasts <- emmeans::contrast(emm, method = "trt.vs.ctrl", ref = ref_idx)
        res_df <- as.data.frame(summary(contrasts))
        
        res_df$Factor <- f1
        res_df
        
      }, error = function(e) list(error = e$message))
      
      if (is.data.frame(res)) {
        posthoc_details[[f1]] <- list(table = res, error = NULL)
        posthoc_combined <- res
      } else {
        posthoc_details[[f1]] <- list(table = NULL, error = res$error)
      }
    }
  } 
  ### TWO-WAY POSTHOC (nested reference-vs-all)
  else if (length(factor_names) == 2) {
    
    f1 <- factor_names[1]
    f2 <- factor_names[2]
    
    f1_spec <- anova_protect_vars(f1)
    f2_spec <- anova_protect_vars(f2)
    
    # Identify reference level of f2
    f2_levels <- levels(model_obj$model[[f2]])
    ref_lvl <- f2_levels[1]
    ref_idx <- which(f2_levels == ref_lvl)
    
    # Compute nested emmeans: f2 within each f1 level
    res_nested <- tryCatch({
      
      emm_nested <- emmeans::emmeans(
        model_obj,
        specs = as.formula(paste("~", f2_spec, "|", f1_spec))
      )
      
      # Reference-vs-all inside each f1 group
      contrasts_nested <- emmeans::contrast(
        emm_nested,
        method = "trt.vs.ctrl",
        ref = ref_idx
      )
      
      df <- as.data.frame(summary(contrasts_nested))
      df$Factor <- paste0(f2, "_within_", f1)

      # Ensure f1 column exists (grouping variable)
      if (!f1 %in% names(df)) {
        df[[f1]] <- df$comparison # fallback: emmeans puts group there
      }

      # Preserve the user-specified order of the grouping factor
      f1_levels <- levels(model_obj$model[[f1]])
      if (!is.null(f1_levels)) {
        df[[f1]] <- factor(df[[f1]], levels = f1_levels)
        df <- df[order(df[[f1]]), , drop = FALSE]
      }

      df[[f1]] <- as.character(df[[f1]])
      df
      
    }, error = function(e) list(error = e$message))
    
    if (is.data.frame(res_nested)) {
      key <- paste0(f2, "_within_", f1)
      posthoc_details[[key]] <- list(table = res_nested, error = NULL)
      posthoc_combined <- dplyr::bind_rows(posthoc_combined, res_nested)
    } else {
      key <- paste0(f2, "_within_", f1)
      posthoc_details[[key]] <- list(table = NULL, error = res_nested$error)
    }
  }
  
  
  if (!is.null(posthoc_combined)) {
    posthoc_combined <- posthoc_combined[, c("Factor", setdiff(names(posthoc_combined), "Factor"))]
    numeric_cols <- names(posthoc_combined)[sapply(posthoc_combined, is.numeric)]
    if (length(numeric_cols) > 0) {
      for (col in numeric_cols) {
      # keep effect sizes/SE/df at 4 decimals; leave p-value for formatter
      if (tolower(col) %in% c("p.value", "p.value.")) next
      posthoc_combined[[col]] <- round(posthoc_combined[[col]], 4)
    }
  }
    
    if ("p.value" %in% names(posthoc_combined)) {
      raw_posthoc_p <- posthoc_combined$p.value
      posthoc_significant <- !is.na(raw_posthoc_p) & raw_posthoc_p < 0.05
    } else {
      posthoc_significant <- rep(FALSE, nrow(posthoc_combined))
    }
  }
  
  list(
    error = NULL,
    anova_object = anova_obj,
    anova_table = anova_df,
    anova_significant = anova_significant,
    posthoc_details = posthoc_details,
    posthoc_table = posthoc_combined,
    posthoc_significant = posthoc_significant
  )
}

#### Collate tidy summaries from ANOVA models ####

download_all_anova_results <- function(models_info, file) {
  if (is.null(models_info) || is.null(models_info$models)) {
    stop("No models found to export.")
  }

  combined_anova <- list()
  combined_contrasts <- list()
  factor_names <- unique(unlist(models_info$factors))
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]
  errors <- character(0)
  
  # --- Case 1: no stratification
  if (is.null(models_info$strata)) {
    for (resp in models_info$responses) {
      model_entry <- models_info$models[[resp]]
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        if (!is.null(model_entry$error)) {
          errors <- c(errors, paste0(resp, ": ", model_entry$error))
        }
        next
      }
      outputs <- prepare_anova_outputs(model_entry$model, factor_names)
      if (!is.null(outputs$error)) {
        errors <- c(errors, paste0(resp, ": ", outputs$error))
        next
      }
      anova_obj <- outputs$anova_object
      if (is.null(anova_obj)) {
        errors <- c(errors, paste0(resp, ": ANOVA results are unavailable."))
        next
      }
      tbl <- as.data.frame(anova_obj)
      tbl$Response <- resp
      tbl$Stratum <- "None"
      tbl$Term <- rownames(tbl)
      rownames(tbl) <- NULL
      names(tbl) <- sub(" ", "", names(tbl))
      tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
      combined_anova[[length(combined_anova) + 1]] <- tbl

      if (!is.null(outputs$posthoc_table) && nrow(outputs$posthoc_table) > 0) {
        ph_tbl <- outputs$posthoc_table
        ph_tbl$Response <- resp
        ph_tbl$Stratum <- "None"
        combined_contrasts[[length(combined_contrasts) + 1]] <- ph_tbl
      }
    }
  } else {
    # --- Case 2: stratified
    for (stratum in models_info$strata$levels) {
      for (resp in models_info$responses) {
        model_entry <- models_info$models[[stratum]][[resp]]
        if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
          if (!is.null(model_entry$error)) {
            errors <- c(errors, paste0(resp, " (", stratum, "): ", model_entry$error))
          }
          next
        }
        outputs <- prepare_anova_outputs(model_entry$model, factor_names)
        if (!is.null(outputs$error)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ", outputs$error))
          next
        }
        anova_obj <- outputs$anova_object
        if (is.null(anova_obj)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ANOVA results are unavailable."))
          next
        }
        tbl <- as.data.frame(anova_obj)
        tbl$Response <- resp
        tbl$Stratum <- stratum
        tbl$Term <- rownames(tbl)
        rownames(tbl) <- NULL
        names(tbl) <- sub(" ", "", names(tbl))
        tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
        combined_anova[[length(combined_anova) + 1]] <- tbl

        if (!is.null(outputs$posthoc_table) && nrow(outputs$posthoc_table) > 0) {
          ph_tbl <- outputs$posthoc_table
          ph_tbl$Response <- resp
          ph_tbl$Stratum <- stratum
          combined_contrasts[[length(combined_contrasts) + 1]] <- ph_tbl
        }
      }
    }
  }

  if (length(combined_anova) == 0) {
    msg <- "No ANOVA models available to export."
    if (length(errors) > 0) {
      msg <- paste0(
        msg,
        " The following issues were reported:\n",
        paste(sprintf("- %s", unique(errors)), collapse = "\n")
      )
    }
    stop(msg)
  }

  write_anova_docx(
    content = list(
      anova_results = combined_anova,
      contrast_results = combined_contrasts
    ),
    file = file
  )
}

write_anova_docx <- function(content, file, response_name = NULL, stratum_label = NULL) {
  if (is.null(content)) stop("No ANOVA results available to export.")

  add_blank_line <- function(doc, text = "", style = "Normal") {
    body_add_par(doc, text, style = style)
  }

  # Helper to format p-values consistently
  format_p <- function(df, p_col) {
    if (is.null(p_col) || !p_col %in% names(df)) return(df)
    p_vals <- as.numeric(df[[p_col]])
    df[[p_col]] <- p_vals
    df[[paste0(p_col, "_label")]] <- ifelse(p_vals < 0.0001, "<0.0001", sprintf("%.4f", p_vals))
    df$sig <- p_vals < 0.05
    df
  }

  # Shared styling for all tables (aligned with LM/LMM exports)
  format_table <- function(df, visible_cols, header_labels, merge_cols = NULL, p_label_col = NULL, sig_col = "sig") {
    ft <- flextable(df[, visible_cols, drop = FALSE])
    ft <- set_header_labels(ft, values = header_labels)

    if (!is.null(merge_cols)) {
      ft <- merge_v(ft, j = intersect(merge_cols, ft$col_keys))
    }

    ft <- fontsize(ft, part = "all", size = 10)
    ft <- bold(ft, part = "header", bold = TRUE)
    ft <- color(ft, part = "header", color = "black")
    # Align text left, numbers right
    numeric_cols <- names(df[, visible_cols, drop = FALSE])[sapply(df[, visible_cols, drop = FALSE], is.numeric)]
    ft <- align(ft, j = setdiff(ft$col_keys, numeric_cols), align = "left", part = "all")
    if (length(numeric_cols) > 0) {
      ft <- align(ft, j = numeric_cols, align = "right", part = "all")
      ft <- colformat_num(ft, j = numeric_cols, digits = 4)
    }
    ft <- border_remove(ft)

    black <- fp_border(color = "black", width = 1)
    ft <- border(ft, part = "header", border.top = black, border.bottom = black)

    if ("Stratum" %in% names(df)) {
      group_cols <- c(if ("Response" %in% names(df)) "Response", "Stratum")
      strata_factor <- interaction(df[, group_cols, drop = FALSE], drop = TRUE)
      change_rows <- which(diff(as.numeric(strata_factor)) != 0)
      if (length(change_rows) > 0) {
        ft <- border(ft, i = change_rows, part = "body", border.bottom = fp_border(color = "black", width = 0.5))
      }
    } else if ("Response" %in% names(df)) {
      change_rows <- which(diff(as.numeric(factor(df$Response))) != 0)
      if (length(change_rows) > 0) {
        ft <- border(ft, i = change_rows, part = "body", border.bottom = fp_border(color = "black", width = 0.5))
      }
    }

    if (nrow(df) > 0) {
      ft <- border(ft, i = nrow(df), part = "body", border.bottom = black)
    }

    if (!is.null(sig_col) && sig_col %in% names(df) && !is.null(p_label_col) && p_label_col %in% ft$col_keys) {
      sig_rows <- which(df[[sig_col]] %in% TRUE)
      if (length(sig_rows) > 0) {
        ft <- bold(ft, i = sig_rows, j = p_label_col, bold = TRUE)
      }
    }

    ft <- set_table_properties(ft, layout = "autofit", width = 0.9)
    ft <- autofit(ft)
    ft <- padding(ft, padding.top = 2, padding.bottom = 2, padding.left = 2, padding.right = 2)
    ft
  }

  # Build unified data frames for ANOVA and contrasts
  is_batch <- !is.null(content$anova_results) || !is.null(content$contrast_results)

  if (is_batch) {
    anova_entries <- content$anova_results
    contrast_entries <- content$contrast_results
  } else {
    anova_entries <- list()
    contrast_entries <- list()

    if (!is.null(content$anova_object)) {
      anova_tbl <- as.data.frame(content$anova_object)
      anova_tbl$Response <- response_name %||% "Response"
      anova_tbl$Stratum <- stratum_label %||% "None"
      anova_tbl$Term <- rownames(anova_tbl)
      rownames(anova_tbl) <- NULL
      names(anova_tbl) <- sub(" ", "", names(anova_tbl))
      anova_tbl$PrF <- anova_tbl[, grep("^Pr", names(anova_tbl))[1]]
      anova_entries <- list(anova_tbl)
    }

    if (!is.null(content$posthoc_table) && nrow(content$posthoc_table) > 0) {
      ph_tbl <- content$posthoc_table
      ph_tbl$Response <- response_name %||% "Response"
      ph_tbl$Stratum <- stratum_label %||% "None"
      contrast_entries <- list(ph_tbl)
    }
  }

  if (is.null(anova_entries) || length(anova_entries) == 0) stop("No ANOVA results available to export.")

  combined_anova <- bind_rows(anova_entries)

  required_cols <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF")
  if (!all(required_cols %in% names(combined_anova))) stop("Missing required columns in ANOVA results.")

  combined_anova <- combined_anova %>%
    mutate(
      SumSq = round(SumSq, 4),
      Fvalue = round(Fvalue, 4)
    ) %>%
    format_p("PrF") %>%
    arrange(Response, Stratum, Term)

  show_strata <- !(length(unique(combined_anova$Stratum)) == 1 && unique(combined_anova$Stratum) == "None")

  if (show_strata) {
    anova_visible <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    anova_merge <- c("Response", "Stratum")
  } else {
    combined_anova$Stratum <- NULL
    anova_visible <- c("Response", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    anova_merge <- c("Response")
  }

  anova_headers <- c(
    Response = "Response",
    Stratum = if (show_strata) "Stratum" else NULL,
    Term = "Term",
    SumSq = "Sum Sq",
    Df = "Df",
    Fvalue = "F value",
    PrF_label = "Pr(>F)"
  )

  doc <- read_docx()

  title_text <- if (length(unique(combined_anova$Response)) == 1) {
    sprintf("ANOVA Results â€” %s", unique(combined_anova$Response))
  } else {
    "ANOVA Results"
  }

  doc <- body_add_fpar(doc, fpar(ftext(title_text, prop = fp_text(bold = TRUE, font.size = 12))))

  # Optional subtitle when there is a single stratum label present
  if (!show_strata && !is.null(stratum_label) && nzchar(stratum_label) && !identical(stratum_label, "None")) {
    doc <- body_add_fpar(doc, fpar(ftext(stratum_label, prop = fp_text(bold = TRUE, font.size = 11))))
  }

  doc <- add_blank_line(doc)

  doc <- body_add_fpar(doc, fpar(ftext("ANOVA Table", prop = fp_text(bold = TRUE))))
  doc <- add_blank_line(doc)
  doc <- body_add_flextable(
    doc,
    format_table(
      combined_anova,
      visible_cols = anova_visible,
      header_labels = anova_headers,
      merge_cols = anova_merge,
      p_label_col = "PrF_label"
    )
  )

  if (!is.null(contrast_entries) && length(contrast_entries) > 0) {
    combined_contrasts <- bind_rows(contrast_entries)

    p_col <- intersect(c("p.value", "p.value."), names(combined_contrasts))
    p_col <- if (length(p_col) > 0) p_col[1] else NULL
    combined_contrasts <- format_p(combined_contrasts, p_col)

    has_stratum_contrast <- "Stratum" %in% names(combined_contrasts)
    show_strata_contrast <- has_stratum_contrast && !(length(unique(combined_contrasts$Stratum)) == 1 && unique(combined_contrasts$Stratum) == "None")

    combined_contrasts <- if (has_stratum_contrast) {
      combined_contrasts %>% arrange(Response, Stratum)
    } else {
      combined_contrasts %>% arrange(Response)
    }

    base_cols <- c("Response", if (show_strata_contrast) "Stratum")
    detail_cols <- setdiff(names(combined_contrasts), c(base_cols, "sig", if (!is.null(p_col)) c(p_col, paste0(p_col, "_label"))))
    p_display_col <- if (!is.null(p_col)) paste0(p_col, "_label") else NULL
    contrast_visible <- unique(c(base_cols, detail_cols, p_display_col))

    header_labels <- setNames(gsub("_", " ", contrast_visible), contrast_visible)
    if (!is.null(p_display_col)) header_labels[[p_display_col]] <- "p-value"

    doc <- add_blank_line(doc)
    doc <- body_add_fpar(doc, fpar(ftext("Post-hoc Contrasts", prop = fp_text(bold = TRUE))))
    doc <- add_blank_line(doc)
    doc <- body_add_flextable(
      doc,
      format_table(
        combined_contrasts,
        visible_cols = contrast_visible,
        header_labels = header_labels,
        merge_cols = base_cols,
        p_label_col = p_display_col
      )
    )
  }

  doc <- add_blank_line(doc)
  doc <- add_blank_line(doc, "Significance level: p < 0.05 (bold values).")
  print(doc, target = file)
}
#### Table Analyzer â€” Shared ANOVA Module  ####
#### Section: UI & Output Binding ####

build_anova_layout_controls <- function(ns, input, info) {
  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  n_responses <- if (!is.null(info$responses)) length(info$responses) else 0

  strata_inputs <- if (has_strata) {
    plot_grid_ui(
      id = ns("strata_grid"),
      rows_label = sprintf("Rows for strata (%s)", info$strata$var),
      cols_label = sprintf("Cols for strata (%s)", info$strata$var),
      rows_help = "Rows of plots when displaying each stratum.",
      cols_help = "Columns of plots when displaying each stratum."
    )
  } else {
    NULL
  }

  response_inputs <- if (!is.null(n_responses) && n_responses > 1) {
    plot_grid_ui(
      id = ns("response_grid"),
      rows_label = sprintf("Rows for responses (n=%d)", n_responses),
      cols_label = sprintf("Cols for responses (n=%d)", n_responses),
      rows_help = "Rows of plots when multiple responses are shown together.",
      cols_help = "Columns of plots when multiple responses are shown together."
    )
  } else {
    NULL
  }

  tagList(strata_inputs, response_inputs)
}


#### Formula utilities ####

render_anova_results <- function(ns, model_info, module_label = "ANOVA") {
  if (is.null(model_info)) return(NULL)
  
  responses <- model_info$responses
  strata_info <- model_info$strata
  
  # No stratification
  if (is.null(strata_info)) {
    tabs <- lapply(seq_along(responses), function(i) {
      tabPanel(
        title = responses[i],
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i)))
        )
      )
    })
    return(do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs)))
  }
  
  # Stratified
  strata_levels <- strata_info$levels
  tabs <- lapply(seq_along(responses), function(i) {
    response_name <- responses[i]
    stratum_tabs <- lapply(seq_along(strata_levels), function(j) {
      stratum_name <- strata_levels[j]
      tabPanel(
        title = stratum_name,
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i, "_", j)))
        )
      )
    })
    tabPanel(
      title = response_name,
      do.call(tabsetPanel, c(list(id = ns(paste0("strata_tabs_", i))), stratum_tabs))
    )
  })
  do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs))
}

bind_anova_outputs <- function(ns, output, models_reactive) {
  observeEvent(models_reactive(), {
    model_info <- models_reactive()
    if (is.null(model_info)) return()
    
    responses <- model_info$responses
    model_list <- model_info$models
    strata_info <- model_info$strata
    factors <- unlist(model_info$factors, use.names = FALSE)
    
    # --- Non-stratified case ---
    if (is.null(strata_info)) {
      for (i in seq_along(responses)) {
        local({
          idx <- i
          response_name <- responses[i]
          model_entry <- model_list[[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx),
            download_id = paste0("download_", idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors
          )
        })
      }
      return()
    }
    
    # --- Stratified case ---
    strata_levels <- strata_info$levels
    for (i in seq_along(responses)) {
      for (j in seq_along(strata_levels)) {
        local({
          idx <- i
          stratum_idx <- j
          response_name <- responses[i]
          stratum_label <- strata_levels[j]
          model_entry <- model_list[[stratum_label]][[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx, "_", stratum_idx),
            download_id = paste0("download_", idx, "_", stratum_idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors,
            stratum_label = stratum_label
          )
        })
      }
    }
  })
}

#### Results export ####

bind_single_model_outputs <- function(output, summary_id, download_id,
                                      model_entry, response_name, factors,
                                      stratum_label = NULL) {
  output[[summary_id]] <- renderPrint({
    print_anova_summary_and_posthoc(model_entry, factors)
  })

  output[[download_id]] <- downloadHandler(
    filename = function() {
      base <- paste0("anova_results_", sanitize_name(response_name))
      if (!is.null(stratum_label)) {
        base <- paste0(base, "_stratum_", sanitize_name(stratum_label))
      }
      paste0(base, "_", Sys.Date(), ".docx")
    },
    content = function(file) {
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        stop("Model not available for download due to fitting error.")
      }
      results <- prepare_anova_outputs(model_entry$model, factors)
      if (!is.null(results$error)) {
        stop(paste0("ANOVA results unavailable: ", results$error))
      }
      if (is.null(results$anova_table)) {
        stop("ANOVA results are unavailable for export.")
      }
      write_anova_docx(
        file = file,
        content = results,
        response_name = response_name,
        stratum_label = stratum_label
      )
    }
  )
}

sanitize_name <- function(name) {
  safe <- gsub("[^A-Za-z0-9]+", "_", name)
  safe <- gsub("_+", "_", safe)
  safe <- gsub("^_|_$", "", safe)
  if (!nzchar(safe)) safe <- "unnamed"
  safe
}

print_anova_summary_and_posthoc <- function(model_entry, factors) {
  if (is.null(model_entry) || (is.list(model_entry) && is.null(model_entry$model))) {
    cat("Model is not available.\n")
    return(invisible(NULL))
  }

  if (!is.null(model_entry$error)) {
    cat(format_safe_error_message("Model fitting failed", model_entry$error), "\n", sep = "")
    return(invisible(NULL))
  }

  model_obj <- model_entry$model
  results <- prepare_anova_outputs(model_obj, factors)
  if (!is.null(results$error)) {
    cat(format_safe_error_message("ANOVA computation failed", results$error), "\n", sep = "")
    return(invisible(NULL))
  }
  if (is.null(results$anova_object)) {
    cat("ANOVA results are unavailable.\n")
    return(invisible(NULL))
  }
  print(results$anova_object)

  if (length(results$posthoc_details) == 0) {
    cat("\nNo post-hoc Tukey comparisons were generated.\n")
  } else {
    for (factor_nm in names(results$posthoc_details)) {
      details <- results$posthoc_details[[factor_nm]]
      if (!is.null(details$error)) {
        cat(
          "\n",
          format_safe_error_message(
            paste("Post-hoc Tukey comparisons for", factor_nm, "failed"),
            details$error
          ),
          "\n",
          sep = ""
        )
      } else if (!is.null(details$table)) {
        cat("\nPost-hoc Tukey comparisons for", factor_nm, ":\n")
        print(details$table)
      }
    }
  }
  invisible(results)
}

#### Section: Model Fitting & Preparation ####

#### Section: Utility Helpers ####

anova_protect_vars <- function(vars) {
  if (is.null(vars) || length(vars) == 0) return(vars)

  vals <- vapply(vars, function(v) {
    if (is.null(v) || is.na(v) || !nzchar(v)) return("")
    if (grepl("^`.*`$", v)) v else paste0("`", v, "`")
  }, character(1))

  vals[nzchar(vals)]
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Two-way ANOVA Module (Validated Version)
# ===============================================================

two_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order_1")),
      uiOutput(ns("level_order_2")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show results", width = "100%"),
          "Fit the two-way ANOVA with the selected factors and responses."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_all"), "Download results", style = "width: 100%;"),
          "Save all ANOVA tables, post-hoc results, and diagnostics to disk."
        ))
      )
    ),
    results = uiOutput(ns("summary_ui"))
  )
}

two_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    responses <- multi_response_server("response", filtered_data)
    strat_info <- stratification_server("strat", filtered_data)
    
    # ------------------------------------------------------------
    # Dynamic inputs
    # ------------------------------------------------------------
    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      
      cat_cols <- names(data)[sapply(data, function(x) is.factor(x) || is.character(x))]
      
      validate(
        need(length(cat_cols) > 1,
             "At least two categorical predictors are required for a two-way ANOVA.")
      )
      
      tagList(
        multi_response_ui(ns("response")),
        
        with_help_tooltip(
          selectInput(
            ns("factor1"),
            "Categorical predictor 1 (x-axis)",
            choices = cat_cols,
            selected = cat_cols[1]
          ),
          "Select the factor for the x-axis groups in the interaction plot."
        ),
        
        with_help_tooltip(
          selectInput(
            ns("factor2"),
            "Categorical predictor 2 (lines)",
            choices = cat_cols,
            selected = cat_cols[2]
          ),
          "Select the factor for the lines in the interaction plot."
        )
      )
    })
    
    # ------------------------------------------------------------
    # Level order inputs
    # ------------------------------------------------------------
    output$level_order_1 <- renderUI({
      req(filtered_data(), input$factor1)
      lev <- resolve_order_levels(filtered_data()[[input$factor1]])
      with_help_tooltip(
        selectInput(
          ns("order1"),
          paste("Order of levels (first = reference)", input$factor1),
          choices = lev,
          selected = lev,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s. The first is the reference.", input$factor1)
      )
    })
    
    output$level_order_2 <- renderUI({
      req(filtered_data(), input$factor2)
      lev <- resolve_order_levels(filtered_data()[[input$factor2]])
      with_help_tooltip(
        selectInput(
          ns("order2"),
          paste("Order of levels (first = reference)", input$factor2),
          choices = lev,
          selected = lev,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s. The first is the reference.", input$factor2)
      )
    })
    
    # ------------------------------------------------------------
    # Main model fitting
    # ------------------------------------------------------------
    models <- eventReactive(input$run, {
      df <- filtered_data()
      req(df, input$factor1, input$factor2, input$order1, input$order2)
      
      resp_vals <- responses()
      validate(
        need(length(resp_vals) > 0, "Select at least one response variable.")
      )
      
      validate(
        need(!identical(input$factor1, input$factor2),
             "The two categorical predictors must be different variables.")
      )
      
      # Factor 1 must have â‰¥ 2 levels
      validate(
        need(dplyr::n_distinct(df[[input$factor1]]) > 1,
             paste0("'", input$factor1, "' must contain at least two levels."))
      )
      
      # Factor 2 must have â‰¥ 2 levels
      validate(
        need(dplyr::n_distinct(df[[input$factor2]]) > 1,
             paste0("'", input$factor2, "' must contain at least two levels."))
      )
      
      # Order must contain â‰¥ 2 levels
      validate(
        need(length(input$order1) > 1,
             paste0("The level order for '", input$factor1, "' must contain at least two levels."))
      )
      
      validate(
        need(length(input$order2) > 1,
             paste0("The level order for '", input$factor2, "' must contain at least two levels."))
      )
      
      # Orders must match existing data levels
      validate(
        need(all(input$order1 %in% unique(df[[input$factor1]])),
             "Invalid level order for the first factor.")
      )
      
      validate(
        need(all(input$order2 %in% unique(df[[input$factor2]])),
             "Invalid level order for the second factor.")
      )
      
      # Numeric responses
      validate_numeric_columns(df, resp_vals, "response variables")
      
      # Response variance > 0
      for (r in resp_vals) {
        validate(
          need(stats::var(df[[r]], na.rm = TRUE) > 0,
               paste("Response", r, "has zero variance and cannot be analyzed."))
        )
      }
      
      # Stratification: each stratum must contain â‰¥ 2 levels for each factor
      if (!is.null(strat_info()$active) && strat_info()$active) {
        s <- strat_info()
        for (lev in s$levels) {
          sub <- df[df[[s$var]] == lev, ]
          
          validate(
            need(dplyr::n_distinct(sub[[input$factor1]]) > 1,
                 paste0("Stratum '", lev, "' contains fewer than two levels of ", input$factor1, "."))
          )
          
          validate(
            need(dplyr::n_distinct(sub[[input$factor2]]) > 1,
                 paste0("Stratum '", lev, "' contains fewer than two levels of ", input$factor2, "."))
          )
        }
      }
      
      # --------
      # Fit model
      # --------
      prepare_stratified_anova(
        df = df,
        responses = resp_vals,
        model = "twoway_anova",
        factor1_var = input$factor1,
        factor1_order = input$order1,
        factor2_var = input$factor2,
        factor2_order = input$order2,
        stratification = strat_info()
      )
    })
    
    # ------------------------------------------------------------
    # Download
    # ------------------------------------------------------------
    output$download_all <- downloadHandler(
      filename = function() {
        info <- models()
        req(info)
        
        n_resp <- length(info$responses)
        n_strata <- length(info$strata$levels %||% NULL)
        label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        paste0("anova_results_", n_resp, "resp_", label, "_",
               format(Sys.time(), "%Y%m%d-%H%M"), ".docx")
      },
      content = function(file) download_all_anova_results(models(), file)
    )
    
    # ------------------------------------------------------------
    # Results UI
    # ------------------------------------------------------------
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "Two-way ANOVA")
    })
    
    bind_anova_outputs(ns, output, models)
    
    # ------------------------------------------------------------
    # Exportable results object
    # ------------------------------------------------------------
    anova_results <- reactive({
      mod <- models()
      req(mod)
      
      res <- compile_anova_results(mod)
      data_used <- mod$data_used
      
      list(
        analysis_type = "ANOVA",
        type = "twoway_anova",
        data_used = data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        errors = res$errors,
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })
    
    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” Two-way ANOVA (Apply-button version)
# ===============================================================

visualize_twoway_ui <- function(id) {
  ns <- NS(id)
  
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize two-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c(
            "Lineplots (mean Â± SE)" = "lineplot_mean_se",
            "Barplots (mean Â± SE)"  = "barplot_mean_se"
          ),
          selected = "lineplot_mean_se"
        ),
        "Pick the chart style you prefer for viewing group means and uncertainty."
      ),
      
      conditionalPanel(
        condition = sprintf("input['%s'] === 'lineplot_mean_se'", ns("plot_type")),
        fluidRow(
          column(
            6,
            with_help_tooltip(
              checkboxInput(
                ns("lineplot_show_lines"),
                "Connect means with lines",
                value = TRUE
              ),
              "Draw connecting lines between group means."
            )
          ),
          column(
            6,
            with_help_tooltip(
              checkboxInput(
                ns("lineplot_use_dodge"),
                "Dodge grouped means",
                value = FALSE
              ),
              "Offset the level means of the second factor along the x-axis."
            )
          )
        )
      ),
      
      uiOutput(ns("axis_and_jitter")),
      subplot_size_ui(ns),
      uiOutput(ns("layout_controls")),
      
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = TRUE)),
        column(
          6,
          tagList(
            base_size_ui(
              ns,
              default = 13,
              help_text = "Adjust the base font size used for the ANOVA plots."
            ),
            br(),
            uiOutput(ns("common_legend_controls"))
          )
        )
      ),
      
      br(),
      
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"))
      )
    ),
    
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}



visualize_twoway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    # ------------------------------------------------------------------
    # Stored state
    # ------------------------------------------------------------------
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL,
      plot_width = NULL,
      plot_height = NULL
    )
    
    df <- reactive(filtered_data())
    
    # ------------------------------------------------------------------
    # Color handling
    # ------------------------------------------------------------------
    color_var <- reactive({
      info <- model_info()
      if (is.null(info) || is.null(info$factors)) return(NULL)
      info$factors$factor2
    })
    
    factor2_levels <- reactive({
      info <- model_info()
      if (is.null(info) || is.null(info$orders)) return(NULL)
      info$orders$order2
    })
    
    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = color_var,
      multi_group = TRUE,
      level_order_reactive = factor2_levels
    )
    
    base_size <- base_size_server(input = input, default = 13)
    
    # ------------------------------------------------------------------
    # Grid modules
    # ------------------------------------------------------------------
    strata_grid   <- plot_grid_server("strata_grid")
    response_grid <- plot_grid_server("response_grid")
    
    # ------------------------------------------------------------------
    # Dynamic UI
    # ------------------------------------------------------------------
    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })
    
    output$axis_and_jitter <- renderUI({
      jitter_widget <- NULL
      
      if (input$plot_type == "lineplot_mean_se") {
        jitter_widget <- with_help_tooltip(
          checkboxInput(
            ns("lineplot_show_jitter"),
            "Overlay jittered data",
            value = isTRUE(input$lineplot_show_jitter)
          ),
          "Overlay raw observations with jitter."
        )
      }
      
      fluidRow(
        column(
          6,
          with_help_tooltip(
            checkboxInput(
              ns("share_y_axis"),
              "Use common y-axis across plots",
              value = isTRUE(input$share_y_axis)
            ),
            "Use the same y-scale for all panels."
          )
        ),
        column(6, jitter_widget)
      )
    })
    
    # ------------------------------------------------------------------
    # Common legend UI
    # ------------------------------------------------------------------
    legend_state <- reactiveValues(
      enabled = FALSE,
      position = "bottom"
    )
    
    common_legend_available <- reactive({
      info <- model_info()
      if (is.null(info) || !identical(info$type, "twoway_anova"))
        return(FALSE)
      
      has_mult_resp <- length(info$responses %||% character()) > 1
      has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
      
      has_mult_resp || has_strata
    })
    
    observeEvent(input$use_common_legend, {
      legend_state$enabled <- isTRUE(input$use_common_legend)
    })
    
    observeEvent(input$common_legend_position, {
      legend_state$position <- input$common_legend_position
    })
    
    output$common_legend_controls <- renderUI({
      if (!common_legend_available()) return(NULL)
      
      legend_enabled <- isTRUE(legend_state$enabled)
      
      legend_checkbox <- with_help_tooltip(
        checkboxInput(
          ns("use_common_legend"),
          "Use common legend",
          value = legend_enabled
        ),
        "Merge legends across subplots."
      )
      
      legend_position <- NULL
      if (legend_enabled) {
        legend_position <- with_help_tooltip(
          selectInput(
            ns("common_legend_position"),
            "Legend position",
            c("Bottom" = "bottom", "Right" = "right", "Top" = "top", "Left" = "left"),
            selected = legend_state$position
          ),
          "Choose where to place the combined legend."
        )
      }
      
      tagList(legend_checkbox, legend_position)
    })
    
    # ------------------------------------------------------------------
    # APPLY BUTTON
    # ------------------------------------------------------------------
    observeEvent(input$apply_plot, {
      data <- df()
      info <- model_info()
      
      stored$plot_width  <- input$plot_width  %||% 600
      stored$plot_height <- input$plot_height %||% 600
      
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data or ANOVA results available."
        stored$plot <- NULL
        stored$layout <- NULL
        return()
      }
      
      # Count panels
      has_strata <- !is.null(info$strata) && !is.null(info$strata$levels)
      n_strata <- if (has_strata) length(info$strata$levels) else 1L
      
      responses <- info$responses
      n_responses <- if (!is.null(responses) && length(responses) > 0L) length(responses) else 1L
      
      # Final grid layouts
      layout_inputs <- list(
        strata_rows = strata_grid$rows(),
        strata_cols = strata_grid$cols(),
        resp_rows   = response_grid$rows(),
        resp_cols   = response_grid$cols()
      )
      
      # Legend handling
      legend_supported <- TRUE
      use_common_legend <- legend_supported && common_legend_available() && legend_state$enabled
      legend_position <- if (use_common_legend) legend_state$position else NULL
      
      # Compute plots
      results <- list(
        lineplot_mean_se = plot_anova_lineplot_meanse(
          data, info, layout_inputs,
          line_colors      = custom_colors(),
          base_size        = base_size(),
          show_lines       = input$lineplot_show_lines,
          show_jitter      = input$lineplot_show_jitter,
          use_dodge        = input$lineplot_use_dodge,
          share_y_axis     = input$share_y_axis,
          common_legend    = use_common_legend,
          legend_position  = legend_position
        ),
        
        barplot_mean_se = plot_anova_barplot_meanse(
          data, info, layout_inputs,
          line_colors      = custom_colors(),
          base_size        = base_size(),
          posthoc_all      = info$posthoc,
          share_y_axis     = input$share_y_axis,
          common_legend    = use_common_legend,
          legend_position  = legend_position
        )
      )
      
      chosen <- input$plot_type
      chosen_result <- results[[chosen]]
      
      stored$warning <- chosen_result$warning
      stored$plot    <- chosen_result$plot
      stored$layout  <- chosen_result$layout
    })
    
    # ------------------------------------------------------------------
    # Outputs
    # ------------------------------------------------------------------
    output$plot_warning <- renderUI({
      if (!is.null(stored$warning))
        div(class = "alert alert-warning", stored$warning)
    })
    
    output$plot <- renderPlot(
      {
        p <- stored$plot
        if (is.null(p)) return(NULL)
        print(p)
      },
      width = function() {
        lay <- stored$layout
        if (is.null(lay)) return(600)
        cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
        stored$plot_width * cols
      },
      height = function() {
        lay <- stored$layout
        if (is.null(lay)) return(600)
        rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
        stored$plot_height * rows
      },
      res = 96
    )
    
    output$download_plot <- downloadHandler(
      filename = function() paste0("anova_twoway_plot_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        req(!is.null(lay))
        
        cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
        rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
        
        w_in <- (stored$plot_width  * cols) / 96
        h_in <- (stored$plot_height * rows) / 96
        
        ggsave(file, p,
               dpi = 300,
               width = w_in,
               height = h_in,
               units = "in",
               limitsize = FALSE)
      }
    )
  })
}
