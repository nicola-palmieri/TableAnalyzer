# ===============================================================
# ðŸ§ª Table Analyzer â€” One-way ANOVA Module (Clean & Minimal)
# ===============================================================

one_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(
          6,
          with_help_tooltip(
            actionButton(ns("run"), "Show results", width = "100%"),
            "Run the ANOVA using the selected response and group variable."
          )
        ),
        column(
          6,
          with_help_tooltip(
            downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
            "Export the ANOVA summaries, post-hoc tests, and diagnostics."
          )
        )
      )
    ),
    results = uiOutput(ns("summary_ui"))
  )
}

one_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    responses <- multi_response_server("response", filtered_data)
    strat_info <- stratification_server("strat", filtered_data)
    
    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      cat_cols <- names(data)[sapply(data, is.factor) | sapply(data, is.character)]
      
      tagList(
        multi_response_ui(ns("response")),
        with_help_tooltip(
          selectInput(
            ns("group"),
            "Categorical predictor",
            choices = cat_cols,
            selected = if (length(cat_cols) > 0) cat_cols[1] else NULL
          ),
          "Choose the grouping variable that defines the comparison categories."
        )
      )
    })
    
    output$level_order <- renderUI({
      req(filtered_data(), input$group)
      levels <- resolve_order_levels(filtered_data()[[input$group]])
      with_help_tooltip(
        selectInput(
          ns("order"),
          "Order of levels (first = reference)",
          choices = levels,
          selected = levels,
          multiple = TRUE
        ),
        "Arrange the group levels; the first level is used as the reference in outputs."
      )
    })
    
    models <- eventReactive(input$run, {
      df <- filtered_data()
      req(df, input$group, input$order)
      resp_vals <- responses()
      validate(need(length(resp_vals) > 0, "Select at least one response variable."))
      validate_numeric_columns(df, resp_vals, "response variables")
      prepare_stratified_anova(
        df = df,
        responses = resp_vals,
        model = "oneway_anova",
        factor1_var = input$group,
        factor1_order = input$order,
        stratification = strat_info()
      )
    })
    
    output$download_all <- downloadHandler(
      filename = function() {
        info <- models()
        n_resp <- length(info$responses)
        n_strata <- length(info$strata$levels %||% NULL)
        label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        paste0("anova_results_", n_resp, "resp_", label, "_", format(Sys.time(), "%Y%m%d-%H%M"), ".docx")
      },
      content = function(file) download_all_anova_results(models(), file)
    )
    
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "One-way ANOVA")
    })
    
    bind_anova_outputs(ns, output, models)
    
    anova_results <- reactive({
      mod <- models()
      req(mod)
      res <- compile_anova_results(mod)

      list(
        analysis_type = "ANOVA",
        type = "oneway_anova",
        data_used = mod$data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = list(
          n = nrow(mod$data_used),
          vars = names(mod$data_used)
        ),
        errors = res$errors,
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })
    
    
    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” One-way ANOVA (Apply-button version)
# ===============================================================

visualize_oneway_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize one-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      
      selectInput(
        ns("plot_type"),
        label = "Select visualization type",
        choices = c(
          "Lineplots (mean Â± SE)" = "lineplot_mean_se",
          "Barplots (mean Â± SE)"  = "barplot_mean_se"
        ),
        selected = "lineplot_mean_se"
      ),
      
      conditionalPanel(
        condition = sprintf("input['%s'] === 'lineplot_mean_se'", ns("plot_type")),
        fluidRow(
          column(6, checkboxInput(ns("lineplot_show_lines"),  "Connect means with lines", value = TRUE)),
          column(6, checkboxInput(ns("lineplot_show_jitter"), "Overlay jittered data",  value = FALSE))
        )
      ),
      
      checkboxInput(ns("share_y_axis"), "Use common y-axis across plots", value = FALSE),
      
      subplot_size_ui(ns),
      uiOutput(ns("layout_controls")),
      
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = FALSE)),
        column(6, base_size_ui(ns, default = 13))
      ),
      
      br(),
      
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"))
      )
    ),
    
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}


visualize_oneway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL
    )
    
    df <- reactive(filtered_data())
    
    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = reactive(NULL),
      multi_group = FALSE
    )
    
    base_size <- base_size_server(input = input, default = 14)
    
    strata_grid   <- plot_grid_server("strata_grid")
    response_grid <- plot_grid_server("response_grid")
    
    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })
    
    observeEvent(input$apply_plot, {
      data <- df()
      info <- model_info()
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data or ANOVA results available."
        stored$plot <- NULL
        return()
      }
      
      layout_inputs <- list(
        strata_rows = strata_grid$rows(),
        strata_cols = strata_grid$cols(),
        resp_rows   = response_grid$rows(),
        resp_cols   = response_grid$cols()
      )
      
      results <- list(
        lineplot_mean_se = plot_anova_lineplot_meanse(
          data, info, layout_inputs,
          line_colors  = custom_colors(),
          base_size    = base_size(),
          show_lines   = input$lineplot_show_lines,
          show_jitter  = input$lineplot_show_jitter,
          share_y_axis = input$share_y_axis
        ),
        barplot_mean_se = plot_anova_barplot_meanse(
          data, info,
          layout_values     = layout_inputs,
          line_colors       = custom_colors(),
          base_size         = base_size(),
          posthoc_all       = info$posthoc,
          share_y_axis      = input$share_y_axis
        )
      )
      
      chosen <- input$plot_type
      chosen_result <- results[[chosen]]

      stored$warning <- chosen_result$warning
      stored$plot    <- chosen_result$plot
      stored$layout  <- chosen_result$layout

      apply_grid_defaults_if_empty(
        input,
        session,
        "strata_grid",
        chosen_result$defaults$strata,
        n_items = chosen_result$panel_counts$strata
      )

      apply_grid_defaults_if_empty(
        input,
        session,
        "response_grid",
        chosen_result$defaults$responses,
        n_items = chosen_result$panel_counts$responses
      )
    })
    
    output$plot_warning <- renderUI({
      if (!is.null(stored$warning)) {
        div(class = "alert alert-warning", HTML(stored$warning))
      }
    })
    
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_width * (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
    },
    height = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      stored$plot_height * (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
    },
    res = 96)
    
    output$download_plot <- downloadHandler(
      filename = function() paste0("anova_plot_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        req(!is.null(lay))
        
        total_cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
        total_rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
        
        # Pixels â†’ inches conversion
        w_in <- (stored$plot_width  * total_cols) / 96
        h_in <- (stored$plot_height * total_rows) / 96
        
        ggsave(
          filename = file,
          plot = p,
          dpi = 300,
          width = w_in,
          height = h_in,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}


#### Section: Barplot Construction ####

plot_anova_barplot_meanse <- function(data,
                                      info,
                                      layout_values = list(),
                                      line_colors = NULL,
                                      base_size = 14,
                                      posthoc_all = NULL,
                                      share_y_axis = FALSE,
                                      common_legend = FALSE,
                                      legend_position = NULL) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2

  allowed_positions <- c("bottom", "top", "left", "right")
  legend_position_value <- if (!is.null(legend_position) && legend_position %in% allowed_positions) legend_position else "bottom"

  if (is.null(factor1) || length(context$responses) == 0) {
    return(NULL)
  }

  shared_y_limits <- if (isTRUE(share_y_axis)) {
    compute_barplot_shared_limits(
      context,
      data,
      factor1,
      factor2,
      posthoc_all
    )
  } else {
    NULL
  }
  
  base_fill <- if (!is.null(line_colors) && length(line_colors) > 0) unname(line_colors)[1] else "#3E8FC4"

  response_plots <- list()
  strata_panel_count <- context$initial_strata_panels

  build_response_plot <- function(resp) {
    posthoc_entry <- get_posthoc_entry_for_response(posthoc_all, resp)
    stats_entries <- generate_anova_stats_entries(
      context = context,
      data = data,
      resp = resp,
      factor1 = factor1,
      factor2 = factor2,
      posthoc_entry = posthoc_entry
    )

    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      stratum_plots <- lapply(stats_entries, function(entry) {
        build_bar_plot_panel(
          stats_df = entry$stats_df,
          title_text = entry$label,
          factor1 = factor1,
          factor2 = factor2,
          line_colors = line_colors,
          base_fill = base_fill,
          base_size = base_size,
          posthoc_entry = entry$posthoc,
          nested_posthoc = entry$posthoc,
          y_limits = shared_y_limits
        )
      })
      names(stratum_plots) <- vapply(stats_entries, function(x) x$label, character(1))
      stratum_plots <- Filter(Negate(is.null), stratum_plots)

      if (!length(stratum_plots)) return(NULL)

      strata_panel_count <<- max(strata_panel_count, length(stratum_plots))
      combined <- patchwork::wrap_plots(
        plotlist = stratum_plots,
        nrow = context$strata_layout$nrow,
        ncol = context$strata_layout$ncol
      )

      title_plot <- ggplot() +
        ta_plot_theme_void() +
        ggtitle(resp) +
        theme(plot.title = element_text(size = base_size, face = "bold", hjust = 0.5))

      title_plot / combined + patchwork::plot_layout(heights = c(0.08, 1))
    } else if (length(stats_entries) > 0) {
      entry <- stats_entries[[1]]
      build_bar_plot_panel(
        stats_df = entry$stats_df,
        title_text = entry$label,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_fill = base_fill,
        base_size = base_size,
        posthoc_entry = entry$posthoc,
        nested_posthoc = entry$posthoc,
        y_limits = shared_y_limits
      )
    }
  }

  response_plots <- lapply(context$responses, build_response_plot)
  names(response_plots) <- context$responses
  response_plots <- Filter(Negate(is.null), response_plots)

  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = isTRUE(common_legend),
    legend_position = if (isTRUE(common_legend)) legend_position_value else NULL
  )
}

compute_barplot_shared_limits <- function(context,
                                          data,
                                          factor1,
                                          factor2,
                                          posthoc_all = NULL) {
  combined <- NULL

  for (resp in context$responses) {
    posthoc_entry <- get_posthoc_entry_for_response(posthoc_all, resp)
    stats_entries <- generate_anova_stats_entries(
      context = context,
      data = data,
      resp = resp,
      factor1 = factor1,
      factor2 = factor2,
      posthoc_entry = posthoc_entry
    )

    for (entry in stats_entries) {
      rng <- compute_barplot_panel_range(
        entry$stats_df,
        factor1,
        factor2,
        posthoc_entry = entry$posthoc,
        nested_posthoc = entry$posthoc
      )
      combined <- update_numeric_range(combined, rng)
    }
  }

  if (is.null(combined)) return(NULL)
  
  limits <- expand_axis_limits(combined, lower_mult = 0.05, upper_mult = 0.12)
  ensure_barplot_zero_baseline(limits)
}

compute_barplot_panel_range <- function(stats_df,
                                        factor1,
                                       factor2,
                                       posthoc_entry = NULL,
                                       nested_posthoc = NULL) {
  if (is.null(stats_df) || nrow(stats_df) == 0) return(NULL)
  values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
  values <- values[is.finite(values)]
  if (length(values) == 0) return(NULL)
  range(values)
}

expand_axis_limits <- function(range_vals, lower_mult = 0.05, upper_mult = 0.12) {
  if (is.null(range_vals) || length(range_vals) != 2 || any(!is.finite(range_vals))) return(range_vals)
  span <- diff(range_vals)
  if (!is.finite(span) || span == 0) span <- max(1, abs(range_vals[2]))
  c(range_vals[1] - span * lower_mult, range_vals[2] + span * upper_mult)
}

ensure_barplot_zero_baseline <- function(range_vals) {
  if (is.null(range_vals) || length(range_vals) != 2 || any(!is.finite(range_vals))) {
    return(range_vals)
  }

  if (!is.na(range_vals[1])) range_vals[1] <- 0
  range_vals
}

get_posthoc_entry_for_response <- function(posthoc_all, resp) {
  if (is.null(posthoc_all) || is.null(posthoc_all[[resp]])) return(NULL)
  posthoc_all[[resp]]
}

generate_anova_stats_entries <- function(context,
                                         data,
                                         resp,
                                         factor1,
                                         factor2,
                                         posthoc_entry) {
  entries <- list()
  has_strata <- context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)

  if (has_strata) {
    for (stratum in context$strata_levels) {
      subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
      subset_data <- data[subset_rows, , drop = FALSE]
      if (nrow(subset_data) == 0) next

      stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) next

      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)

      stratum_posthoc <- NULL
      if (!is.null(posthoc_entry) && !is.null(posthoc_entry[[stratum]])) {
        stratum_posthoc <- posthoc_entry[[stratum]]
      }

      entries[[length(entries) + 1]] <- list(
        label = stratum,
        stats_df = stats_df,
        posthoc = stratum_posthoc
      )
    }
  } else {
    stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
    if (nrow(stats_df) == 0) return(entries)

    stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)

    entries[[1]] <- list(
      label = resp,
      stats_df = stats_df,
      posthoc = posthoc_entry
    )
  }

  entries
}

build_bar_plot_panel <- function(stats_df,
                                 title_text,
                                 factor1,
                                 factor2,
                                 line_colors,
                                 base_fill,
                                 base_size = 14,
                                 posthoc_entry = NULL,
                                 nested_posthoc = NULL,
                                 y_limits = NULL) {
  if (is.null(y_limits)) {
    panel_range <- compute_barplot_panel_range(
      stats_df,
      factor1,
      factor2,
      posthoc_entry = posthoc_entry,
      nested_posthoc = nested_posthoc
    )
    
    if (!is.null(panel_range)) {
      y_limits <- expand_axis_limits(panel_range, lower_mult = 0, upper_mult = 0.12)
      y_limits <- ensure_barplot_zero_baseline(y_limits)
    }
  }
  
  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    return(
      build_single_factor_barplot(
        stats_df = stats_df,
        title_text = title_text,
        factor1 = factor1,
        base_fill = base_fill,
        base_size = base_size,
        posthoc_entry = posthoc_entry,
        y_limits = y_limits
      )
    )
  }
  
  build_two_factor_barplot(
    stats_df = stats_df,
    title_text = title_text,
    factor1 = factor1,
    factor2 = factor2,
    line_colors = line_colors,
    base_fill = base_fill,
    base_size = base_size,
    nested_posthoc = nested_posthoc,
    y_limits = y_limits
  )
}

build_single_factor_barplot <- function(stats_df,
                                        title_text,
                                        factor1,
                                        base_fill,
                                        base_size,
                                        posthoc_entry,
                                        y_limits = NULL) {
  plot_obj <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean)) +
    geom_col(fill = base_fill, width = 0.6, alpha = 0.8) +
    geom_errorbar(
      aes(ymin = mean - se, ymax = mean + se),
      width = 0.15,
      color = "gray40",
      linewidth = 0.5
    ) +
    ta_plot_theme(base_size = base_size) +
    labs(x = factor1, y = "Mean Â± SE", title = title_text) +
    theme(
      plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
      axis.title.x = element_text(margin = margin(t = 6)),
      axis.title.y = element_text(margin = margin(r = 6)),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af")
    )
  
  plot_obj <- add_significance_after_build(
    p = plot_obj,
    stats_df = stats_df,
    factor1 = factor1,
    factor2 = NULL,
    posthoc_entry = posthoc_entry
  )
  
  plot_obj
}

build_two_factor_barplot <- function(stats_df,
                                     title_text,
                                     factor1,
                                     factor2,
                                     line_colors,
                                     base_fill,
                                     base_size,
                                     nested_posthoc = NULL,
                                     y_limits = NULL) {
  group_levels <- if (is.factor(stats_df[[factor2]])) {
    levels(stats_df[[factor2]])
  } else {
    unique(as.character(stats_df[[factor2]]))
  }
  group_levels <- group_levels[!is.na(group_levels)]
  palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
  dodge <- position_dodge(width = 0.7)
  
  plot_obj <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean, fill = !!sym(factor2))) +
    geom_col(position = dodge, width = 0.6, alpha = 0.85) +
    geom_errorbar(
      aes(ymin = mean - se, ymax = mean + se),
      position = dodge,
      width = 0.2,
      color = "gray40",
      linewidth = 0.5
    ) +
    ta_plot_theme(base_size = base_size) +
    labs(x = factor1, y = "Mean Â± SE", fill = factor2, title = title_text) +
    theme(
      plot.title = element_text(size = base_size, face = "bold", hjust = 0.5),
      axis.title.x = element_text(margin = margin(t = 6)),
      axis.title.y = element_text(margin = margin(r = 6)),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.line = element_line(color = "#9ca3af"),
      axis.ticks = element_line(color = "#9ca3af")
    ) +
    scale_fill_manual(values = palette)
  
  plot_obj <- add_significance_after_build(
    p = plot_obj,
    stats_df = stats_df,
    factor1 = factor1,
    factor2 = factor2,
    posthoc_entry = nested_posthoc
  )
  
  plot_obj
}

#### Section: Significance Annotation System (ggplot_build-based) ####

extract_bar_positions <- function(p, factor1, factor2 = NULL) {
  built <- ggplot_build(p)
  layer <- built$data[[1]]
  original <- built$plot$data
  
  y_top <- if ("ymax" %in% names(layer)) {
    layer$ymax
  } else if ("y" %in% names(layer)) {
    layer$y
  } else {
    rep(NA_real_, nrow(layer))
  }
  
  df <- data.frame(
    x = layer$x,
    y = y_top
  )
  
  df[[factor1]] <- original[[factor1]]
  
  if (!is.null(factor2)) {
    df[[factor2]] <- original[[factor2]]
  }
  
  df
}

clean_p_values_barplot <- function(x) {
  x <- as.character(x)
  x <- gsub("[[:space:]]", "", x)
  x <- gsub("^<\\.?0*", "0.", x)
  suppressWarnings(as.numeric(x))
}

build_annotations_single_factor <- function(barpos,
                                            posthoc_entry,
                                            factor1,
                                            offset_mult = 0.12) {
  if (is.null(posthoc_entry) || nrow(posthoc_entry) == 0) return(NULL)
  
  levels_f1 <- unique(as.character(barpos[[factor1]]))
  if (length(levels_f1) < 2) return(NULL)
  reference <- levels_f1[1]
  
  posthoc_entry <- posthoc_entry |> dplyr::mutate(
    p.value = clean_p_values_barplot(.data$p.value)
  )
  posthoc_entry <- posthoc_entry |> dplyr::filter(!is.na(.data$p.value))
  if (nrow(posthoc_entry) == 0) return(NULL)
  
  values <- barpos$y[is.finite(barpos$y)]
  if (length(values) == 0) return(NULL)
  offset <- compute_annotation_offset(values, offset_mult)
  
  res <- list()
  
  for (lvl in levels_f1[-1]) {
    contrasts <- c(
      paste0(lvl, " - ", reference),
      paste0(reference, " - ", lvl)
    )
    
    row <- posthoc_entry[posthoc_entry$contrast %in% contrasts, , drop = FALSE]
    if (nrow(row) == 0) next
    
    p <- row$p.value[1]
    if (is.na(p) || p >= 0.05) next
    
    label <- dplyr::case_when(
      p < 0.001 ~ "***",
      p < 0.01 ~ "**",
      p < 0.05 ~ "*",
      TRUE ~ ""
    )
    if (label == "") next
    
    bar_row <- barpos[as.character(barpos[[factor1]]) == lvl, , drop = FALSE]
    if (nrow(bar_row) == 0) next
    
    res[[length(res) + 1]] <- data.frame(
      x = bar_row$x[1],
      y = bar_row$y[1] + offset,
      label = label
    )
  }
  
  if (length(res) == 0) return(NULL)
  
  do.call(rbind, res)
}

build_annotations_two_factor <- function(barpos,
                                         nested_posthoc,
                                         factor1,
                                         factor2,
                                         offset_mult = 0.12) {
  if (is.null(nested_posthoc)) return(NULL)
  
  nested_name <- paste0(factor2, "_within_", factor1)
  
  df <- NULL
  if (is.data.frame(nested_posthoc)) {
    if ("Factor" %in% names(nested_posthoc)) {
      df <- nested_posthoc |> dplyr::filter(.data$Factor == nested_name)
    } else {
      df <- nested_posthoc
    }
  } else if (is.list(nested_posthoc) && nested_name %in% names(nested_posthoc)) {
    df <- nested_posthoc[[nested_name]]
  } else {
    return(NULL)
  }
  
  if (is.null(df) || nrow(df) == 0) return(NULL)
  if (!all(c("contrast", "p.value", factor1) %in% names(df))) return(NULL)
  
  df <- df |> dplyr::mutate(
    p.value = clean_p_values_barplot(.data$p.value)
  )
  df <- df |> dplyr::filter(!is.na(.data$p.value))
  if (nrow(df) == 0) return(NULL)
  
  lev1 <- unique(as.character(barpos[[factor1]]))
  lev2 <- unique(as.character(barpos[[factor2]]))
  lev1 <- lev1[!is.na(lev1)]
  lev2 <- lev2[!is.na(lev2)]
  if (length(lev2) < 2) return(NULL)
  reference <- lev2[1]
  
  values <- barpos$y[is.finite(barpos$y)]
  if (length(values) == 0) return(NULL)
  offset <- compute_annotation_offset(values, offset_mult)
  
  res <- list()
  
  for (g1 in lev1) {
    for (lvl in lev2[lev2 != reference]) {
      contrasts <- c(
        paste0(lvl, " - ", reference),
        paste0(reference, " - ", lvl)
      )
      
      sub <- df[df[[factor1]] == g1 & df$contrast %in% contrasts, , drop = FALSE]
      if (nrow(sub) == 0) next
      
      p <- sub$p.value[1]
      if (is.na(p) || p >= 0.05) next
      
      label <- dplyr::case_when(
        p < 0.001 ~ "***",
        p < 0.01 ~ "**",
        p < 0.05 ~ "*",
        TRUE ~ ""
      )
      if (label == "") next
      
      bar_row <- barpos[
        as.character(barpos[[factor1]]) == g1 &
          as.character(barpos[[factor2]]) == lvl,
        ,
        drop = FALSE
      ]
      if (nrow(bar_row) == 0) next
      
      res[[length(res) + 1]] <- data.frame(
        x = bar_row$x[1],
        y = bar_row$y[1] + offset,
        label = label
      )
    }
  }
  
  if (length(res) == 0) return(NULL)

  do.call(rbind, res)
}

compute_annotation_offset <- function(values, offset_mult) {
  span <- diff(range(values))
  if (!is.finite(span) || span == 0) span <- max(values)
  if (is.finite(span) && span > 0) span * offset_mult else 0.1
}

add_significance_after_build <- function(p,
                                         stats_df,
                                         factor1,
                                         factor2 = NULL,
                                         posthoc_entry = NULL,
                                         text_size = 4) {
  if (is.null(posthoc_entry)) return(p)
  
  barpos <- extract_bar_positions(p, factor1, factor2)
  barpos <- barpos[is.finite(barpos$y), , drop = FALSE]
  if (nrow(barpos) == 0) return(p)
  
  if (is.null(factor2)) {
    ann <- build_annotations_single_factor(
      barpos = barpos,
      posthoc_entry = posthoc_entry,
      factor1 = factor1
    )
  } else {
    ann <- build_annotations_two_factor(
      barpos = barpos,
      nested_posthoc = posthoc_entry,
      factor1 = factor1,
      factor2 = factor2
    )
  }
  
  if (is.null(ann) || nrow(ann) == 0) return(p)
  
  max_y_text <- max(ann$y, na.rm = TRUE)
  
  p_build <- ggplot_build(p)
  current_limits <- p_build$layout$panel_params[[1]]$y.range
  
  new_upper <- max(current_limits[2], max_y_text * 1.05)
  
  p +
    scale_y_continuous(
      limits = c(0, new_upper),
      expand = expansion(mult = c(0, 0))
    ) +
    geom_text(
      data = ann,
      aes(x = x, y = y, label = label),
      inherit.aes = FALSE,
      color = "gray30",
      size = text_size,
      fontface = "bold"
    )
  
}
#### Section: Summary Calculations ####

anova_summarise_stats <- function(df_subset, resp_name, factor1, factor2) {
  if (is.null(factor1) || !factor1 %in% names(df_subset)) {
    return(tibble::tibble())
  }

  if (is.null(factor2) || !factor2 %in% names(df_subset)) {
    df_subset |>
      dplyr::group_by(.data[[factor1]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  } else {
    df_subset |>
      dplyr::group_by(.data[[factor1]], .data[[factor2]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  }
}

apply_anova_factor_levels <- function(stats_df, factor1, factor2, order1, order2) {
  if (!is.null(factor1) && factor1 %in% names(stats_df)) {
    if (!is.null(order1)) {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]), levels = order1)
    } else {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]))
    }
  }

  if (!is.null(factor2) && factor2 %in% names(stats_df)) {
    levels2 <- if (!is.null(order2)) {
      order2
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = levels2)
  }

  stats_df
}
#### Section: Lineplot Construction ####

plot_anova_lineplot_meanse <- function(data,
                                       info,
                                       layout_values,
                                       line_colors = NULL,
                                       base_size = 14,
                                       show_lines = FALSE,
                                       show_jitter = FALSE,
                                       use_dodge = FALSE,
                                       share_y_axis = FALSE,
                                       common_legend = FALSE,
                                       legend_position = NULL) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2
  
  allowed_positions <- c("bottom", "top", "left", "right")
  legend_position_value <- if (!is.null(legend_position) && legend_position %in% allowed_positions) {
    legend_position
  } else {
    "bottom"
  }
  
  shared_y_limits <- if (isTRUE(share_y_axis)) {
    compute_lineplot_shared_limits(context, data, factor1, factor2)
  } else {
    NULL
  }
  
  response_plots <- list()
  strata_panel_count <- context$initial_strata_panels
  
  for (resp in context$responses) {
    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      stratum_stats <- list()
      y_values <- c()
      
      for (stratum in context$strata_levels) {
        subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
        subset_data <- data[subset_rows, , drop = FALSE]
        if (nrow(subset_data) == 0) {
          next
        }
        
        stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
        if (nrow(stats_df) == 0) {
          next
        }
        
        stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
        y_values <- c(y_values, stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
        stratum_stats[[stratum]] <- list(
          stats = stats_df,
          raw = prepare_lineplot_raw_data(subset_data, resp, factor1, factor2)
        )
      }
      
      if (length(stratum_stats) == 0) {
        next
      }
      
      y_limits <- range(y_values, na.rm = TRUE)
      if (!all(is.finite(y_limits))) {
        y_limits <- NULL
      }
      y_limits_to_use <- if (!is.null(shared_y_limits)) shared_y_limits else y_limits
      
      strata_panel_count <- max(strata_panel_count, length(stratum_stats))
      
      strata_plot_list <- lapply(names(stratum_stats), function(stratum_name) {
        entry <- stratum_stats[[stratum_name]]
        build_line_plot_panel(
          stats_df = entry$stats,
          title_text = stratum_name,
          y_limits = y_limits_to_use,
          factor1 = factor1,
          factor2 = factor2,
          line_colors = line_colors,
          base_size = base_size,
          raw_data = entry$raw,
          response_var = resp,
          show_lines = show_lines,
          show_jitter = show_jitter,
          use_dodge = use_dodge
        )
      })

      combined <- patchwork::wrap_plots(
        plotlist = strata_plot_list,
        nrow = context$strata_layout$nrow,
        ncol = context$strata_layout$ncol
      )
      
      if (isTRUE(common_legend)) {
        combined <- collect_guides_safe(combined)
      }
      
      title_plot <- ggplot() +
        ta_plot_theme_void() +
        ggtitle(resp) +
        theme(
          plot.title = element_text(
            size = base_size,
            face = "bold",
            hjust = 0.5
          ),
          plot.margin = margin(t = 0, r = 0, b = 6, l = 0)
        )
      
      response_plots[[resp]] <- title_plot / combined + plot_layout(heights = c(0.08, 1))
    } else {
      stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) {
        next
      }
      
      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
      y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
      y_limits <- range(y_values, na.rm = TRUE)
      if (!all(is.finite(y_limits))) {
        y_limits <- NULL
      }
      
      y_limits_to_use <- if (!is.null(shared_y_limits)) shared_y_limits else y_limits
      
      response_plots[[resp]] <- build_line_plot_panel(
        stats_df = stats_df,
        title_text = resp,
        y_limits = y_limits_to_use,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_size = base_size,
        raw_data = prepare_lineplot_raw_data(data, resp, factor1, factor2),
        response_var = resp,
        show_lines = show_lines,
        show_jitter = show_jitter,
        use_dodge = use_dodge
      )
    }
  }
  
  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = isTRUE(common_legend),
    legend_position = if (isTRUE(common_legend)) legend_position_value else NULL
  )
}

compute_lineplot_shared_limits <- function(context, data, factor1, factor2) {
  combined <- NULL

  for (resp in context$responses) {
    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      for (stratum in context$strata_levels) {
        subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
        subset_data <- data[subset_rows, , drop = FALSE]
        if (nrow(subset_data) == 0) next

        stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
        if (nrow(stats_df) == 0) next

        stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
        y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
        combined <- update_numeric_range(combined, y_values)
      }
    } else {
      stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) next
      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
      y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
      combined <- update_numeric_range(combined, y_values)
    }
  }

  if (is.null(combined) || any(!is.finite(combined))) return(NULL)
  combined
}


prepare_lineplot_raw_data <- function(df, response_var, factor1, factor2 = NULL) {
  if (is.null(df) || is.null(response_var) || is.null(factor1)) return(NULL)
  if (!response_var %in% names(df) || !factor1 %in% names(df)) return(NULL)
  
  cols <- c(factor1, factor2, response_var)
  cols <- cols[!vapply(cols, is.null, FUN.VALUE = logical(1), USE.NAMES = FALSE)]
  cols <- unique(cols)
  cols <- cols[cols %in% names(df)]
  if (!response_var %in% cols || !factor1 %in% cols) return(NULL)
  
  raw_subset <- df[, cols, drop = FALSE]
  raw_subset <- raw_subset[!is.na(raw_subset[[response_var]]), , drop = FALSE]
  if (nrow(raw_subset) == 0) return(NULL)
  raw_subset
}


build_line_plot_panel <- function(stats_df,
                                  title_text,
                                  y_limits,
                                  factor1,
                                  factor2,
                                  line_colors,
                                  base_size = 13,
                                  raw_data = NULL,
                                  response_var = NULL,
                                  show_lines = FALSE,
                                  show_jitter = FALSE,
                                  use_dodge = FALSE) {
  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    color_value <- if (!is.null(line_colors) && length(line_colors) > 0) {
      unname(line_colors)[1]
    } else {
      resolve_single_color()
    }
    p <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean))

    if (isTRUE(show_jitter) && !is.null(raw_data) &&
        !is.null(response_var) && response_var %in% names(raw_data) &&
        factor1 %in% names(raw_data)) {
      jitter_df <- raw_data[!is.na(raw_data[[response_var]]), , drop = FALSE]
      if (nrow(jitter_df) > 0) {
        p <- p + geom_jitter(
          data = jitter_df,
          aes(x = !!sym(factor1), y = !!sym(response_var)),
          width = 0.12,
          alpha = 0.35,
          size = 1.7,
          color = color_value,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
      }
    }

    if (isTRUE(show_lines)) {
      p <- p + geom_line(aes(group = 1), color = color_value, linewidth = 1)
    }

    p <- p +
      geom_point(size = 3, color = color_value) +
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        color = color_value
      ) +
      ta_plot_theme(base_size = base_size) +
      labs(x = factor1, y = "Mean Â± SE") +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.line = element_line(color = "#9ca3af"),
        axis.ticks = element_line(color = "#9ca3af")
      )
  } else {
    group_levels <- if (is.factor(stats_df[[factor2]])) {
      levels(stats_df[[factor2]])
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    group_levels <- group_levels[!is.na(group_levels)]
    palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = group_levels)
    dodge_width <- if (isTRUE(use_dodge)) 0.4 else NULL
    dodge <- if (!is.null(dodge_width)) position_dodge(width = dodge_width) else NULL
    jitter_dodge_width <- if (is.null(dodge_width)) 0 else dodge_width
    p <- ggplot(stats_df, aes(
      x = !!sym(factor1),
      y = mean,
      color = !!sym(factor2),
      group = !!sym(factor2)
    ))

    if (isTRUE(show_jitter) && !is.null(raw_data) && !is.null(response_var) &&
        all(c(factor1, factor2) %in% names(raw_data)) &&
        response_var %in% names(raw_data)) {
      jitter_df <- raw_data[!is.na(raw_data[[response_var]]), , drop = FALSE]
      if (nrow(jitter_df) > 0) {
        jitter_df[[factor2]] <- factor(as.character(jitter_df[[factor2]]), levels = group_levels)
        p <- p + geom_jitter(
          data = jitter_df,
          aes(x = !!sym(factor1), y = !!sym(response_var), color = !!sym(factor2)),
          position = position_jitterdodge(jitter.width = 0.15, dodge.width = jitter_dodge_width),
          size = 1.6,
          alpha = 0.4,
          inherit.aes = FALSE,
          show.legend = FALSE
        )
      }
    }

    if (isTRUE(show_lines)) {
      if (is.null(dodge)) {
        p <- p + geom_line(linewidth = 1)
      } else {
        p <- p + geom_line(linewidth = 1, position = dodge)
      }
    }

    point_layer <- if (is.null(dodge)) {
      geom_point(size = 3)
    } else {
      geom_point(size = 3, position = dodge)
    }

    errorbar_layer <- if (is.null(dodge)) {
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15
      )
    } else {
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        position = dodge
      )
    }

    p <- p +
      point_layer +
      errorbar_layer +
      ta_plot_theme(base_size = base_size) +
      labs(
        x = factor1,
        y = "Mean Â± SE",
        color = factor2
      ) +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.line = element_line(color = "#9ca3af"),
        axis.ticks = element_line(color = "#9ca3af")
      ) +
      scale_color_manual(values = palette)
  }

  if (!is.null(y_limits) && all(is.finite(y_limits))) {
    p <- p + scale_y_continuous(limits = y_limits)
  }

  p + ggtitle(title_text) +
    theme(
      plot.title = element_text(
        size = base_size,
        face = "bold",
        hjust = 0.5
      )
    )
}





#### Section: Model Fitting & Preparation ####

prepare_stratified_anova <- function(
    df,
    responses,
    model,
    factor1_var = NULL,
    factor1_order = NULL,
    factor2_var = NULL,
    factor2_order = NULL,
    stratification = NULL,
    stratify_var = NULL,
    strata_order = NULL
) {
  req(df, responses, model)

  if (!is.null(stratification)) {
    if (!is.null(stratification$var)) {
      stratify_var <- stratification$var
    }
    if (!is.null(stratification$levels)) {
      strata_order <- stratification$levels
    }
  }

  

  df <- df |>
    set_factor_levels(factor1_var, factor1_order) |>
    set_factor_levels(factor2_var, factor2_order) |>
    set_factor_levels(stratify_var, strata_order, default_factor = TRUE)

  strata <- if (!is.null(stratify_var) && stratify_var %in% names(df)) {
    levels(df[[stratify_var]])
  } else {
    NULL
  }

  factor1_rhs <- anova_protect_vars(factor1_var)
  factor2_rhs <- anova_protect_vars(factor2_var)

  rhs <- switch(
    model,
    oneway_anova = factor1_rhs,
    twoway_anova = if (length(factor1_rhs) > 0 && length(factor2_rhs) > 0) {
      paste(factor1_rhs, factor2_rhs, sep = " *")
    } else {
      factor1_rhs
    },
    factor1_rhs
  )
  rhs <- if (is.null(rhs) || rhs == "") "1" else rhs

  build_formula <- function(resp) stats::as.formula(paste(anova_protect_vars(resp), "~", rhs))
  safe_fit <- purrr::safely(function(fml, data) stats::aov(fml, data = data))

  base_info <- list(
    type = model,
    responses = responses,
    factors = list(factor1 = factor1_var, factor2 = factor2_var),
    orders = list(order1 = factor1_order, order2 = factor2_order),
    data_used = df
  )

  if (is.null(strata)) {
    return(c(base_info, list(models = fit_models_for_data(df, responses, build_formula, safe_fit), strata = NULL)))
  }

  models <- lapply(strata, function(s) {
    subset_rows <- df[[stratify_var]] == s & !is.na(df[[stratify_var]])
    fit_models_for_data(df[subset_rows, , drop=FALSE], responses, build_formula, safe_fit)
  })
  names(models) <- strata

  c(base_info, list(models = models, strata = list(var = stratify_var, levels = strata)))
}


set_factor_levels <- function(data, var, levels = NULL, default_factor = FALSE) {
  if (is.null(var) || !var %in% names(data)) return(data)
  if (!is.null(levels)) {
    data[[var]] <- factor(as.character(data[[var]]), levels = levels)
  } else if (default_factor) {
    data[[var]] <- as.factor(as.character(data[[var]]))
  }
  data
}


fit_models_for_data <- function(data, responses, build_formula, safe_fit) {
  lapply(responses, function(resp) {
    fit_result <- safe_fit(build_formula(resp), data)
    list(
      model = fit_result$result,
      error = if (!is.null(fit_result$error)) conditionMessage(fit_result$error) else NULL
    )
  }) |>
    stats::setNames(responses)
}


compile_anova_results <- function(model_info) {
  if (is.null(model_info) || is.null(model_info$models)) return(NULL)

  factor_names <- unlist(model_info$factors)
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]

  if (is.null(model_info$strata)) {
    summary_list <- list()
    posthoc_list <- list()
    effects_list <- list()
    errors_list <- list()

    for (resp in names(model_info$models)) {
      entry <- model_info$models[[resp]]
      entry_errors <- character(0)
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_errors <- c(entry_errors, outputs$error)
          summary_list[[resp]] <- NULL
          posthoc_list[[resp]] <- NULL
          effects_list[[resp]] <- NULL
        } else {
          summary_list[[resp]] <- outputs$anova_table
          posthoc_list[[resp]] <- outputs$posthoc_table
          effects_list[[resp]] <- build_effects(outputs)
        }
      } else {
        summary_list[[resp]] <- NULL
        posthoc_list[[resp]] <- NULL
        effects_list[[resp]] <- NULL
      }
      if (!is.null(entry$error)) {
        entry_errors <- c(entry_errors, entry$error)
      }
      if (length(entry_errors) > 0) {
        errors_list[[resp]] <- paste(unique(entry_errors), collapse = "\n")
      }
    }

    return(list(
      summary = summary_list,
      posthoc = posthoc_list,
      effects = effects_list,
      errors = errors_list
    ))
  }

  summary_list <- list()
  posthoc_list <- list()
  effects_list <- list()
  errors_list <- list()

  for (stratum_name in names(model_info$models)) {
    stratum_models <- model_info$models[[stratum_name]]
    if (is.null(stratum_models)) next

    for (resp in names(stratum_models)) {
      entry <- stratum_models[[resp]]
      outputs <- NULL
      entry_error <- NULL
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_error <- outputs$error
          outputs <- NULL
        }
      }

      if (is.null(summary_list[[resp]])) summary_list[[resp]] <- list()
      if (is.null(posthoc_list[[resp]])) posthoc_list[[resp]] <- list()
      if (is.null(effects_list[[resp]])) effects_list[[resp]] <- list()
      if (is.null(errors_list[[resp]])) errors_list[[resp]] <- list()

      summary_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$anova_table else NULL
      posthoc_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$posthoc_table else NULL
      effects_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) build_effects(outputs) else NULL

      if (!is.null(entry$error)) {
        entry_error <- c(entry_error, entry$error)
      }

      if (!is.null(entry_error)) {
        errors_list[[resp]][[stratum_name]] <- paste(unique(entry_error), collapse = "\n")
      }
    }
  }


  list(
    summary = summary_list,
    posthoc = posthoc_list,
    effects = effects_list,
    errors = errors_list
  )
}


build_effects <- function(outputs) {
  if (is.null(outputs) || is.null(outputs$anova_table)) return(NULL)
  effects <- data.frame(
    Effect = outputs$anova_table$Effect,
    significant = outputs$anova_significant,
    stringsAsFactors = FALSE
  )
  if ("p.value" %in% names(outputs$anova_table)) {
    effects$p.value <- outputs$anova_table$p.value
  }
  effects
}#### Section: Plot Context Initialization ####

initialize_anova_plot_context <- function(data, info, layout_values) {
  factor1 <- info$factors$factor1
  factor2 <- info$factors$factor2
  order1 <- info$orders$order1
  order2 <- info$orders$order2

  if (!is.null(factor1) && !is.null(order1) && factor1 %in% names(data)) {
    data[[factor1]] <- factor(data[[factor1]], levels = order1)
  }
  if (!is.null(factor2) && !is.null(order2) && factor2 %in% names(data)) {
    data[[factor2]] <- factor(data[[factor2]], levels = order2)
  }

  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  strat_var <- if (has_strata) info$strata$var else NULL
  strata_levels <- if (has_strata) info$strata$levels else character(0)

  if (has_strata && (is.null(strata_levels) || length(strata_levels) == 0) &&
      !is.null(strat_var) && strat_var %in% names(data)) {
    strata_levels <- unique(as.character(stats::na.omit(data[[strat_var]])))
  }

  layout_input <- parse_anova_layout_inputs(layout_values)

  n_expected_strata <- if (has_strata) max(1L, length(strata_levels)) else 1L
  strata_defaults <- if (has_strata) {
    compute_default_grid(n_expected_strata)
  } else {
    list(rows = 1L, cols = 1L)
  }
  strata_layout <- basic_grid_layout(
    rows = layout_input$strata_rows,
    cols = layout_input$strata_cols,
    default_rows = strata_defaults$rows,
    default_cols = strata_defaults$cols
  )

  list(
    data = data,
    responses = info$responses,
    factor1 = factor1,
    factor2 = factor2,
    order1 = order1,
    order2 = order2,
    has_strata = has_strata,
    strat_var = strat_var,
    strata_levels = strata_levels,
    n_expected_strata = n_expected_strata,
    strata_defaults = strata_defaults,
    strata_layout = strata_layout,
    layout_input = layout_input,
    initial_strata_panels = if (has_strata) 0L else 1L
  )
}

parse_anova_layout_inputs <- function(layout_values) {
  list(
    strata_rows = suppressWarnings(as.numeric(layout_values$strata_rows)),
    strata_cols = suppressWarnings(as.numeric(layout_values$strata_cols)),
    resp_rows   = suppressWarnings(as.numeric(layout_values$resp_rows)),
    resp_cols   = suppressWarnings(as.numeric(layout_values$resp_cols))
  )
}

update_numeric_range <- function(current_range, values) {
  values <- values[is.finite(values)]
  if (length(values) == 0) return(current_range)
  new_range <- range(values)
  if (any(!is.finite(new_range))) return(current_range)
  if (is.null(current_range)) {
    new_range
  } else {
    c(min(current_range[1], new_range[1]), max(current_range[2], new_range[2]))
  }
}

apply_common_legend_layout <- function(plot_obj,
                                       legend_position = NULL,
                                       collect_guides = FALSE) {
  if (is.null(plot_obj)) return(plot_obj)

  updated <- plot_obj
  if (collect_guides) {
    updated <- collect_guides_safe(updated)
  }

  if (!is.null(legend_position)) {
    updated <- add_theme_to_plot(updated, theme(legend.position = legend_position))
  }

  updated
}

collect_guides_safe <- function(plot_obj) {
  if (is.null(plot_obj) || !requireNamespace("patchwork", quietly = TRUE)) {
    return(plot_obj)
  }

  is_patchwork <- inherits(plot_obj, "patchwork")
  if (!is_patchwork) {
    return(plot_obj)
  }

  exports <- tryCatch(getNamespaceExports("patchwork"), error = function(...) character())
  collected <- if ("collect_guides" %in% exports) {
    patchwork::collect_guides(plot_obj)
  } else {
    plot_obj + patchwork::plot_layout(guides = "collect")
  }

  collected + patchwork::plot_layout(guides = "collect")
}

add_theme_to_plot <- function(plot_obj, theme_obj) {
  if (inherits(plot_obj, "patchwork")) {
    plot_obj & theme_obj
  } else {
    plot_obj + theme_obj
  }
}


finalize_anova_plot_result <- function(response_plots,
                                       context,
                                       strata_panel_count,
                                       collect_guides = FALSE,
                                       legend_position = NULL) {
  if (length(response_plots) == 0) {
    return(NULL)
  }
  
  has_strata <- context$has_strata
  strata_layout <- context$strata_layout
  
  if (has_strata && strata_panel_count == 0L) {
    strata_panel_count <- context$n_expected_strata
  }

  response_defaults <- compute_default_grid(length(response_plots))
  response_layout <- basic_grid_layout(
    rows = context$layout_input$resp_rows,
    cols = context$layout_input$resp_cols,
    default_rows = response_defaults$rows,
    default_cols = response_defaults$cols
  )

  strata_validation <- if (has_strata) {
    validate_grid(max(1L, strata_panel_count), strata_layout$nrow, strata_layout$ncol)
  } else {
    list(valid = TRUE, message = NULL)
  }
  
  response_validation <- validate_grid(
    length(response_plots),
    response_layout$nrow,
    response_layout$ncol
  )
  
  warnings <- c()
  if (has_strata && !strata_validation$valid && !is.null(strata_validation$message)) {
    warnings <- c(warnings, strata_validation$message)
  }
  if (!response_validation$valid && !is.null(response_validation$message)) {
    warnings <- c(warnings, response_validation$message)
  }
  warning_text <- if (length(warnings) > 0) paste(warnings, collapse = "<br/>") else NULL
  
  panel_counts <- list(
    strata = if (has_strata) max(1L, strata_panel_count) else 1L,
    responses = length(response_plots)
  )
  
  final_plot <- NULL
  if (is.null(warning_text)) {
    if (length(response_plots) == 1) {
      final_plot <- response_plots[[1]]
      if (collect_guides && !is.null(legend_position)) {
        final_plot <- final_plot & theme(legend.position = legend_position)
      }
    } else {
      final_plot <- patchwork::wrap_plots(
        plotlist = response_plots,
        nrow = response_layout$nrow,
        ncol = response_layout$ncol
      )
    }
    if (collect_guides || !is.null(legend_position)) {
      final_plot <- apply_common_legend_layout(
        final_plot,
        legend_position = legend_position,
        collect_guides = collect_guides
      )
    }
  }
  
  list(
    plot = final_plot,
    layout = list(
      strata = list(
        rows = if (has_strata) strata_layout$nrow else 1L,
        cols = if (has_strata) strata_layout$ncol else 1L
      ),
      responses = list(
        rows = response_layout$nrow,
        cols = response_layout$ncol
      )
    ),
    warning = warning_text,
    panel_counts = panel_counts,
    defaults = list(
      strata = context$strata_defaults,
      responses = response_defaults
    )
  )
}
#### Section: ANOVA Output Processing ####

prepare_anova_outputs <- function(model_obj, factor_names) {
  old_contrasts <- options("contrasts")
  on.exit(options(old_contrasts), add = TRUE)
  options(contrasts = c("contr.sum", "contr.poly"))

  safe_anova <- purrr::safely(function(mod) {
    car::Anova(mod, type = 3)
  })

  anova_result <- safe_anova(model_obj)
  if (!is.null(anova_result$error)) {
    return(list(
      error = conditionMessage(anova_result$error),
      anova_object = NULL,
      anova_table = NULL,
      anova_significant = NULL,
      posthoc_details = list(),
      posthoc_table = NULL,
      posthoc_significant = NULL
    ))
  }

  anova_obj <- anova_result$result
  anova_df <- as.data.frame(anova_obj)
  anova_df$Effect <- rownames(anova_df)
  rownames(anova_df) <- NULL
  anova_df <- anova_df[, c("Effect", setdiff(names(anova_df), "Effect"))]
  
  # --- round numeric columns and keep raw p-values ---
  p_col <- grep("^Pr", names(anova_df), value = TRUE)
  p_col <- if (length(p_col) > 0) p_col[1] else NULL
  raw_p <- if (!is.null(p_col)) anova_df[[p_col]] else rep(NA_real_, nrow(anova_df))

  for (col in names(anova_df)) {
    if (is.numeric(anova_df[[col]])) {
      anova_df[[col]] <- round(anova_df[[col]], 2)
    }
  }

  anova_significant <- !is.na(raw_p) & raw_p < 0.05
  if (!is.null(p_col)) {
    names(anova_df)[names(anova_df) == p_col] <- "p.value"
  } else {
    anova_df$p.value <- NA_real_
  }
  
  # --- Post-hoc Tukey for each factor ---
  factor_names <- unique(factor_names[!is.na(factor_names) & nzchar(factor_names)])
  posthoc_details <- list()
  posthoc_combined <- NULL
  posthoc_significant <- numeric(0)
  
  # --- Post-hoc Tukey (one-way or two-way specific) ---
  if (length(factor_names) == 1) {
    f1 <- factor_names[1]
    f1_spec <- anova_protect_vars(f1)

    res <- list(error = "Factor not found in model object.")
    if (f1 %in% names(model_obj$model)) {
      res <- tryCatch({
        emm <- emmeans::emmeans(model_obj, specs = as.formula(paste("~", f1_spec)))
        contrasts <- emmeans::contrast(emm, method = "pairwise", adjust = "tukey")
        summary_df <- as.data.frame(summary(contrasts))

        # Keep only contrasts that involve the reference level (first factor level)
        levs <- levels(model_obj$model[[f1]])
        if (!is.null(levs) && length(levs) > 0) {
          reference <- levs[1]
          summary_df <- summary_df[
            grepl(paste0(reference, " - "), summary_df$contrast) |
              grepl(paste0(" - ", reference), summary_df$contrast),
            ,
          ]
        }

        summary_df
      }, error = function(e) list(error = e$message))
    }

    if (is.data.frame(res)) {
      res$Factor <- f1
      posthoc_details[[f1]] <- list(table = res, error = NULL)
      posthoc_combined <- res
    } else {
      posthoc_details[[f1]] <- list(table = NULL, error = res$error)
    }

  } else if (length(factor_names) == 2) {
    f1 <- factor_names[1]
    f2 <- factor_names[2]

    f1_spec <- anova_protect_vars(f1)
    f2_spec <- anova_protect_vars(f2)

    # --- nested contrasts: keep ONLY comparisons vs the reference level of factor2 ---
    res_nested <- tryCatch({
      formula_nested <- as.formula(paste("pairwise ~", f2_spec, "|", f1_spec))
      emm_nested <- emmeans::emmeans(model_obj, specs = formula_nested, adjust = "tukey")
      contrasts_df <- as.data.frame(summary(emm_nested$contrasts))
      
      # Identify reference level (first level of factor2)
      lev2 <- levels(model_obj$model[[f2]])
      reference <- lev2[1]
      
      # Keep only contrasts involving the reference
      contrasts_df <- contrasts_df[
        grepl(paste0(reference, " - "), contrasts_df$contrast) |
          grepl(paste0(" - ", reference), contrasts_df$contrast),
        ,
      ]
      
      # Add metadata
      contrasts_df$Factor <- paste0(f2, "_within_", f1)
      contrasts_df[[f1]] <- as.character(contrasts_df[[f1]])
      contrasts_df
    }, error = function(e) list(error = e$message))
    
    
    if (is.data.frame(res_nested)) {
      posthoc_details[[paste0(f2, "_within_", f1)]] <- list(table = res_nested, error = NULL)
      posthoc_combined <- dplyr::bind_rows(posthoc_combined, res_nested)
    } else {
      posthoc_details[[paste0(f2, "_within_", f1)]] <- list(table = NULL, error = res_nested$error)
    }
  }
  
  
  if (!is.null(posthoc_combined)) {
    posthoc_combined <- posthoc_combined[, c("Factor", setdiff(names(posthoc_combined), "Factor"))]
    numeric_cols <- names(posthoc_combined)[sapply(posthoc_combined, is.numeric)]
    if (length(numeric_cols) > 0) {
      for (col in numeric_cols) {
        posthoc_combined[[col]] <- round(posthoc_combined[[col]], 2)
      }
    }
    
    if ("p.value" %in% names(posthoc_combined)) {
      raw_posthoc_p <- posthoc_combined$p.value
      posthoc_significant <- !is.na(raw_posthoc_p) & raw_posthoc_p < 0.05
    } else {
      posthoc_significant <- rep(FALSE, nrow(posthoc_combined))
    }
  }

  list(
    error = NULL,
    anova_object = anova_obj,
    anova_table = anova_df,
    anova_significant = anova_significant,
    posthoc_details = posthoc_details,
    posthoc_table = posthoc_combined,
    posthoc_significant = posthoc_significant
  )
}

#### Collate tidy summaries from ANOVA models ####

download_all_anova_results <- function(models_info, file) {
  if (is.null(models_info) || is.null(models_info$models)) {
    stop("No models found to export.")
  }

  combined_results <- list()
  contrast_results <- list()
  factor_names <- unique(unlist(models_info$factors))
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]
  errors <- character(0)

  # --- Case 1: no stratification
  if (is.null(models_info$strata)) {
    for (resp in models_info$responses) {
      model_entry <- models_info$models[[resp]]
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        if (!is.null(model_entry$error)) {
          errors <- c(errors, paste0(resp, ": ", model_entry$error))
        }
        next
      }
      outputs <- prepare_anova_outputs(model_entry$model, factor_names)
      if (!is.null(outputs$error)) {
        errors <- c(errors, paste0(resp, ": ", outputs$error))
        next
      }
      anova_obj <- outputs$anova_object
      if (is.null(anova_obj)) {
        errors <- c(errors, paste0(resp, ": ANOVA results are unavailable."))
        next
      }
      tbl <- as.data.frame(anova_obj)
      tbl$Response <- resp
      tbl$Stratum <- "None"
      tbl$Term <- rownames(tbl)
      rownames(tbl) <- NULL
      names(tbl) <- sub(" ", "", names(tbl))
      tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
      combined_results[[length(combined_results) + 1]] <- tbl

      if (!is.null(outputs$posthoc_table)) {
        contrast_tbl <- outputs$posthoc_table
        contrast_tbl$Response <- resp
        contrast_tbl$Stratum <- "None"
        contrast_results[[length(contrast_results) + 1]] <- contrast_tbl
      }
    }
  } else {
    # --- Case 2: stratified
    for (stratum in models_info$strata$levels) {
      for (resp in models_info$responses) {
        model_entry <- models_info$models[[stratum]][[resp]]
        if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
          if (!is.null(model_entry$error)) {
            errors <- c(errors, paste0(resp, " (", stratum, "): ", model_entry$error))
          }
          next
        }
        outputs <- prepare_anova_outputs(model_entry$model, factor_names)
        if (!is.null(outputs$error)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ", outputs$error))
          next
        }
        anova_obj <- outputs$anova_object
        if (is.null(anova_obj)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ANOVA results are unavailable."))
          next
        }
        tbl <- as.data.frame(anova_obj)
        tbl$Response <- resp
        tbl$Stratum <- stratum
        tbl$Term <- rownames(tbl)
        rownames(tbl) <- NULL
        names(tbl) <- sub(" ", "", names(tbl))
        tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
        combined_results[[length(combined_results) + 1]] <- tbl

        if (!is.null(outputs$posthoc_table)) {
          contrast_tbl <- outputs$posthoc_table
          contrast_tbl$Response <- resp
          contrast_tbl$Stratum <- stratum
          contrast_results[[length(contrast_results) + 1]] <- contrast_tbl
        }
      }
    }
  }

  if (length(combined_results) == 0 && length(contrast_results) == 0) {
    msg <- "No ANOVA models available to export."
    if (length(errors) > 0) {
      msg <- paste0(
        msg,
        " The following issues were reported:\n",
        paste(sprintf("- %s", unique(errors)), collapse = "\n")
      )
    }
    stop(msg)
  }

  write_anova_docx(
    file = file,
    content = list(anova = combined_results, contrasts = contrast_results)
  )
}

write_anova_docx <- function(file, content, response_name = NULL, stratum_label = NULL) {

  prep <- prepare_docx_tables(content, response_name, stratum_label)
  combined_anova <- prep$anova
  combined_contrasts <- prep$contrasts

  if (is.null(combined_anova) || length(combined_anova) == 0) {
    stop("No ANOVA results available to export.")
  }

  combined <- bind_rows(combined_anova)

  required_cols <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF")
  if (!all(required_cols %in% names(combined))) stop("Missing required columns in ANOVA results.")

  combined <- combined %>%
    mutate(
      SumSq = round(SumSq, 3),
      Fvalue = round(Fvalue, 3),
      PrF_label = ifelse(PrF < 0.001, "<0.001", sprintf("%.3f", PrF)),
      sig = PrF < 0.05
    ) %>%
    arrange(Response, Stratum, Term)

  if (length(unique(combined$Stratum)) == 1 && unique(combined$Stratum) == "None") {
    combined$Stratum <- NULL
    visible_cols <- c("Response", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    merge_cols <- c("Response")
  } else {
    visible_cols <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    merge_cols <- c("Response", "Stratum")
  }

  ft <- flextable(combined[, visible_cols])
  ft <- set_header_labels(
    ft,
    Response = "Response",
    Stratum = if ("Stratum" %in% visible_cols) "Stratum" else NULL,
    Term = "Term",
    SumSq = "Sum Sq",
    Df = "Df",
    Fvalue = "F value",
    PrF_label = "Pr(>F)"
  )

  ft <- apply_publication_style(ft, combined, merge_cols, which(combined$sig), "PrF_label")

  doc <- read_docx()
  doc <- body_add_par(doc, "Type III ANOVA", style = "Normal")
  doc <- body_add_par(doc, "", style = "Normal")
  doc <- body_add_flextable(doc, ft)

  if (!is.null(combined_contrasts) && length(combined_contrasts) > 0) {
    contrast_df <- bind_rows(combined_contrasts)
    contrast_df <- format_contrast_table(contrast_df)

    if (!is.null(contrast_df)) {
      if (!"Stratum" %in% names(contrast_df) ||
        (length(unique(contrast_df$Stratum)) == 1 && unique(contrast_df$Stratum) == "None")) {
        contrast_df$Stratum <- NULL
        c_visible_cols <- c("Response", "Factor", "contrast", "estimate", "SE", "df", "t.ratio", "lower.CL", "upper.CL", "p_label")
        c_merge_cols <- c("Response")
      } else {
        c_visible_cols <- c("Response", "Stratum", "Factor", "contrast", "estimate", "SE", "df", "t.ratio", "lower.CL", "upper.CL", "p_label")
        c_merge_cols <- c("Response", "Stratum")
      }

      c_visible_cols <- intersect(c_visible_cols, names(contrast_df))
      contrast_ft <- flextable(contrast_df[, c_visible_cols])
      contrast_ft <- set_header_labels(
        contrast_ft,
        Response = "Response",
        Stratum = if ("Stratum" %in% c_visible_cols) "Stratum" else NULL,
        Factor = if ("Factor" %in% c_visible_cols) "Factor" else NULL,
        contrast = "Contrast",
        estimate = "Estimate",
        SE = "SE",
        df = "df",
        t.ratio = "t-ratio",
        lower.CL = if ("lower.CL" %in% c_visible_cols) "Lower CL" else NULL,
        upper.CL = if ("upper.CL" %in% c_visible_cols) "Upper CL" else NULL,
        p_label = "p-value"
      )

      contrast_ft <- apply_publication_style(
        contrast_ft,
        contrast_df,
        c_merge_cols,
        which(contrast_df$sig),
        "p_label"
      )

      doc <- body_add_par(doc, "", style = "Normal")
      doc <- body_add_par(doc, "Tukey contrasts", style = "Normal")
      doc <- body_add_par(doc, "", style = "Normal")
      doc <- body_add_flextable(doc, contrast_ft)
    }
  }

  doc <- body_add_par(doc, "")
  doc <- body_add_par(doc, sprintf("Generated by Table Analyzer on %s", Sys.Date()))
  doc <- body_add_par(doc, "Significant p-values (< 0.05) in bold.", style = "Normal")
  print(doc, target = file)
}

prepare_docx_tables <- function(content, response_name = NULL, stratum_label = NULL) {
  anova_tables <- list()
  contrast_tables <- list()

  if (!is.null(content$anova_table)) {
    resp_label <- if (!is.null(response_name)) response_name else "Response"
    stratum_val <- if (!is.null(stratum_label)) stratum_label else "None"

    anova_tbl <- content$anova_table
    anova_tbl$Response <- resp_label
    anova_tbl$Stratum <- stratum_val
    if (!"Term" %in% names(anova_tbl) && "Effect" %in% names(anova_tbl)) {
      anova_tbl$Term <- anova_tbl$Effect
    }

    p_col <- grep("^Pr|p\\.value|p.value", names(anova_tbl), value = TRUE)[1]
    if (!is.null(p_col) && !"PrF" %in% names(anova_tbl)) {
      anova_tbl$PrF <- anova_tbl[[p_col]]
    }

    anova_tables <- list(anova_tbl)

    if (!is.null(content$posthoc_table)) {
      contrast_tbl <- content$posthoc_table
      contrast_tbl$Response <- resp_label
      contrast_tbl$Stratum <- stratum_val
      contrast_tables <- list(contrast_tbl)
    }
  } else if (!is.null(content$anova)) {
    anova_tables <- content$anova
    contrast_tables <- content$contrasts
  } else {
    anova_tables <- content
  }

  list(anova = anova_tables, contrasts = contrast_tables)
}

apply_publication_style <- function(ft, data, merge_cols, sig_rows = integer(0), sig_col = NULL) {
  ft <- merge_v(ft, j = intersect(merge_cols, ft$col_keys))
  ft <- fontsize(ft, part = "all", size = 10)
  ft <- bold(ft, part = "header", bold = TRUE)
  ft <- color(ft, part = "header", color = "black")
  ft <- align(ft, align = "center", part = "all")

  if (!is.null(sig_col) && sig_col %in% ft$col_keys && length(sig_rows) > 0) {
    ft <- bold(ft, i = sig_rows, j = sig_col, bold = TRUE)
  }

  ft <- border_remove(ft)
  black <- fp_border(color = "black", width = 1)
  thin <- fp_border(color = "black", width = 0.5)

  ft <- border(ft, part = "header", border.top = black)
  ft <- border(ft, part = "header", border.bottom = black)

  if ("Response" %in% names(data)) {
    resp_index <- which(diff(as.numeric(factor(data$Response))) != 0)
    if (length(resp_index) > 0) {
      ft <- border(ft, i = resp_index, part = "body", border.bottom = thin)
    }
  }

  if (nrow(data) > 0) {
    ft <- border(ft, i = nrow(data), part = "body", border.bottom = black)
  }

  ft <- set_table_properties(ft, layout = "autofit", width = 0.9)
  ft <- padding(ft, padding.top = 2, padding.bottom = 2, padding.left = 2, padding.right = 2)
  ft
}

format_contrast_table <- function(df) {
  if (is.null(df) || nrow(df) == 0) return(NULL)

  if (!"Response" %in% names(df)) df$Response <- "Response"
  if (!"Stratum" %in% names(df)) df$Stratum <- "None"
  if (!"Factor" %in% names(df) && "factor" %in% names(df)) df$Factor <- df$factor

  if (!"Factor" %in% names(df)) {
    df$Factor <- NA_character_
  }

  numeric_cols <- names(df)[sapply(df, is.numeric)]
  if (length(numeric_cols) > 0) {
    for (col in numeric_cols) {
      df[[col]] <- round(df[[col]], 3)
    }
  }

  p_col <- grep("^p\\.value|^p.value|^p_?value", names(df), value = TRUE)[1]
  if (is.null(p_col)) return(NULL)

  df$p_label <- ifelse(df[[p_col]] < 0.001, "<0.001", sprintf("%.3f", df[[p_col]]))
  df$sig <- df[[p_col]] < 0.05

  df
}

#### Table Analyzer â€” Shared ANOVA Module  ####
#### Section: UI & Output Binding ####

build_anova_layout_controls <- function(ns, input, info) {
  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  n_responses <- if (!is.null(info$responses)) length(info$responses) else 0

  build_grid_section <- function(title, grid_id, row_help, col_help) {
    tagList(
      h5(title),
      plot_grid_ui(
        id = ns(grid_id),
        rows_help = row_help,
        cols_help = col_help
      )
    )
  }

  strata_inputs <- if (has_strata) {
    build_grid_section(
      title = "Across strata:",
      grid_id = "strata_grid",
      row_help = "Set how many rows of plots to use when displaying different strata.",
      col_help = "Set how many columns of plots to use when displaying different strata."
    )
  } else {
    NULL
  }

  response_inputs <- if (!is.null(n_responses) && n_responses > 1) {
    build_grid_section(
      title = "Across responses:",
      grid_id = "response_grid",
      row_help = "Set the number of plot rows when multiple responses are shown together.",
      col_help = "Set the number of plot columns when multiple responses are shown together."
    )
  } else {
    NULL
  }

  tagList(strata_inputs, response_inputs)
}


#### Formula utilities ####

render_anova_results <- function(ns, model_info, module_label = "ANOVA") {
  if (is.null(model_info)) return(NULL)
  
  responses <- model_info$responses
  strata_info <- model_info$strata
  
  # No stratification
  if (is.null(strata_info)) {
    tabs <- lapply(seq_along(responses), function(i) {
      tabPanel(
        title = responses[i],
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i)))
        )
      )
    })
    return(do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs)))
  }
  
  # Stratified
  strata_levels <- strata_info$levels
  tabs <- lapply(seq_along(responses), function(i) {
    response_name <- responses[i]
    stratum_tabs <- lapply(seq_along(strata_levels), function(j) {
      stratum_name <- strata_levels[j]
      tabPanel(
        title = stratum_name,
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i, "_", j)))
        )
      )
    })
    tabPanel(
      title = response_name,
      do.call(tabsetPanel, c(list(id = ns(paste0("strata_tabs_", i))), stratum_tabs))
    )
  })
  do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs))
}

bind_anova_outputs <- function(ns, output, models_reactive) {
  observeEvent(models_reactive(), {
    model_info <- models_reactive()
    if (is.null(model_info)) return()
    
    responses <- model_info$responses
    model_list <- model_info$models
    strata_info <- model_info$strata
    factors <- unlist(model_info$factors, use.names = FALSE)
    
    # --- Non-stratified case ---
    if (is.null(strata_info)) {
      for (i in seq_along(responses)) {
        local({
          idx <- i
          response_name <- responses[i]
          model_entry <- model_list[[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx),
            download_id = paste0("download_", idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors
          )
        })
      }
      return()
    }
    
    # --- Stratified case ---
    strata_levels <- strata_info$levels
    for (i in seq_along(responses)) {
      for (j in seq_along(strata_levels)) {
        local({
          idx <- i
          stratum_idx <- j
          response_name <- responses[i]
          stratum_label <- strata_levels[j]
          model_entry <- model_list[[stratum_label]][[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx, "_", stratum_idx),
            download_id = paste0("download_", idx, "_", stratum_idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors,
            stratum_label = stratum_label
          )
        })
      }
    }
  })
}

#### Results export ####

bind_single_model_outputs <- function(output, summary_id, download_id,
                                      model_entry, response_name, factors,
                                      stratum_label = NULL) {
  output[[summary_id]] <- renderPrint({
    print_anova_summary_and_posthoc(model_entry, factors)
  })

  output[[download_id]] <- downloadHandler(
    filename = function() {
      base <- paste0("anova_results_", sanitize_name(response_name))
      if (!is.null(stratum_label)) {
        base <- paste0(base, "_stratum_", sanitize_name(stratum_label))
      }
      paste0(base, "_", Sys.Date(), ".docx")
    },
    content = function(file) {
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        stop("Model not available for download due to fitting error.")
      }
      results <- prepare_anova_outputs(model_entry$model, factors)
      if (!is.null(results$error)) {
        stop(paste0("ANOVA results unavailable: ", results$error))
      }
      if (is.null(results$anova_table)) {
        stop("ANOVA results are unavailable for export.")
      }
      write_anova_docx(
        file = file,
        content = results,
        response_name = response_name,
        stratum_label = stratum_label
      )
    }
  )
}

sanitize_name <- function(name) {
  safe <- gsub("[^A-Za-z0-9]+", "_", name)
  safe <- gsub("_+", "_", safe)
  safe <- gsub("^_|_$", "", safe)
  if (!nzchar(safe)) safe <- "unnamed"
  safe
}

print_anova_summary_and_posthoc <- function(model_entry, factors) {
  if (is.null(model_entry) || (is.list(model_entry) && is.null(model_entry$model))) {
    cat("Model is not available.\n")
    return(invisible(NULL))
  }

  if (!is.null(model_entry$error)) {
    cat(format_safe_error_message("Model fitting failed", model_entry$error), "\n", sep = "")
    return(invisible(NULL))
  }

  model_obj <- model_entry$model
  results <- prepare_anova_outputs(model_obj, factors)
  if (!is.null(results$error)) {
    cat(format_safe_error_message("ANOVA computation failed", results$error), "\n", sep = "")
    return(invisible(NULL))
  }
  if (is.null(results$anova_object)) {
    cat("ANOVA results are unavailable.\n")
    return(invisible(NULL))
  }
  print(results$anova_object)

  if (length(results$posthoc_details) == 0) {
    cat("\nNo post-hoc Tukey comparisons were generated.\n")
  } else {
    for (factor_nm in names(results$posthoc_details)) {
      details <- results$posthoc_details[[factor_nm]]
      if (!is.null(details$error)) {
        cat(
          "\n",
          format_safe_error_message(
            paste("Post-hoc Tukey comparisons for", factor_nm, "failed"),
            details$error
          ),
          "\n",
          sep = ""
        )
      } else if (!is.null(details$table)) {
        cat("\nPost-hoc Tukey comparisons for", factor_nm, ":\n")
        print(details$table)
      }
    }
  }
  invisible(results)
}

#### Section: Model Fitting & Preparation ####

#### Section: Utility Helpers ####

anova_protect_vars <- function(vars) {
  if (is.null(vars) || length(vars) == 0) return(vars)

  vals <- vapply(vars, function(v) {
    if (is.null(v) || is.na(v) || !nzchar(v)) return("")
    if (grepl("^`.*`$", v)) v else paste0("`", v, "`")
  }, character(1))

  vals[nzchar(vals)]
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Two-way ANOVA Module
# ===============================================================

two_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order_1")),
      uiOutput(ns("level_order_2")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show results", width = "100%"),
          "Fit the two-way ANOVA with the selected factors and responses."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
          "Save all ANOVA tables, post-hoc results, and diagnostics to disk."
        ))
      )
    ),
    results = tagList(
      uiOutput(ns("summary_ui"))
    )
  )
}

two_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    responses <- multi_response_server("response", filtered_data)

    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      cat_cols <- names(data)[sapply(data, function(x) is.character(x) || is.factor(x))]

      tagList(
        multi_response_ui(ns("response")),
        with_help_tooltip(
          selectInput(
            ns("factor1"),
            "Categorical predictor 1 (x-axis)",
            choices = cat_cols,
            selected = if (length(cat_cols) > 0) cat_cols[1] else NULL
          ),
          "Select the factor for the x-axis groups in the interaction plot."
        ),
        with_help_tooltip(
          selectInput(
            ns("factor2"),
            "Categorical predictor 2 (lines)",
            choices = cat_cols,
            selected = if (length(cat_cols) > 1) cat_cols[2] else NULL
          ),
          "Select the factor for the lines in the interaction plot."
        )
      )
    })
    
    strat_info <- stratification_server("strat", filtered_data)
    
    # -----------------------------------------------------------
    # Level order selections
    # -----------------------------------------------------------
    output$level_order_1 <- renderUI({
      req(filtered_data(), input$factor1)
      levels1 <- resolve_order_levels(filtered_data()[[input$factor1]])
      with_help_tooltip(
        selectInput(
          ns("order1"),
          paste("Order of levels (first = reference)", input$factor1, "(x-axis)"),
          choices = levels1,
          selected = levels1,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s for the x-axis; the first level is the reference.", input$factor1)
      )
    })
    
    output$level_order_2 <- renderUI({
      req(filtered_data(), input$factor2)
      levels2 <- resolve_order_levels(filtered_data()[[input$factor2]])
      with_help_tooltip(
        selectInput(
          ns("order2"),
          paste("Order of levels (first = reference)", input$factor2, "(lines)"),
          choices = levels2,
          selected = levels2,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s for the line colours; the first level is the reference.", input$factor2)
      )
    })
    
    # -----------------------------------------------------------
    # Model fitting (via shared helper)
    # -----------------------------------------------------------
    models <- eventReactive(input$run, {
      df <- filtered_data()
      req(df, input$factor1, input$order1, input$factor2, input$order2)
      resp_vals <- responses()
      validate(
        need(length(resp_vals) > 0, "Please select at least one response variable."),
        need(
          !identical(input$factor1, input$factor2),
          "Categorical predictor 1 and 2 must be different variables."
        ),
        need(all(input$order1 %in% unique(df[[input$factor1]])), "Invalid level order for first factor."),
        need(all(input$order2 %in% unique(df[[input$factor2]])), "Invalid level order for second factor.")
      )
      validate_numeric_columns(df, resp_vals, "response variables")
      prepare_stratified_anova(
        df = df,
        responses = resp_vals,
        model = "twoway_anova",
        factor1_var = input$factor1,
        factor1_order = input$order1,
        factor2_var = input$factor2,
        factor2_order = input$order2,
        stratification = strat_info()
      )
    })

    # -----------------------------------------------------------
    # Download all results as one combined DOCX
    # -----------------------------------------------------------
    output$download_all <- downloadHandler(
      filename = function() {
        model_info <- models()
        req(model_info)
        
        n_resp <- length(model_info$responses)
        n_strata <- if (is.null(model_info$strata)) 0 else length(model_info$strata$levels)
        strata_label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        timestamp <- format(Sys.time(), "%Y%m%d-%H%M")
        sprintf("anova_results_%sresp_%s_%s.docx", n_resp, strata_label, timestamp)
      },
      content = function(file) {
        model_info <- models()
        req(model_info)
        download_all_anova_results(model_info, file)
      }
    )
    
    # -----------------------------------------------------------
    # Render results
    # -----------------------------------------------------------
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "Two-way ANOVA")
    })
    
    # -----------------------------------------------------------
    # Render model summaries + downloads (shared helper)
    # -----------------------------------------------------------
    bind_anova_outputs(ns, output, models)

    anova_results <- reactive({
      mod <- models()
      req(mod)

      res <- compile_anova_results(mod)
      data_used <- mod$data_used

      list(
        analysis_type = "ANOVA",
        type = "twoway_anova",
        data_used = data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        errors = res$errors,
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })

    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” Two-way ANOVA (Apply-button version)
# ===============================================================

visualize_twoway_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize two-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c(
            "Lineplots (mean Â± SE)" = "lineplot_mean_se",
            "Barplots (mean Â± SE)"  = "barplot_mean_se"
          ),
          selected = "lineplot_mean_se"
        ),
        "Pick the chart style you prefer for viewing group means and uncertainty."
      ),
      conditionalPanel(
        condition = sprintf("input['%s'] === 'lineplot_mean_se'", ns("plot_type")),
        fluidRow(
          column(
            6,
            with_help_tooltip(
              checkboxInput(
                ns("lineplot_show_lines"),
                "Connect means with lines",
                value = TRUE
              ),
              "Draw connecting lines between group means."
            )
          ),
          column(
            6,
            with_help_tooltip(
              checkboxInput(
                ns("lineplot_use_dodge"),
                "Dodge grouped means",
                value = FALSE
              ),
              "Offset the level means of the second factor along the x-axis to prevent overlap."
            )
          )
        )
      ),
      uiOutput(ns("axis_and_jitter")),
      subplot_size_ui(ns),
      uiOutput(ns("layout_controls")),
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = TRUE)),
        column(
          6,
          tagList(
            base_size_ui(
              ns,
              default = 13,
              help_text = "Adjust the base font size used for the ANOVA plots."
            ),
            br(),
            uiOutput(ns("common_legend_controls"))
          )
        )
      ),
      
      br(),
      
      fluidRow(
        column(6, actionButton(ns("apply_plot"), "Apply changes", width = "100%")),
        column(6, downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"))
      )
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}



visualize_twoway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    stored <- reactiveValues(
      plot = NULL,
      warning = NULL,
      layout = NULL,
      plot_width = NULL,
      plot_height = NULL
    )
    
    df <- reactive(filtered_data())
    
    color_var <- reactive({
      info <- model_info()
      if (is.null(info) || is.null(info$factors)) return(NULL)
      info$factors$factor2
    })
    
    factor2_levels <- reactive({
      info <- model_info()
      if (is.null(info) || is.null(info$orders)) return(NULL)
      info$orders$order2
    })
    
    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = color_var,
      multi_group = TRUE,
      level_order_reactive = factor2_levels
    )
    
    base_size <- base_size_server(input = input, default = 13)
    
    strata_grid <- plot_grid_server("strata_grid")
    response_grid <- plot_grid_server("response_grid")
    
    # UI render
    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })
    
    output$axis_and_jitter <- renderUI({
      jitter_widget <- NULL
      if (input$plot_type == "lineplot_mean_se") {
        jitter_widget <- with_help_tooltip(
          checkboxInput(
            ns("lineplot_show_jitter"),
            "Overlay jittered data",
            value = isTRUE(input$lineplot_show_jitter)
          ),
          "Overlay raw observations with jitter."
        )
      }
      
      fluidRow(
        column(
          6,
          with_help_tooltip(
            checkboxInput(
              ns("share_y_axis"),
              "Use common y-axis across plots",
              value = isTRUE(input$share_y_axis)
            ),
            "Use the same y-scale for all panels."
          )
        ),
        column(6, jitter_widget)
      )
    })
    
    # Common legend UI
    legend_state <- reactiveValues(
      enabled = FALSE,
      position = "bottom"
    )
    
    common_legend_available <- reactive({
      info <- model_info()
      if (is.null(info) || !identical(info$type, "twoway_anova"))
        return(FALSE)
      has_mult_resp <- length(info$responses %||% character()) > 1
      has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
      has_mult_resp || has_strata
    })
    
    observeEvent(input$use_common_legend, {
      legend_state$enabled <- isTRUE(input$use_common_legend)
    }, ignoreNULL = TRUE)
    
    observeEvent(input$common_legend_position, {
      legend_state$position <- input$common_legend_position
    }, ignoreNULL = TRUE)
    
    output$common_legend_controls <- renderUI({
      if (!common_legend_available()) return(NULL)
      
      legend_enabled <- isTRUE(legend_state$enabled)
      
      legend_checkbox <- with_help_tooltip(
        checkboxInput(
          ns("use_common_legend"),
          "Use common legend",
          value = legend_enabled
        ),
        "Merge legends across subplots."
      )
      
      legend_position <- NULL
      if (legend_enabled) {
        legend_position <- with_help_tooltip(
          selectInput(
            ns("common_legend_position"),
            "Legend position",
            c("Bottom" = "bottom", "Right" = "right", "Top" = "top", "Left" = "left"),
            selected = legend_state$position
          ),
          "Choose where to place the combined legend."
        )
      }
      
      tagList(legend_checkbox, legend_position)
    })
    
    # ------------------------------------------------------------------
    # APPLY button (core logic)
    # ------------------------------------------------------------------
    observeEvent(input$apply_plot, {
      data <- df()
      info <- model_info()
      
      stored$plot_width  <- input$plot_width
      stored$plot_height <- input$plot_height
      
      if (is.null(info) || is.null(data) || nrow(data) == 0) {
        stored$warning <- "No data or ANOVA results available."
        stored$plot <- NULL
        return()
      }
      
      # Build layout
      layout_inputs <- list(
        strata_rows = strata_grid$rows(),
        strata_cols = strata_grid$cols(),
        resp_rows   = response_grid$rows(),
        resp_cols   = response_grid$cols()
      )
      
      # Legend handling
      legend_supported <- input$plot_type %in% c("lineplot_mean_se", "barplot_mean_se")
      use_common_legend <- legend_supported && common_legend_available() && legend_state$enabled
      legend_position <- if (use_common_legend) legend_state$position else NULL
      
      # Compute all plots
      results <- list(
        lineplot_mean_se = plot_anova_lineplot_meanse(
          data, info, layout_inputs,
          line_colors  = custom_colors(),
          base_size    = base_size(),
          show_lines   = input$lineplot_show_lines,
          show_jitter  = input$lineplot_show_jitter,
          use_dodge    = input$lineplot_use_dodge,
          share_y_axis = input$share_y_axis,
          common_legend = use_common_legend,
          legend_position = legend_position
        ),
        
        barplot_mean_se = plot_anova_barplot_meanse(
          data, info, layout_inputs,
          line_colors       = custom_colors(),
          base_size         = base_size(),
          posthoc_all       = info$posthoc,
          share_y_axis      = input$share_y_axis,
          common_legend     = use_common_legend,
          legend_position   = legend_position
        )
      )
      
      chosen <- input$plot_type
      chosen_result <- results[[chosen]]

      stored$warning <- chosen_result$warning
      stored$plot    <- chosen_result$plot
      stored$layout  <- chosen_result$layout

      apply_grid_defaults_if_empty(
        input,
        session,
        "strata_grid",
        chosen_result$defaults$strata,
        n_items = chosen_result$panel_counts$strata
      )

      apply_grid_defaults_if_empty(
        input,
        session,
        "response_grid",
        chosen_result$defaults$responses,
        n_items = chosen_result$panel_counts$responses
      )
    })
    
    # ------------------------------------------------------------------
    # OUTPUTS
    # ------------------------------------------------------------------
    
    output$plot_warning <- renderUI({
      if (!is.null(stored$warning))
        div(class = "alert alert-warning", stored$warning)
    })
    
    output$plot <- renderPlot({
      p <- stored$plot
      if (is.null(p)) return(NULL)
      print(p)
    },
    width = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      total_cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
      stored$plot_width * total_cols
    },
    height = function() {
      lay <- stored$layout
      if (is.null(lay)) return(600)
      total_rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
      stored$plot_height * total_rows
    },
    res = 96)
    
    output$download_plot <- downloadHandler(
      filename = function() paste0("anova_twoway_plot_", Sys.Date(), ".png"),
      content = function(file) {
        p <- stored$plot
        req(!is.null(p))
        
        lay <- stored$layout
        req(!is.null(lay))
        
        total_cols <- (lay$strata$cols %||% 1) * (lay$responses$cols %||% 1)
        total_rows <- (lay$strata$rows %||% 1) * (lay$responses$rows %||% 1)
        
        w_in <- (stored$plot_width  * total_cols) / 96
        h_in <- (stored$plot_height * total_rows) / 96
        
        ggsave(file, p, dpi = 300,
               width = w_in, height = h_in,
               units = "in", limitsize = FALSE)
      }
    )
  })
}

